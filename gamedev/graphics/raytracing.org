- playlist [[https://www.youtube.com/playlist?list=PLlrATfBNZ98edc5GshdBtREv5asFW3yXl][Ray Tracing]] by The Cherno
- The Timeless https://www.youtube.com/watch?v=T-9R0zAwL7s
- video Coding Adventure! by Sebastian Lague
  - [[https://www.youtube.com/watch?v=Qz0KTGYJtUk][Ray Tracing]]
  - [[https://www.youtube.com/watch?v=C1H4zIiCOaI][More Ray Tracing!]]
- video [[https://www.youtube.com/watch?v=ezXGTRSx1g8][How Ray Tracing Works]] by computerphile
- https://github.com/dannyfritz/awesome-ray-tracing
- https://www.scratchapixel.com/

- article: ps https://seriot.ch/projects/postscript_tiny_ray_tracer.html
- article: clojure https://www.abhirag.com/ray_tracer/
- article: C https://fabiensanglard.net/postcard_pathtracer/
- article: C++ https://fabiensanglard.net/rayTracing_back_of_business_card/
  - c++ -O3 -o card card.cpp

- 17 Video: Handmade Ray
  https://www.youtube.com/watch?v=pq7dV4sR7lg simple raycaster
  https://www.youtube.com/watch?v=ZAeU3Z0PmcU multithreading
  https://www.youtube.com/watch?v=xBBEkn1x7So replacing rand()
  https://www.youtube.com/watch?v=dpvrPYdTkPw SSE2 & AVX2
  https://www.youtube.com/watch?v=iHXYFbHAmlw brdf loading

* Video: RealTime Raytracing in Python
|---------------+-----+--------------------------------------------------------------------------|
| playlist      |     | https://www.youtube.com/playlist?list=PLn3eTxaOtL2Md9tyeycECvgT-FMsf0uAd |
| source code   | 0.1 | https://github.com/amengede/getIntoGameDev                               |
|               | 0.2 | https://github.com/mcfletch/pyopengl                                     |
| maths library | 0.3 | https://github.com/adamlwgriffiths/Pyrr                                  |
| arrays        |  22 | https://github.com/numpy/numpy                                           |
|---------------+-----+--------------------------------------------------------------------------|
** 1 Introduction to Raytracing
https://www.youtube.com/watch?v=NIAUFnNZGhE
- Vulkan has raytracing pipelines
- While we can mix both rasterizing and raytracing.
  1) With defer shading(?) and a light pass with raytracing.
  2) _Problem_ is that we cannot trace a game, we cannot recover the primary rays, we cannot the arbitrary LOD
- A shader if solving an _conditional_, it will solve both cases, and use one.
- Need to solve equations by each pixel at 60fps
  - one equation for each object
  - one equation for lighting/shadows
- Types
  1) Raytracing:
     - we solve an equation
     - from camera and possible from a light too
     - almost arbitrary LOD for simple parametrized shapes
  2) Pathtracing: bounces
  3) Raymarching:
     - we don't solve an equation
     - we simulated by a loop
     - by steps
     - Allows participating media to change it.
  4) Spheremarching:
     - not fixed step size
     - adapts to what is possible
     - can save some computation time.
     - Cannot interact with media.
     - Reduces backtracking.
** 2 Compute Shaders 101
- opengl 4.3 needed for compute shaders
- when accesing an image from a compute-shader is accessed as a image2d, NOT as a sampler2d
  - for that reason, the texture filtering it needs to be GL_NEAREST
- GL_RGBA32F
- https://stackoverflow.com/questions/44181875/ray-tracing-via-compute-shader-vs-screen-quad
  - Short answer: because compute shaders give you more effective tools to perform complex computations.
    - Important on complex scene, not so much for a "Cornell Box"
    - Many drives will abort if a single operation takes to long
    - Techniques like: use of glScissor, draw smaller quads, limit the workload.
      Is reinvented _compute shader_ *work groups* for controling job size
** 3 Getting data in
- aka passing the uniforms
  - still we can only pass so much data (breaks around 1024 spheres)
  - we can pass it through a texture or a SSBO
  - to pass more than 4 values on a texture you can package it as consecutives pixels
    a 1D array on the cpu, 2D interpreted by the GPU
    eg: in the shape 1024x2
- sphere class: center, radius, color
- camera class
  - thetha: angle around z axis (left to right)
  - phi   : angle around y axis, altitude (polar coordinates)
  #+begin_src python
    def recalculateVectors(self):
        # from "spherical coordinates"
        self.forwards = np.array([
            np.cos(np.deg2rad(self.theta)) * np.cos(np.deg2rad(self.phi)),
            np.sin(np.deg2rad(self.theta)) * np.cos(np.deg2rad(self.phi)),
            np.sin(np.deg2rad(self.phi))
            ], dtype=np.float32)
        self.right = pyrr.vector3.cross(self.forwards, np.array([0,0,1],dtype=np.float32))
        self.up = pyrr.vector3.cross(self.right, self.forwards)
  #+end_src
*** raytrace.compute
  #+begin_src glsl
    struct RenderState {
      float t;
      vec3 color;
      bool hit;
    };
    vec3 rayColor(Ray ray) {
      vec3 color = vec3(0.0);
      float nearestHit = 999999;
      bool hitSomething = false;
      RenderState renderState;
      for (int i = 0; i < sphereCount; i++) {
        renderState = hit(ray, spheres[i], 0.001, nearestHit, renderState);
        if (renderState.hit) {
          nearestHit = renderState.t;
          hitSomething = true;
        }
      }
      if (hitSomething) {
        color = renderState.color;
      }
      return color;
    }
    RenderState hit(Ray ray, Sphere sphere, tMin, tMax, RenderState renderState) {
      vec3 co = ray.origin - sphere.center;
      float a = dot(ray.direction, ray.direction);
      float b = 2 * dot(ray.direction, co);
      float c = dot(co, co) - sphere.radius * sphere.radius;
      float discriminant = b * b - (4 * a * c);
      if (discriminant > 0.0) {
        float t = (-b - sqrt(discriminant)) / (2 * a);
        if (t > tMin && t < tMax) {
          renderState.t = t;
          renderState.color = sphere.color;
          renderState.hit = true;
          return renderState;
        }
      }
      renderState.hit = false;
      return renderState;
    }
  #+end_src
** TODO 4 Rendering Planes (20:00)
- if we store the data of the plane and the spheres in the same texture we will waste some space
  - since the plane has more information than the sphere, we will waste around 3 pixel per sphere
  - still *seems* to be more efficient for this to have bigger textures than more smaller ones
  - spheres strides will need to be updated to leave 20 bytes betwen sphere
*** plane class
- not infinite, but constrained
#+begin_src python
  class Plane:
      def __init__(self, normal, tangent, bitangent, uMin, uMax, vMin, vMax, center, color):
          self.normal = np.array(normal, dtype=np.float32)
          self.tangent = np.array(tangent, dtype=np.float32)
          self.bitangent = np.array(bitangent, dtype=np.float32)
          self.uMin = uMin
          self.uMax = uMax
          self.vMin = vMin
          self.vMax = vMax
          self.center = np.array(center, dtype=np.float32)
          self.color = np.array(color, dtype=np.float32)
#+end_src
*** raytrace.compute
#+begin_src glsl
  struct Plane {
    vec3 center;
    vec3 tangent;
    vec3 bitangent;
    vec3 normal;
    float uMin;
    float uMax;
    float vMin;
    float vMax;
    vec3 color;
  };
  uniform float PlaneCount;
  RenderState hit(Ray ray, Plane plane, float tMin, floattMax, RenderState renderstate) {
  }
  Plane unpackPlane(int index) {
    Plane plane;
    vec4 attributeChunk = imageLoad(objects, ivec2(0, index));
    plane.center = attributeChunk.xyz;
    plane.tangent.x = attributeChunk.w;

    attributeChunk = imageLoad(objects, ivec2(1,index));
    plane.tangent.yz = attributeChunk.xy;
    plane.bitangent.xy = attributeChunk.zw;

    attributeChunk = imageLoad(objects, ivec2(2,index));
    plane.bitangent.z = attributeChunk.x;
    plane.normal = attributeChunk.yzw;

    attributeChunk = imageLoad(objects, ivec2(3,index));
    plane.uMin = attributeChunk.x;
    plane.uMax = attributeChunk.y;
    plane.vMin = attributeChunk.z;
    plane.vMax = attributeChunk.w;

    attributeChunk = imageLoad(objects, ivec2(4,index));
    plane.color = attributeChunk.xyz;

    return plane;
  }
#+end_src
* Book: The Ray Tracer Challenge

- Bonus Chapters http://www.raytracerchallenge.com/#bonus
- Errata https://pragprog.com/cms/errata/jbtracer-errata/
  - Cofactor 4x4
    - https://forum.devtalk.com/t/the-ray-tracer-challenge-page-37-4x4-cofactor/41433/2
    - https://forum.raytracerchallenge.com/thread/88/cofactor-4x4-matrix
- Forums
  - https://forum.raytracerchallenge.com/
  - https://devtalk.com/books/the-ray-tracer-challenge
- External Links:
  - https://betterexplained.com/articles/vector-calculus-understanding-the-dot-product/
- Third party sources
  - C https://github.com/LiquidityC/ray_tracer_challenge/
    - complete 16 chapters
    - uses CMake
      - has some "-fsanitize=address -g", "tracer ... m asan"
      - uses Unity for testing
    - calloc()
    - realloc()
    - usage of _init() for structs
    - unions for vec3

** 1 Tuples

*** Types

- Point: (x,y,z,1)
- Vector: (x,y,z,0)

*** Operations

**** Equality
  - by an epsilon of difference
**** Addition
  - translating a _point_ by a _vector_
  - add 2 _vectors_
  - +adding 2 points+ INVALID
**** Subtraction
  - find _vector_ between 2 _points_
  - move a _point_ backward by a _vector_
  - the change in direction between 2 _vector_
  - +a point from a vector+
**** Negation
  - to know the "opposite" of some _vector_
**** Scalar Multiplication
**** Scalar Division
**** Magnitud/Length
  - aka sqrt(x²+y²+z²)
  - the magnitude of the distance of a vector
**** Normalization
  - vector to unit vector
  - divide each component by its magnitude
**** Dot Product (aka scalar/inner product)
  - takes 2 vectors, returns a scalar
  - the sum of the products of each component/vector
  - the smaller it is, the larger the angle between
**** Cross Product
  - takes 2 vectors, returns a vector
    - perpendicular to both inputs
  - use v3 only
  - order of operation matters
  - cross(a,b)
    a.y*b.z - a.z*b.y,
    a.z*b.x - a.x*b.z,
    a.x*b.y - a.y*b.x

*** Exercise

- Datastructures:
  - Projectile: has position(point) and velocity(vector)
  - Environment: has gravity(vector) and wind(vector)

- advances projectile 1 time unit/tick
#+begin_src
  f tick(env  environment,
         proj projectile) -> projectile
    proj.pos = proj.pos + proj.vel
    proj.vel = proj.vel + env.gravity + env.wind
#+end_src

** 2 Color

*** Color

- 3 components: red, green, blue
- values 0-1, but accepts higher values

- Operations, due transparency or reflection
  - adding
  - subtracting
  - multiplication:
    - to blend 2 colors (aka hadamard/schur product)
  - scalar multiplication

*** Canvas

- a rectangular grid of rgb pixels
- configurable size
- initialized to black (0,0,0)
- No draw elements outside canvas

- operation
  #+begin_src
   red <- color(1,0,0)
   write_pixel(canvas, 2, 3, red) -> void
   canvas_to_ppm(canvas) -> string
  #+end_src

- saving
  - File format: PPM (Portable Pixmap)
    - P3 for plain(text)
    - max color component value should be clamped
    - no line should be >70 chars
    - ends with a newline
    - Example: 80x40, 255 maximum color value
    #+begin_src ppm
      P3
      80 40
      255
    #+end_src

** 3 Matrix

- RxC - Rows x Columns
- we would mainly use 4x4 matrices
  - later also create 2x2 and 3x3
- refer to it by a [R,C] index

- operations
  - create
  - equality

*** operation: multiplying

- multiplying by matrix (only 4x4)
  - results in a matrix
  - for: scaling, rotation, translation
  - in a specific way
    - AxB
    - C[row,col]
    - row of A * column of B
      - left to right
      - up to down
      - where * is the =dot product=
      - aka sum of products of each

- multiplying by tuple
  - results in a tuple
  - same as by matrix

*** identity matrix

- all zeros, except along the diagonal \ which are set to 1(ones)
- used as the default transformation matrix
- is the identity value for matrix multiplication
  - same as 1 is for multiplication

*** operation: transposing

- turns first row, into first column...
- =transpose(id) == id=

*** operation: inverting

- not every matrix is invertible
  - impossible if: determinant(A) = 0

- allows you to revert a multiplication
  #+begin_src
  if A*B=C => C*1/B=A
  #+end_src

- cofactor = (±1 * (minor = determinant(submat(M))))

**** submatrix(mat,row,col)
- result of removing 1 column and 1 row of a matrix
**** Determinant

- a number derived from a matrix
- for 2x2 is the difference of the product of diagonals
  = a*d - b*c
- for NxN
  - pick any row column
  - multiply each by its _cofactor_
  - sum them all

**** Minor

- a number
- for 3x3 matrices
- aka determinant of the submatrix
  - determinant(submatrix(A,1,0))

**** Cofactor

- a number
- the minor, with maybe their sign changed
- sign changes if row+column is odd number
- cofactor(A,0,0) = 56

**** Cofactor Expansion

- Long way
  1) Construct a matrix of cofactors of INPUT
  2) Transpose it
  3) Divide 2) it by the determinant of INPUT

- Short
  1) iterate over each cell
  2) divide the cofactor by the determinant of INPUT

** 4 Matrix Transformations

- allow us to display shapes, without describing each radius and location
- matrix multiplication is associative, _NOT commutative_
  - concatenate tranformations in the reverse order, that you want them applied
  - or you put the *identity matrix* as the first matrix in the multiplication
    - effectively inverting the chain order, back to "normal"

*** Translation

- movement by addition
- translation(x,y,z)
  - a 4x4 identity matrix
  - with (x,y,z) in the rightmost column ↓
- inverse of it, reverses the movement
- should affect Points(w=1), not Vectors(w=0)

*** Scaling

- movement by multiplication
- scaling(x,y,z)
  - a 4x4 identity matrix
  - replacing \ diagonal with (x,y,z,1)
- affects Points(w=1) AND Vectors(w=0)
  - to vectors, it changes it's length (grow or shrink if inverse)
- >1 bigger
- <1 smaller
- =reflection=
  - is scaling by a negative value
  - moves it to the other side of an axis

*** Rotation

- radians(deg)
  - = deg/180 * 𝛑
  - 360° = 2𝛑 radians

- multiplying tuple by rot matrix
  - different 4x4 matrixes for each axis rotation
  - clockwise, while looking towards axis negative end
    - left hand rule
  - rotation_x(rad)
    #+begin_src
      1   0     0   0
      0  cosr -sinr 0
      0  sinr  cosr 0
      0   0     0   1
    #+end_src
  - rotation_y(rad)
    #+begin_src
      cosr  0  sinr  0
       0    1   0    0
     -sinr  0  cosr  0
       0    0   0    1
    #+end_src
  - rotation_z(rad)
    #+begin_src
      cosr  -sinr  0  0
      sinr   cosr  0  0
        0     0    1  0
        0     0    0  1
    #+end_src
nn
*** Shearing

- or skew
- makes straight lines slanted
- changes tuple components in _proportion_ to the other components
- shearing(xy,xz,yx,yz,zx,zy) - 6 parameters
  #+begin_src
    1   xy  xz  0
    yz  1   yz  0
    zx  zy  1   0
    0   0   0   1
  #+end_src
*** Exercise: clock face

- using rotation matrix
- centerd at point(0,0,0) center
** 5 Ray-Sphere Intersections

- raycasting:
  - creating a ray/line
  - finding the intersection of it with the objects on the scene

- ray(origin Point, direction Vector) -> Ray
- position(Ray, t) -> Point
  - a point given a distance t along a ray
- sphere()
  - each invokation should return uniquely identified spheres (maybe by id)
  - assumming
    - unit spheres (radii = 1)
    - centered at origin
- intesect(Sphere,Ray)
