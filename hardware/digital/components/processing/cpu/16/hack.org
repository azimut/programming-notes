- https://en.wikipedia.org/wiki/Hack_computer
  - from "The Elements of Computing Systems"
    - by Noam Nissan, Shimon Schocken

#+CAPTION: General Architecture
#+ATTR_ORG: :width 400
[[https://upload.wikimedia.org/wikipedia/commons/thumb/7/76/Hack_Computer_Block_Diagram_2.png/600px-Hack_Computer_Block_Diagram_2.png]]

#+CAPTION: CPU Architecture
#+ATTR_ORG: :width 600
[[https://upload.wikimedia.org/wikipedia/commons/2/2c/Hack_Computer_CPU_Block_Diagram.png]]

* Video: From NAND To Tetris by "Tea Leaves"
https://www.youtube.com/playlist?list=PLu6SHDdOToSdD4-c9nZX2Qu3ZXnNFocOH
* Course: From NAND to Tetris

Teachers: Simon Schocken, Noam Nisan
Based on "The Elements of Computing Systems" book

home https://www.nand2tetris.org/
online IDE https://nand2tetris.github.io/web-ide/chip/

** Videos

*** 07 Twelve steps

https://www.youtube.com/watch?v=JtXvUoPx4Qs
- to appreciate interfaces that put all together

*** 12 TED - Shimon Schocken: The self-organizing computer course

https://www.youtube.com/watch?v=iE7YRHxwoDs
- to connect with the soul in the machine
- from first principles
- ~1000 NAND gates
- "reduction" is transforming a problem into a simpler one

*** Twelve steps (google) https://www.youtube.com/watch?v=IlPj5Rg1y2w
*** from NAND to Lambda https://www.youtube.com/watch?v=E6mCglfodPg

** Overview - Weeks

1) Logic Gates: elementary, composite (mux, adder, ...)
2) ALU
3) Registers and Memory
4) Low Level programs
5) Computer Architecture
6) Assembler

** Part 1 - Hardware

https://www.youtube.com/playlist?list=PLrDd_kMiAuNmSb-CKWQqq9oBFN_KNMTaI

*** 0.1 The Road Ahead

- in CS usually you don't need to worry about the HOW (implementation)
- is usually enough to only care about WHAT (abstraction) are you doing
- it's a feature of CS

*** 0.2 From NAND to Hack

- using ~Combinational Logic~ one can convert NAND to other logic gates, AND OR XOR...
- using ~Combinational~ and ~Sequential~ Logic (time and clock based) we build CPU/Registers/Memory
- turn *Digital Design* it into a *Computer Arquitecture*

*** 1.1 Boolean Logic

- Boolean identities laws:
  1) Commutative
  2) Associative
  3) Distributive
  4) De Morgan:
     - (not (and x y))=(or (not x) (not y))
     - (not (or x y))=(and (not x) (not y))
  5) Idempotence (and x x) = x
  6) Doble negation (not (not x)) = x

*** 1.2 Boolean Functions

- Boolean Functions can be represented
  - boolean expression
  - truth table

- While designing a circuit, we have a "truth table" (the desired phenomen we want to happen).
  - And we need to convert it to a "Boolean function".

- =There is NO algorithm to get the most efficient function from the truth table=

- Manual calculation (aka constructing a disjuntive normal form from a TT):
  1) write a formula/expression for each row with a truth (1) value in the table
  2) OR them all
  3) simplify

- Notice we represented our TT with only: AND, OR, NOT operations
- Those can then be constructed with NANDs (remember de Morgan)

*** 1.4 HDL
    - On a chip we have an interface (io) and the implementation.
    - On VHDL you have to label each edge(line) between chips to describe the parts.
    - Chip == Gate
      Pin  == edge between chips
    #+begin_src C
    /** Xor Gate: out = (a And Not(b)) Or (Not(a) And b) **/
    CHIP Xor {
      IN a,b;
      OUT out;
      PARTS:
      Not (in=a, out=nota);
      Not (in=b, out=notb);
      And (a=a,        b=notb,     out=aAndNotb);
      And (a=nota,     b=b,        out=notaAndb);
      Or  (a=aAndNotb, b=notaAndb, out=out);
    }
    #+end_src
*** 1.6
    - Bits in buses, bits manipulated together
    #+begin_src C
   CHIP And4 {
     IN a[4],b[4];
     OUT out[4];
     PARTS:
       AND(a=a[0], b=b[0], out=out[0]);
       AND(a=a[1], b=b[1], out=out[1]);
       AND(a=a[2], b=b[2], out=out[2]);
       AND(a=a[3], b=b[3], out=out[3]);
   }
    #+end_src
*** 1.7
    - Elementary logic gates: not,and,or,xor,mux,dmux
    - 16-bit variant: not16,and16,or16,mux16
    - Multiway variant: Or8Way,Mux4Way16,Mux8Way16,DMux4Way,DMux8Way
    - Mux gates take 3 inputs: a,b,sel.
      - If sel is 1 then a is returned
      - if sel is 0 then b is returned
    - AndMuxOr
    #+begin_src c
    CHIP AndMuxOr {
    IN a,b,sel;
    OUT out;
    PARTS:
    And (a=a, b=b, out=andOut);
    Or  (a=a, b=b, out=orOut);
    Mux (a=andOut,b=orOut,sel=sel,out=out);
    }
    #+end_src
    - DeMux, takes an input and a selector. Based on the sel, "channels" to a or b (other gets 0).
** Part 2 - Software

https://www.youtube.com/playlist?list=PLrDd_kMiAuNmllp9vuPqCuttC1XL9VyVh

- High Level Language compiler
- OS
- stdlib
