#+TITLE: MCS-48

|----------+----------------------------------------------------|
| manual   | https://devsaurus.github.io/mcs-48/mcs-48.pdf      |
| wiki     | [[https://en.wikipedia.org/wiki/Intel_MCS-48][english]] [[https://es.wikipedia.org/wiki/Intel_MCS-48][spanish]] [[https://en.wikipedia.org/wiki/Intel_MCS-48#/media/File:EPROM-Microcontroller_Intel_8749H_(chip)_-_(1).jpg][die]]                                |
| wiki     | https://handwiki.org/wiki/Engineering:Intel_MCS-48 |
| timeline | https://timeline.intel.com/1976/mcs-48             |
|----------+----------------------------------------------------|

- 1976
- Models: 8048, 8035, 8748/9 (EPROM)
- Intel's first =Microcontroller= (aka microcomputer)
- Still manufactured in the 90's to support older designs (cheap)
- Used in
  - [[https://en.wikipedia.org/wiki/Magnavox_Odyssey_2][Magnavox's Oddysey 2]] video game console (1978)
  - [[https://en.wikipedia.org/wiki/Entex_Adventure_Vision][Adventure Vision]] video game console (1982)
  - Korg Trident Series
  - Korg Poly-61
  - Roland Jupiter-4
  - Roland Promars

* architecture

|--------+--------+---------------|
|  <c>   |        |               |
|  8048  | 1k ROM | 64 bytes RAM  |
|  8049  | 2k ROM | 128 bytes RAM |
|  8050  | 4k ROM | 256 bytes RAM |
| 8748/9 | EPROM  |               |
|--------+--------+---------------|

- (Modified) Harvard Architecture https://en.wikipedia.org/wiki/Modified_Harvard_architecture
  - loose separation between code and data
  - _allows memory that contains instructions to be accesed as data_

- 11MHz (divided by 15 internally?)
- 8 bit data
- 96 instructions
  - 1 byte are those that only have the opcode (80%?) (aka operate)
  - 2 bytes are immediate instructions
  - 2 bytes are memory reference intructions

** Timer

- 8bit binary counter (0x00 - 0xFF)
- on overflow:
  - sets a flag flip-flop
    - can be _test_ with ~JTF~ instruction
    - can be _reset_ with ~JFT~ instruction or RST(4) pin
  - if timer interrupt is enabled
    - generates an interruption request
    - calling subroutine in addr 7
    #+begin_src asm
      en  tcnti ;  enable timer counter interrupt
      dis tcnti ; disable timer counter interrupt (also removes it)
    #+end_src

- start/stop
  #+begin_src asm
    strt t    ; start as a TIMER, counts the internal clock = cycle clock / 32
    strt cnt  ; start as a event COUNTER, counts T1 changes (aka external events), set to 255 acts as a second INT
    stop tcnt ; stop any, also by RST
  #+end_src

- set/initialized through the accumulator
  #+begin_src asm
    mov t, a ; timer = acc
    mov a, t ; acc   = timer
  #+end_src

** Conditional Branch Logic

(?)

|-----------------------+---------+-------------|
|          <c>          |   <c>   |     <c>     |
|-----------------------+---------+-------------|
|      accumulator      | all 0's | not all 0's |
|   accumulator bits    |    -    |      1      |
|      carry flag       |    0    |      1      |
|  user flags (F0,F1)   |    -    |      1      |
|  time overflow flag   |    -    |      1      |
|-----------------------+---------+-------------|
|  test input (T0,T1)   |    0    |      1      |
| interrupt input (INT) |    0    |      -      |
|-----------------------+---------+-------------|

** PSW (Program Status Word)

#+begin_src pikchr :file mcs48-psw.svg :result graphics :exports result
  boxwid = 0.7; boxht = boxwid
  "0  " below big bold
  box "stack pointer" "" "3" width (boxwid*3)
  box "unused" """1" fill gray
  box "BS" "" "1"
  box "F0" "" "1"
  box "AC" "" "1"
  box "CY" "" "1"
  "  7" below big bold
#+end_src

#+ATTR_ORG: :width 700
#+RESULTS:
[[file:mcs48-psw.svg]]

- 4 MSB cpu flags are stored at the top of the ~stack~, when a subroutine CALL or INT(errupt) along with the _program counter_
- can be read/write as a whole from/to the accumulator
  #+begin_src asm
    mov psw,a
    mov a,psw
  #+end_src
- 8 bit wide
  - 3 stack pointer
    - initialized to 0, points to 8-9 of RAM (start of stack)
    - incremented by 1 on each CALL/INT(errupt)
    - decremented by 1 on RETR, aka the end of a subroutine
      - RET does _not_ update the PSW
    - on overflow, goes back to pointing to 8-9 (111->000)
  - 1 unused
  - 1 BS working register bank switch
    #+begin_src asm
      sel rb0 ; = 0 for R0  - R7
      sel rb1 ; = 1 for R0' - R7'
    #+end_src
  - 1 F0 flag
    - tested by ~JF0~
  - 1 AC auxiliary carry flag
    - generated by an ~ADD~ and used by ~DA A~
  - 1 CY carry flag

** Program Counter
#+begin_src pikchr :file mcs48-pc.svg :result graphics :exports result
  boxwid = 0.5; boxht = boxwid
  "0  " below big bold
  box "" "address" "8" width (boxwid*8)
  box "" "page" "3" width (boxwid*3)
  box "" "bs" "1" width (boxwid*1)
  "  11" below big bold
#+end_src

#+ATTR_ORG: :width 700
#+RESULTS:
[[file:mcs48-pc.svg]]

- stored at the top of the ~stack~ on subroutine CALL or INT(errupt) along with the _program status word_
- reset to zero(0) when: power-on or RST(4) is received
- 12 bits wide (from LSB to MSB)
  - 8 bit for ~address~ within a page
  - 3 bit for ~page~ addressing (4 pages)
    |---+-----+-----------|
    | 0 | 000 | 000 - 0FF |
    | 1 | 001 | 100 - 1FF |
    | 2 | 010 | 200 - 2FF |
    | 3 | 011 | 300 - 3FF |
    |---+-----+-----------|
  - 1 bit memory bank select
    - needed when using _external memory_
    - under programmer's only control
    |---+---------+-------------------------|
    | 0 | sel mb0 | 0x000/0000 - 0x7ff/2047 |
    | 1 | sel mb1 | 0x800/2048 - 0xfff/4095 |
    |---+---------+-------------------------|

*** unconditional jump & call instruction

- instruction
  - 8 bit opcode
    - 5 bit for opcode
    - 3 bit MSB address
    - there is an _unique opcode for each page_ that a jump or call can transfer control to
  - 8 bit address

- replace 11 bits of the ~program counter~
  - transfer control anywhere within a 2K address range
    - 4 pages of external program memory
    - 4 pages of resident program memory

***   conditional jump instructions

- can transfer control only _within the page_ containing the instruction
- use 2(two) bytes
  - 1(one) for the opcode/instruction
  - 1(one) for the adddress
    - replaces the LSB of the ~program counter~

** ROM

- 1K internal for _program memory_
  - segmented into 4(four) 256-byte blocks/pages
- 3k of additional support for external ROM for _program memory_
- 4k of total ROM supported

*** Program Memory

- 1024 words 8bit wide addressed by the =program counter=

#+begin_src asm
  .org 0 ; reset vector, ->RST(4)
  jmp hellworld

  .org 3 ; external interrupt vector, ->INT(6)
  retr   ; if not used

  .org 7 ; time interrupt vector (msd to lsd)
         ; ...

  .org 0x100
  hellworld: ; ...
  .org 0x300 ; BCD lookup table
#+end_src

*** External Access Mode

- EA(7) input pin
- disables internal _program memory_ (the original first ~1k of the memory map)
- allowing the first words of _program memory_, to be fetched from external memory
- bumps _program memory_ size upto 4k
- RST(4) should be applied when EA(7) changes
- External _Instruction_ *FETCH* Cycle
  - automatically if memory address >1024 OR EA(7) pin is on
  - ~program counter~ put
    - 8bit bus
    - 4bit port 2
  - ALE(11) indicates address validity timing
    - Address Latch Enable - connect to a 373 latch control
    - for both external program and external data memory
  - PSEN(9) indicates program fetching is in progress
    - Program Store ENable
    - tie it to CE/OE of the memory
  - bus is reset (? and content is read

** RAM

- Vdd(26) provides power when Vcc(40) is powered off
- Can be expanded to access 256 bytes extra of external _data memory_
  - 64+256 = 320 bytes

*** External Data Memory addressing

- =movx= allows upto 256 new memory locations (added to the 64 internal)
- additional pages may be added by bank switching with extra output lines (?)

#+begin_src asm
  movx   a, @r0 ;   a = *r0
  movx @r0, a   ; *r0 = a

  movx   a, @r1 ;   a = *r1
  movx @r1, a   ; *r1 = a
#+end_src

*** Internal Data Memory layout

- (0-31) Lower Half
  - (0-7) 8 (working) registers of 8bit
    - R0-R7 - aka memory bank 0
    - =Register Inderect Addressing=
      - R0/R1 may be used as *RAM pointers* to access memory containing data.
        #+begin_src asm
          mov a, @r0 ; a = *r0
        #+end_src
  - (8-23) 8-Level (program counter) stack
    - 16x8
    - addressed by the stack pointer during subroutine calls
    - 8 stack locations in 16 RAM locations (2 locations per address)
    - each will contain the ~program counter~ + 4MSB of the ~PSW~
  - (24-31) Optional second register stack
    - R0'-R7' - aka memory bank 1
    - can be used in place of R0-R7
    - useful during interrupts
    - see ~program status word~

- (32-64) Upper Half
  - 32x8
  - Data Store
    - up to the programmer
    - accessed only by R0, R1

** Arithmetic Section
*** Instruction Decoder
- stores the ~OP code~ part of the instruction
- sends control signals to the ALU
*** ALU (Arithmetic Logic Unit)
- 2x 8bit input
  - 8 bit accumulator
  - 8 bit temporary register (transparent)
- 8 bit output
- sets a =Carry Flag= on the ~Program Status Word~ on overflow
- Operations:
  - add with/out carry, incr, decr
  - AND, OR, XOR
  - bit complement, rotation, swap nibbles, BCD decimal adjust
*** Accumulator register
- 8 bit
- one of the ALU sources
- data to/from I/O ports and memory pass through it
** I/O (BUS,PS1,PS2,T0,T1,INT)

- 27 pins in total (8+8+8+1+1+1)
- 1 bit ones
  - they can be used to monitor external signals
  - branching/condjumps without loading an input port into the ~accumulator~

*** Types of data tranfers

1) Programmed: controlled by the _program_
   - control-> ->signal <-data->
   - inneficient use of CPU
   - there is abit chit-chat needed for reading data
     + you signal/ask for the conversion to happen to the A/D converter
     + wait for it to be ready on T0 (maybe thousands of status signals)
     + accept the data

2) Interrupt: initiated by the _device_ when is ready, through an INTerruption
   - temporarilly suspends normal operations, and transfer the data
   - _more efficient_ than programming
   - useful for events of _unpredictable_ occurrence
   - requires more _hardware complexity_ on the IO, to externally compare and trigger the INTerruption
   - no idle time
     - you send a signal
     - keep processing
     - accept data when INTerrupted

3) DMA Direct Memory Access: between _device_ and the computer _memory_
   - no involvement at all by the CPU
   - needs a _DMA controller_ IC
   - =NOT AVAILABLE for the 8048=

*** Types of I/O operations

1) Control: IO <=  CPU, causes IO to perform an *action* (eg: rewind tape)
2) Status:  IO  => CPU, convey *information* about the present state or condition (eg: parity error)
3) Data:    IO <=> CPU, through data lines on the CPU bus

*** 1 bit INT(6)

#+begin_src asm
  en  i ;  enables interrupts
  dis i ; disables interrupts
#+end_src

- disabled on RST
- is active low, to allow logic ORing of several ones
- sampled every instruction cycle
- can be tested with ~JNI~ to test a pending interrupts before enable them
  - if kept disable can be seen as a new ~T2~
- must be held for at least 3 machine cycles to ensure proper a interrupt
- must be removed before ~RETR~
  - peripherical devices (ics?) automatically disable the interrupt when a register is read on it
  - you might output and interrupt ack
- single level, once triggered all further ones are ignored until ~RETR~

*** 1 bit T0(1)

#+CAPTION: reading of T0 with "ent0 clk" done
#+ATTR_ORG: :width 600
[[./DeMon48_128k_G_LA_ENT0_CLK.png]]

- use cases
  - as a test input
  - to OUTPUT periodical sequence of pulses
    - to be used externally as reference for other devices
    - used internally to generate the S1-S5 machine cycles
    #+begin_src asm
      ent0 clk ; output clock/3 on T0
    #+end_src

*** 1 bit T1(39)

- uses
  - test input
  - or INPUT to an event counter

*** 8 bit port (x2)

- P1 & P2 ports
  - LSB of P2 are used as addresses for external program memory access
- TTL compatible IO
- you can mix input and output within a port (aka quasi-bidirectional)
- output _latched_ (aka remains until new data is written, pull resistor of 50kΩ)
  #+begin_src asm
    outl p1,a ; port 1 = accumulator
    outl p2,a ; port 2 = accumulator
  #+end_src
- input _non-latched_
  #+begin_src asm
    in a,p1 ; accumulator = port 1 state
    in a,p2 ; accumulator = port 2 state
  #+end_src

*** 8 bit bus (12-19)

#+begin_src asm
  outl bus, a   ; bus = acc(umulator) - also needed for ORL and ANL opcodes
  ins    a, bus ; acc = bus
#+end_src

- all pins must be used for either input or output (no mixing possible)
- used for addresses (LSB 8 bits) and data r/w
  - needs a transparent latch (373/573) IC for addresses
- configurations
  1) bidirectional (true)
     - with IO strobe pins: RD(8) and WR(10)
  2) statically non-latched INPUT
  3) statically latched OUTPUT

* support chips

- https://en.wikipedia.org/wiki/Intel_MCS-48#Variants
- mcs-80 peripherals https://en.wikipedia.org/wiki/Intel_8080#Support_chips
- mcs-85 peripherals https://en.wikipedia.org/wiki/Intel_8085#Periphery

|------+----+------------------------------------------------|
| 8214 |    | Priority Interrupt Control                     |
| 8224 |    | Clock Generator                                |
| [[https://web.archive.org/web/20200919134210/https://www.datasheets360.com/pdf/-4828066515233335508][8228]] | 28 | System Controller & Bus Driver                 |
| [[https://web.archive.org/web/20230918030959/https://www.datasheets360.com/pdf/-4828066515233335508][8238]] |    | "                                              |
| [[https://en.wikipedia.org/wiki/Intel_8251][8251]] | 28 | Communication Controller, USART                |
| [[https://en.wikipedia.org/wiki/Intel_8253][8253]] | 24 | Programmable Interval Timer, PITs              |
| 8259 |    | Programmable Interrupt Controller, handle IRQs |
|------+----+------------------------------------------------|

* tools

- board
  - [[https://www.punsmann.de/retro/prompt-48.html][The INTEL Prompt 48 Deveopment System]]
  - [[https://en.wikipedia.org/wiki/Intel_system_development_kit#HSE-49][HSE-49: Original Dev Board]]
  - [[https://vintagecomputer.ca/imsai-8048-control-computer/][IMSAI 8048 Control Computer]] [[https://x.com/Arduining/status/1897729027756245281/photo/1][photo]]

- AS output to binary to be written into ROM https://linux.die.net/man/1/p2bin

- dissasembler ? https://github.com/pmackinlay/binaryninja-mcs48
  - for https://binary.ninja/
  - https://github.com/nejohnson/dasmxx
    - old https://www.oocities.org/pclareuk/DASMx/

- VHDL https://github.com/devsaurus/t48
- ROM programmer story https://laughtonelectronics.com/oldsite/lab_oem/lab_mcs48.html
- https://jhnbyrn.github.io/951-KLR-PAGES/reading_code.html
- dumping ROM https://www.sbprojects.net/projects/8049spy/index.php
- dumping ROM https://www.eevblog.com/forum/projects/intel-mcs-48-(8749-8049)-hmos-vs-cmos-differences-bus-driver-(dumping-woe)/
- KIT: internal EPROM programmer for UV ereasable ones
  - https://www.mattmillman.com/projects/hveprom-project/an-easy-to-build-mcs-48-8748-8749-8741-8742-8048-8049-programmer-reader/
  - https://www.mattmillman.com/projects/an-intel-mcs-48-based-dual-temperature-sensor/
  - https://x.com/Arduining/status/1706457993120796910
  - https://x.com/Arduining/status/1706719963925434722
  - https://x.com/Arduining/status/1707078033666941267
  - https://x.com/Arduining/status/1707053856570458391

** assembler

- asm48 https://github.com/daveho/asm48
  - $ asm48 -o foo.bin foo.asm
- fasm macros https://board.flatassembler.net/topic.php?t=18398
- tasm (?
- sbasm https://www.sbprojects.net/sbasm/8080.php
  - source https://github.com/sbprojects/sbasm3
  - doc https://www.sbprojects.net/sbasm/8048.php
- asxxxx https://shop-pdp.net/ashtml/asxxxx.php
- asX https://github.com/jaw0/asX
  - example https://github.com/jaw0/nametag48/

** simulator

- https://web.archive.org/web/20130601085340/http://www.coprolite.com/art27.html
- https://www.acebus.com/8048.htm
- S48
  - https://web.synchro.net/files/Simtel.Sep-1997/EMULATE/
  - by William Luitje
- https://www.ucsim.hu/news.html
  - comes in ubuntu
  - doc pdf https://www.baigar.de/irix/ucsim.pdf
  - commands https://www.ucsim.hu/cmd_general.html
  - example https://x.com/hiroki7v11/status/1572917676783341568
  - source https://github.com/danieldrotos/ucsim
    - https://github.com/danieldrotos/ucsim/issues/6
      #+begin_src
       "Behaviour of P1, P2 ports is not simulated yet,
        so all instructions working on these ports (and on Bus)
        are unimplemented yet."
      #+end_src

* gotchas

- critique
  - mcs-48 was originally designed as a 2kb machine, with a second 2kb capability added as a clumsy afterthought. Creating 2 problems with the addressing mechanism.
    - the _program counter_ is really 11 bits, thus address JMP/CALL instructions possible within 2kb bank of program store
      - the internal MB register flag
      - SEL MB0
      - SEL MB1
      - since you can't know the value of the flag on JMP/CALL , do not them on interruption code
    - 2k memory banks are divided in 256 byte pages
      - conditional jumps specify an 8bit target address _in the current page_
    - lack of codition codes for testing their rsults
      - only the accumulator can be tested for zero or negative
      - no overflow bit (harder comparison of signed two-complement)

* codebases

- demoscene [[https://www.pouet.net/prod.php?which=61201][source]] [[https://www.youtube.com/watch?v=1q-4Ie5wjus][video]]
- https://github.com/AngryTroll/i8048_board
- hello world https://x.com/RueNahcMohr/status/1431910449185005571
- homebrew computer https://github.com/jim11662418/Intel_8048_Single_Board_Computer
- https://github.com/Lefucjusz/MAB8048_led_clock
- https://github.com/marekw1986/8048/blob/main/code/ascii/ascii.asm
- game https://github.com/tcr/8bit-demos/
- clock [[https://web.archive.org/web/20220630074502/https://www.wraith.sf.ca.us/8048/][8048 Assembly Code Tomb]]
  - source https://web.archive.org/web/20041210150149/http://www.wraith.sf.ca.us/8048/block-sig.asm
  - sheet https://web.archive.org/web/20210913152817/https://www.wraith.sf.ca.us/8048/clock-8048.gif

- https://hackaday.io/project/19278-8048-maze-generator
  - code https://cdn.hackaday.io/files/19278824789952/maze.asm

- https://web.archive.org/web/20140717062700/http://coprolite.com:80/8048.html
- [[https://www.delabs-circuits.com/cirdir/micro/micro4.html][80C39-8749 MCS-48 Examples and code]]
- dev board
  - part 1 [[https://vintagechips.wordpress.com/2025/02/19/wrt8749/][japan]] [[https://vintagechips-wordpress-com.translate.goog/2025/02/19/wrt8749/?_x_tr_sl=ja&_x_tr_tl=en&_x_tr_hl=es&_x_tr_pto=wapp][english]]
  - part 2 [[https://vintagechips.wordpress.com/2025/02/21/mcs8749/][japan]] [[https://vintagechips-wordpress-com.translate.goog/2025/02/21/mcs8749/?_x_tr_sl=ja&_x_tr_tl=en&_x_tr_hl=es&_x_tr_pto=wapp][english]]
  - https://github.com/vintagechips/mcs8749
  - https://x.com/vintagechips/status/1677939391690358784
- Led blinking
  - part1 [[https://elchika-com.translate.goog/article/1ab5a4a9-b14d-476f-b835-b1a01120d7b8/?_x_tr_sl=ja&_x_tr_tl=en&_x_tr_hl=es&_x_tr_pto=wapp&_x_tr_hist=true][english]]
  - part2 [[https://elchika.com/article/9dd6b829-8672-4a28-b671-d379db1bad90/][japanese]] [[https://elchika-com.translate.goog/article/9dd6b829-8672-4a28-b671-d379db1bad90/?_x_tr_sl=ja&_x_tr_tl=en&_x_tr_hl=es&_x_tr_pto=wapp&_x_tr_hist=true#h_MCS-48%E3%81%AE%E5%A0%B4%E5%90%88%20(FLASH.ASM)][english]] [[https://x.com/elchika_info/status/1457636146062585858][video]]

** reversing

- multimeter https://github.com/romavis/metra-m1t380-doc
- Porsche computer https://jhnbyrn.github.io/951-KLR-PAGES/
- korg trident mk2 https://github.com/wohali/polysix/blob/457212866bcf8875156f871fd5cc638a6e59b143/docs/klm8048.asm#L4

** programmer

- https://www.sbprojects.net/projects/8049spy/index.php
- https://minuszerodegrees.net/willem/Willem%20MCS-48%20adapter.htm
- programmer
  - original https://www.jelora.fr/post/2024/06/15/Programmateur-de-microcontrleur-Intel-MCS-48-experimental-sur-Arduino.html
  - translation https://www-jelora-fr.translate.goog/post/2024/06/15/Programmateur-de-microcontrleur-Intel-MCS-48-experimental-sur-Arduino.html?_x_tr_sl=fr&_x_tr_tl=en&_x_tr_hl=es&_x_tr_pto=wapp
  - had a "MAB 8048H" IC from Philips

** by rcgoff

- https://github.com/rcgoff/pokroller
- https://github.com/rcgoff/vostok-doorbell-emifon
- https://github.com/rcgoff/therm8048

** by retiredfeline

- https://hackaday.io/project/184942-ancient-12-hour-display
- https://github.com/retiredfeline/8048-board

- https://hackaday.io/project/185235-pwm-led-bench-light
- https://github.com/retiredfeline/8048-pwmctl

- https://hackaday.io/project/160958-restoring-a-beckman-neon-display-clock
- https://github.com/retiredfeline/beckman-clock

* articles

- ⭐ https://www.controller-designs.de/index.php?lang=de&cat=projekte&cont=demon48_128k&sub=documentation_0
  - When operating at 11MHz, the instruction cycle time is 1.364µs (T[µs] = 15 / fosc[MHz]), in which 1-byte/1-cycle instructions are executed
- https://web.archive.org/web/20140703075839/http://www.atarihq.com/danb/files/8048.txt
- http://www.moria.de/~michael/comp/ecb/sbcmcs48/hardware.html
- https://www.cpu-world.com/Arch/8048.html
- 22 https://www.eejournal.com/article/a-history-of-early-microcontrollers-part-4-the-intel-8048-and-8748/
- 20 https://www.mattmillman.com/mcs-48-the-quest-for-16-bit-division-on-the-8-bit-cpu-which-cant-divide-anything/
  - discussion https://news.ycombinator.com/item?id=24941189
- 13 http://www.theresistornetwork.com/2013/07/programming-vintage-intel-mcs-48.html
  - Early Intel processors combine the address and data bits onto the same lines and use two signals:
    1) ALE  (Address Latch Enable)
    2) PSEN (Program Store Enable)
  - To signal what state the bus is in.
  - This was done to save costs and keep pin count down.
  - Unfortunately this complicates the connection to an external PROM.
- 20 Ben Eater's computer based on 8048
  - [[https://www.reddit.com/r/beneater/comments/gbmv8u/inspired_by_bens_6502_project_ive_decided_to/#lightbox][PIC ONLY]], unreleased source

* videos

- 21 video | Intro to Intel 8048 and PIC 16f1619
  https://www.youtube.com/watch?v=7TIBGRGaTB0

** 20 | 8048 microcontroller experiments

- https://www.youtube.com/watch?v=K83uTnW6IHU
- https://github.com/daveho/RandomStuff/tree/master/Episode05

- Extra ICS used:
  - MAX708 reset generator
  - 74HC573 address latch
  - AT28C64E-15PC

- YT Comments
  - I tied EA pin 7 to ground to use internal ROM running with a 10Mhz crystal.
  - I see what you mean with getting the CPU to reset reliably, a 2k2 resistor to VCC with a 10uf cap to gnd seems to work ok, boots reliably on power-up.
  - The devices I have are NEC types programmed with an equally ancient Expro-60 device programmer using an ISO interface card. Indeed a lot of fun, regards.

**** Example 1: infinite loop of NOPs
#+begin_src asm
    .org 0x0
    reset:
            jmp entry
    .org 0x10
    entry:
            nop
            nop
            nop
            nop
            nop
            nop
            nop
            nop
            nop
            nop
            jmp entry
#+end_src

**** Example 2: blink led
#+begin_src asm
  .org 0x0
  reset:
          jmp entry

  .org 0x10
  entry:
          mov   A, #255 ; set all A bits to 1
          outl P1, A    ; output to port 1 (LED will be off)
          call delay

          move  A, #0   ; set all A bits to 0
          outl P1, A    ; output to port 1 (LED will be ON)
          call delay

          jmp entry     ; repeat main loop

  delay:
          mov R0, #255  ; init outer loop counter
  delay_outer:
          mov R1, #255  ; init inner loop counter
  delay_inner:
          nop
          nop
          nop
          nop
          djnz R1, delay_inner ; dec inner count, continue if not zero
          djnz R0, delay_outer ; dec outer count, continue if not zero
          ret                  ; return to caller
#+end_src

**** Example 3: led + button to GND

- button
  - when pressed see 0
  - when released see 1, due pull up

#+begin_src asm
  .org 0x0
  reset:
          jmp entry

  .org 0x10
  entry:
          mov R0, #0xFF         ; R0 is value to output to P1

  loop:
          mov   A, R0           ; get value into accumulator
          outl P1,  A           ; write to P1
          in    A, P1           ; read from P1
          anl   A, #0x80        ; 0b10000000 checks if high bit is set

          jnz buton_not_pressed

          ;; button is pressed
          mov R0, #0xFE         ; 0b11111110 drive P1.0 low, LED is on
          jmp loop

  button_not_pressed:
          mov R0, #0xFF         ; drive P1.0 high, LED is off
#+end_src

**** Example 4: timer + light pattern P1.7 through P1.0

#+begin_src asm
  .equ pattern_array, 32 ; 33, 34
  .equ cycle_count  , 45 ; nr of cycles before interrupt

  .org 0x0
  reset:
          jmp entry
  .org 0x7
  timer_int:
          jmp timer_event
  .org 0x10
  entry:
          ;; initialize pattern_array
          mov  R0, #pattern_array
          mov @R0, #0x6D
          mov  R0, #pattern_array+1
          mov @R0, #0xB6
          mov  R0, #pattern_array+2
          mov @R0, #0xDB

          mov  R4, #cycle_count ; countdown value
          mov  R2, #0           ; is either: 0,1,2
          strt t                ; start timer
          en tcti               ; enable timer interrupt

   loop: ; copies R0 to P1
          mov  A, R0
          outl P1, A
          jmp  loop

   timer_event:
          djnz R4, timer_event_done ; check if countdown=0

          mov  R4, #cycle_count     ; reset countdown
          inc  R2                   ; increment pattern count
          mov   A, R2               ; move pattern count to A
          inc   A                   ; increment
          anl   A, #0x4             ; check if pattern=4
          jz    gen_pattern         ;  no, continue
          mov   R2, #0              ; yes, reset pattern count

   gen_pattern:
          mov A  , #pattern_array ; base address of pattern array
          add A  , R2             ; add offset to select element
          mov R1 , A              ; load element address to R1
          mov A  , @R1            ; retrieve element value
          mov R0 , A              ; copy element value to R0

   timer_event_done:
          retr
#+end_src

* MCS-41 - UPI-41 - 8041/8042

#+begin_src
  NOTE: I own a couple of 8042 so I am making a special section for them.
#+end_src

- 1979
- 8-bit slave microcontroller
  - a MCU with a slave interface
  - interface registers
  - DMA support
- UPI-(C¦L)42 Universal Peripherical Interface
- use cases:
  - keyboard control
  - ADC control
- Can use a 8243 IO expander
- Followed by 8742

- Many dissimilar pins to the 8048
  - *XTAL1(2)* can act as a single clock input if we are following a _master chip_
  - D0-D7 have no dual purpose of communicate addresses besides data
  - P1 pins communicates the addresses
  - DMA suport with *P2_6(37)* for DRQ and *P2_7(38)* for DACK#
  - *RD#(8)* and *WR#(10)* are INPUTS from the _master chip_ to enable either
    - not OUTPUT probes like in 8048
    - no support for extended SRAM (?
  - new *A_0(9)* input from the _master chip_ to indicate if it is tranfering data or a command
  - new *SYNC(11)* output clock signal which occurs once per cycle (works as an ALE?)
  - no *INT(6)* pin

- Second Sources:
  - D80C42C by NEC
    - no *A20GATE(22)* support (?)
    - no *Vdd(26)* pin
    - new *STOP* instruction and INPUT pin *#(26)* to enable a _STOP mode_
      - for lower power consumption
      - stops the oscillator
      - keeps ram powered
      - lowers voltage
        - to 2.0v if done by pin
        - to 2.5v if done by instruction
    - new *HALT* instruction for a _HALT mode_
      - for low power consumption
      - keeps the oscillator active
      - internal clock stops
      - reset by *TEST0(1)* and *RST#(4)*

- tool:
  - any 8048 asm should work, except for instructions that don't
  - asxxxx https://shop-pdp.net/ashtml/asxxxx.php
  - sbasm supports 8041
  - tasm (maybe)
  - disassembler http://web.archive.org/web/20130304035717/http://www.halicery.com/8042/dasm42.c

- ⭐ 05 article https://devster.monkeeh.com/z80/upi42/
- https://web.archive.org/web/20041103235910/http://my.execpc.com/~geezer/osd/kbd/kbd.txt
- Arduino Shield https://groups.io/g/retroshield/topic/intel_8042/33042489#
  - idea being that code runs on the ic CPU, but Arduino emulates the URDP, RAM, ROM
  - https://www.youtube.com/watch?v=VJ7JLX6Icxo

** videos

- 8042 with external memory https://www.youtube.com/watch?v=ODCTIAD-vM0
  - has a schematic on a dropbox link
- https://www.youtube.com/watch?v=vSlNIeMoWZk

** codebases

- RueNahcMohr
  - photos & discussion https://x.com/RueNahcMohr/status/1432549586032283650
  - code+circuit https://x.com/RueNahcMohr/status/1863547404336718220
  - https://x.com/RueNahcMohr/status/1892981146863955973

- https://hackaday.io/project/161909-8042-clock
- https://github.com/retiredfeline/8042-clock/
- https://cdn.hackaday.io/images/8029931540730926617.png

- https://hackaday.io/project/162159-8042-metronome
- https://github.com/retiredfeline/8042-metronome

*** on keyboards

- Can be found in old motherboards as [[https://wiki.osdev.org/%228042%22_PS/2_Controller][Keyboard controllers]]
  - https://aeb.win.tue.nl/linux/kbd/A20.html
  - https://groups.google.com/g/alt.os.development/c/LJHRZcBMMws
  - analysis https://web.archive.org/web/20121026015851/https://halicery.com/8042/8042_INTERN_TXT.htm
  - disassembled http://web.archive.org/web/20110826011846/http://www.halicery.com/8042/8042_1503033.TXT
  - photos https://x.com/TubeTimeUS/status/1149793632859246592
  - as a keyboard controller https://wiki.osdev.org/I8042_PS/2_Controller
  - reversed keyboard controller https://github.com/Halicery/8042
