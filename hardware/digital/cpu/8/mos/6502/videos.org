* cl-6502
https://malisper.me/defaddress/
https://github.com/kingcons/cl-6502
http://redlinernotes.com/docs/cl-6502.pdf
https://lukego.github.io/blog/2012/10/24/readable-programs/
* 2012 - On programmer archaeology - https://vimeo.com/47364930
RESUME 6:19
  - slides: http://redlinernotes.com/docs/talks/opa.html
  - https://en.wikipedia.org/wiki/A_Deepness_in_the_Sky
  - https://www.drdobbs.com/architecture-and-design/interview-with-alan-kay/240003442

* Build a 65c02-based computer from scratch

- https://www.youtube.com/playlist?list=PLowKtXNTBypFbtuVMUVXNR0z1mu7dp7eH

** BOM

- W65C02S (890 pesos at 15Aug/20) (15k pesos at 25Mar/25)
  - 16bit/2^16 addresses 128K of memory
- AT28C256 (1887 pesos at 15Aug/20) (15k pesos at 25Mar/25)
- W65C22 - VIA
- HD44780U (LDC-II) - "Dot matrix Liquid Crystal Display Controller/Driver"
- EEPROM programmer TL866II+

** 01 - "Hello, world" from scratch on a 6502

https://www.youtube.com/watch?v=LnzuMJLZRdU

*** Pin connections for a basic setup

- 5v Vdd(+) Vcc(-)
- Outputs: kept disconnected (VPB,A0-15,D0-D7...)
- Inputs: connected (RDY,IRQB,NMIB,BE,PHI2(clock),...) some to HIGH/UP and some to LOW/DOWN
  - RST: connected to (+) with a 1k resitor, and a button to GND
  - RWB: tells if it is and read or write operation
  - PHI2(clock)
    - Min: new 6502 model allows stopping it and doing step by step execution
    - Max: orig 1Mhz, new model 16Mhz

*** How to study what is happening once plugged?

- We can put leds on the address lines
- We can use a "logic analyzer" to capture each signal.
  - Overkill. Especially useful for fast speed circuits.

**** Using Arduino - Read Address Bus

1) define address pins and initialize pinmode
   #+begin_src c
     const char ADDR[] = {22,24,...};
     void
     setup() {
       for (int n = 0; n < 16; n += 1) {
         pinMode(ADDR[n], INPUT);
       }
     }
   #+end_src
2) Read A0-A15 in loop()
  #+begin_src c++
    unsigned int address = 0;
    for(int n = 0; n < 16; n += 1){
       int bit = digitalRead(ADDR[n]) ? 1 : 0; // to int, could Serial.print(bit)
       address = (address << 1) + bit;         // an address as a number
    } // and after add a Serial.println()
  #+end_src

**** Using Arduino - Read Address Bus on CLOCK

- Read Clock Pulse (have it trigger an interrupt)
 #+begin_src c++
   #define CLOCK 2
   void init() {
     pinMode(CLOCK, INPUT);
     attachInterrupt(digitalPinToInterrupt(CLOCK), onClock, RISING); // !!!
   }
   void onClock(){
    // put what you want to run JUST on a clock
    // in our case the print of addresses input pins
   }
 #+end_src

**** Using Arduino - Read Data Bus

1) Read D0-D7
  #+begin_src c++
    const char DATA[] = {39,41,...};
    pinMode(DATA[n], INPUT); // on setup(), where 0<n<8
    void onClock() { // we add this
      char output[];
      unsigned int data = 0;
      for (int n = 0; n < 8; n += 1) {
        int bit = digitalRead(DATA[n]) ? 1 : 0; // to int
        data = (data << 1) + bit;               // an address as a number
      }
      sprintf(output, "    %04x %02x", address, data);
      Serial.println(output);
    }
  #+end_src

2) Read READ_WRITE pin
   #+begin_src c++
     #define READ_WRITE 3
     pinMode(READ_WRITE, INPUT); // setup()
     digitalRead(READ_WRITE) ? 'r' : 'W'; // use this to add to sprintf
   #+end_src

*** Explaination of hardwiring D0-D8 = 0xea = 11101010

- with 1k resistors
- on RST, tries to read address from ~0xfffc~ and ~0xfffd~
- gets ~0xeaea~
- sets PC to it
- it runs the instruction there, which is a NOP (0xea)
- seeks next to address ~0xeaeb~, reads a NOP...

** 02 - How do CPUs read machine code?

https://www.youtube.com/watch?v=yl8vPW5hydQ

- 6502
  - stores and reads addressed in =Little Endian=
  - reading the lower order byte first,
  - followed by the high order byte

*** EEPROM Connecting
- Adding a EEPROM, so instructions are loaded from it.
- 1x AT28C256 - 32Kilobytes (or 256Kilobits)
- 15 Addresses pins *WHILE 6502 HAS 16*
  - We connect the extra addr pin to CE of the EEPROM but inverted
    - Because we want to keep the 0xfffd and 0xfffc addressed used on RST
    - And we don't want to see the contents repeated when accessing low addresses
    - We use a NAND gate, instead of a NOT
*** Flashing EEPROM - Programming NOPs
- Python script that creates a file with NOPs
  #+begin_src python
    rom = bytearray([0xea] * 32768)
    with open("rom.bin", "wb") as out_file:
        out_file.write(rom)
  #+end_src
- EEPROM programmer TL866II+
  #+begin_src sh
    $ minipro -p AT28C256 -w rom.bin
  #+end_src
*** Flashing EEPROM - Programming IC instructions

- Python script, jumping to beggining of memory, AND programming
- Note: addresses outside 0x800-0xfff range the EEPROM has currently

#+begin_src python
  rom = bytearray([0xea] * 32768)
  rom[0] = 0xa9 # LDA (immediate)
  rom[1] = 0x42 # 0x42 | acc = 0x42

  rom[2] = 0x8d # STA (address)
  rom[3] = 0x00 # 0x600 | eeprom[0x6000] = acc
  rom[4] = 0x60

  rom[0x7ffc] = 0x00 # Fill reset vector with address 8000
  rom[0x7ffd] = 0x80 # which is addr 0 on the ROM for our setup
  with open("rom.bin", "wb") as out_file:
      out_file.write(rom)
#+end_src

*** 65C22 Register - Hooked into CPU's Address and Data Bus
- We'll use memory write instructions (STA) for IO
  - aka "commands" for external hardware
  - since, =6502 does not have separate IO pins/lines=
  - by targetting a pre-arranged range of addresses
  - target hardware will
    1) monitor
       - address lines from CPU
       - WE# pin from the CPU
       - data lines on the a latched bus
    2) when responding to some, the EEPROM will ignore them
- 65C22 - "VIA - Versitale Interface Adapter"
  - made to work with the 6502 (all timings match)
  - pins from the CPU:
    - D0-D7, PHI2, RW#, RST
  - 16 internal registers, enable different functions
    - RS0-3: Register/Port Selector pins (of the 16)
    - [O¦I]R[A¦B]
    - DDR[A¦B]
      - data direction registry for ports A&B
      - can set it up at pin level
  - CS1/CS2#
    - Chip Select
    - to let it know WHEN the CPU will talk to the chip
    - we'll use some address decode logic
  - PA0-7, PB0-7: Port A and B, are the I/O
**** Step 1: detect the address ~0x0600~
- in binary: 011 0000 0000 0000
- We just NEED to check just the first 3 bits (011)
  - Doing this "wastes" address space, but saves on logic gates
- And CS the 652CC if match (needs both CS to be active)
  - A15, A14 to two CS2# through NAND gates.
  - A13, to the CS1 directly.
**** Step 2: write to 652CC registers
- We connect the lower 4 A0-3 from 6502 to RS0-3 of 65C22
- This memory maps 0x600-0x60f to each of the 16 registers on 65C22
- Example: if we want to set DDRB
  - for data direction register B on the 65C22
  - we write to address 0x6002
*** 65C22 Register - Blinking leds on Port B
#+begin_src python
  code = bytearray([
    # Setup Port B pins as outputs
    0xa9, 0xff,       # LDA #$ff -- mark all pins as OUTPUT
    0x8d, 0x02, 0x60, # STA 6002 -- for Port B (DDRB)

    0xa9, 0x55,       # LDA #$55 -- outputs 0x55 -- 0101 0101
    0x8d, 0x00, 0x60, # STA 6000 --  in Port B (ORB)

    0xa9, 0xaa,       # LDA #$aa -- outputs 0xaa -- 1010 1010
    0x8d, 0x00, 0x60, # STA 6000 --  in Port B (ORB)

    0x4c, 0x05, 0x80, # JMP $8005 -- Jumps back to line with "LDA #$55"
  ])

  rom = code + bytearray([0xea] * (32768 - len(code)))

  rom[0x7ffc] = 0x00 # Address 1000000000000000
  rom[0x7ffd] = 0x80 # Address 8000 on the CPU (which is the zero on the ROM)

  with open("rom.bin", "wb") as out_file:
      out_file.write(rom)
#+end_src
** 03 - Assembly language vs. machine code

- Replace the python script used before with ~vasm~
  - using the "old 8-bit style syntax"

*** Example: blink
#+begin_src asm
  .org $8000  // from the CPU perspective 0 is $8000 - A15=1
    lda #$ff
    sta $6002

    lda #$55
    sta $6000
    lda #$aa
    sta $6000

    jmp $8005

  .org $fffc
    .word $8000 // "Reset Vector"
    .word $0000 // two extra bytes for padding
#+end_src

*** Example: blink - labeled jump
#+begin_src asm
  .org $8000 // From the CPU perspective

  reset:
    lda #$ff
    sta $6002

  loop:
    lda #$55
    sta $6000

    lda #$aa
    sta $6000

    jmp loop // <- using the label

  .org $fffc
  .word reset // <- using the label
  .word $0000
#+end_src

*** Example: blink - using ROR to rotate the lights

#+begin_src asm
.org $8000 // From the CPU perspective
reset:
  lda #$ff
  sta $6002

  lda #$50  // we output something right away
  sta $6000

loop:
  ror       // shifting acc pattern to the right
  sta $6000 // send it

  jmp loop

.org $fffc
  .word reset
  .word $0000
#+end_src

** 04 - Connecting an LCD to our computer

- HD44780U (LDC-II) - "Dot matrix Liquid Crystal Display Controller/Driver"

- 16 pins
  - Vcc, Vdd
  - Backlight Display
    - A: Anode (5V) - has a current limit resistor
    - K: Katode (GND)
  - V0: contrast adjust
    - hardwired to GND through a variable resistor of 10K
  - Connected to through the (internal) *MPU*
    - D0-7:
      - data to/from? registers
      - has a mode to make it work with 4 pins
    - E: Enable signal
    - RW: Whether we are reading or writing
    - RS: Registry Select
      - LOW  write to the IR (Instruction Register)
      - HIGH write to the DR (Data Register)

*** Final asm code

#+begin_src asm
PORTB = $6000
PORTA = $6001
DDRB = $6002
DDRA = $6003

E  = %10000000 ; "%" used for binary literals
RW = %01000000
RS = %00100000

.org $8000
reset:
  lda #%11111111 ; Set all pins for output
  sta DDRB
  lda #%11100000 ; Set top 3 pins for Output
  sta DDRA

  lda #%00111000 ; Set 8-bit mode, 2-line display, 5x8 font
  sta PORTB
  lda #0         ; Clear RS/RW/E bits
  sta PORTA
  lda #E         ; Set E bit to send instruction
  sta PORTA
  lda #0         ; Clear RS/RW/E bits
  sta PORTA

  lda #%00001110 ; Display on, cursor on, blink off
  sta PORTB
  lda #0         ; Clear RS/RW/E bits
  sta PORTA
  lda #E         ; Set E bit to send instruction
  sta PORTA
  lda #0         ; Clear RS/RW/E bits
  sta PORTA

  lda #%00000110 ; Increment and shift cursor, don't shift display
  sta PORTB
  lda #0         ; Clear RS/RW/E bits
  sta PORTA
  lda #E         ; Set E bit to send instruction
  sta PORTA
  lda #0         ; Clear RS/RW/E bits
  sta PORTA

  lda #"H"
  sta PORTB
  lda #RS        ; Set RS (we are sending data not an instruction), Clears RW/E bits
  sta PORTA
  lda #(RS | E)  ; Set E bit to send instruction
  sta PORTA
  lda #RS        ; Clear E bits
  sta PORTA

loop:
  jmp loop ;; "halts" the program, infinite loop

  .org $ffc
  .word reset
  .word $0000
#+end_src

** 05 - What is a stack and how does it work?
- Assembler: Using a sub-routine
  #+begin_src asm
PORTB = $6000
PORTA = $6001
DDRB = $6002
DDRA = $6003

E  = %10000000
RW = %01000000
RS = %00100000

  .org $8000

; "%" used for binary literals
reset:
  lda #%11111111 ; Set all pins for output
  sta DDRB
  lda #%11100000  ; Set top 3 pins for Output
  sta DDRA

  lda #%00111000 ; Set 8-bit mode, 2-line display, 5x8 font
  jsr lcd_instruction
  lda #%00001110 ; Display on, cursor on, blink off
  jsr lcd_instruction
  lda #%00000110 ; Increment and shift cursor, don't shift display
  jsr lcd_instruction

  lda #"H"
  jsr print_char

loop:
  jmp loop ;; "halts" the program, infinite loop

lcd_instruction: ; subroutine declaration
  sta PORTB
  lda #0   ; Clear RS/RW/E bits
  sta PORTA
  lda #E   ; Set E bit to send instruction
  sta PORTA
  lda #0   ; Clear RS/RW/E bits
  sta PORTA
  rts ; return from subroutine

print_char:
  sta PORTB
  lda #RS       ; Set RS (we are sending data not an instruction), Clears RW/E bits
  sta PORTA
  lda #(RS | E) ; Set E bit to send instruction
  sta PORTA
  lda #RS       ; Clear E bits
  sta PORTA
  rts

  .org $ffc
  .word reset
  .word $0000
#+end_src
- Stack: example of extra steps the CPU does when a subroutine is called
  #+begin_src
  0124 r 5d
  0124 W 80
  0123 W 0e
  #+end_src
- Stack uses memory from 0100 to 01ff
  - It wraps around when it runs out of it
  - Stack pointer starts with a random value (an offset in the range)
  - *TXS* transfer X to Stack Register
  #+begin_src asm
  ldx #$ff
  txs
  #+end_src
- Calls to subroutine/stack changes the A register
- *pha* puts value of register A into the stack
  *pla* puts back the value into the register A
- Current problem is that it can't read the return address
  Due to the half memory "hack" we have with the CE and upper half of memory addresses
** 06 - RAM and bus timing
- We want to have some writable memory, not just to allocate the stack.
- 1x 62256 (32 Kilobytes)
  - A0-14n
  - D0-7:
  - WE: connected to the RW signal of the CPU
  - OE: A14
  - CS: A15
- We are going to use 16K of the 32K in our memory layout
  - Active when A15 and A14 are both 0
    0000-3fff
- Just plugging OE,CS to A14-15 *might not* work.
  There might be an access delay when reading from the ram.
  For read/write operations, look at the times of the setup&hold of data
  If not looking carefully to the protocol/timings of the communication.
  - Might not work under certain conditions
  - Like high temperature
- Other timing issues might happen if you overclock the CPU, as it will shorter times.
- Timing Issue: Address gets invalid before data. Due Timing on CS and WE.
  - We need to make sure CS is only LOW when the *clock* is HIGH
    - negate the 15 and NAND it with the *clock*
  - Propagation delay is 8ns (worst case 15ns)
** 07 - Subroutine calls, now with RAM
- Connecting and seeing it works with the Stack/RAM now.
- Added instruction to clear display
** 08 - Why build an entire computer on breadboards?
- The quality of the vertical springs, wether are flexible or not. Make the quality of the breadboard.
  - Shopping list https://eater.net/breadboards
- Capacitance: Any time you have 2 wires close together, you have a capacitor. Oppose the change of voltage.
- Inductance: everytime you have a current, you have a magnetic field. Opposes the change of current.
- Both, can cause some phase-shifting and attenuated
- To avoid drops on the power rail
  1) is a good practice add capacitors (0.1mf) across the power riel
  2) AND/OR extra 1 Capacitor for every Chip, across the power lines
- CPU: Fall time, Rise time are 5 ns
  - All square waves are sum of sine waves
  - we have less perfect square waves the lower the frequency (as they are less sine waves too)
- 1Mhz oscillator
  - Issue: on the LED, sending data too early. Without checking for "busy flag"
** 09 - How assembly language loops work
- Display doesn't work with the 1Mhz due we are not waiting for the LCD to finish the instructions that we send.
  Clock cycles are 37us and instructions on the LCD run on 35us
  We *could* add NOP's to add delay. (750 nops)
- We do it properly and read the CPU's *busy flag*, and loop while the flag is up.
- Conditional jumps use the CPU "Process Status Register"
#+NAME: while loop for busy flag to clear
#+begin_src asm
lcd_wait:
  pha ; Push A register to stack
  lda #%00000000 ; Port B is input for now
  sta DDRB
lcdbusy:
  lda #RW
  sta PORTA
  lda #(RW | E)
  sta PORTA
  lda PORTB
  and #%10000000
  bne lcdbusy

  lda #%11111111 ; Port B is output for now
  sta DDRB
  pla ; Restore A register
  rts

lcd_instruction:
  jsr lcd_wait
  ...
print_char:
  jsr lcd_wait
  ...
  #+end_src
#+NAME: Put string into memory
#+begin_src asm
  ldx #0
print:
  lda message,x ;; Adds to the X register
  beq loop      ;; If we Loaded a zero, we exit "jmp" loop
  jsr print_char
  inx
  jmp print

message: .byte "H"
message: .asciiz "Hello, world!" ; ascii with and extra zero
#+end_src
- Using a oscilloscope to debug performance
** 10 - Binary to decimal can't be that hard, right?
- 164 lines of assembly
- We want to display a binary number in decimal.
  We could use binary shifting to run division which will separate the decimal digits.
  Since we don't have OP codes for division.
- Algorithm??????
#+NAME: for loop, and division algorithm, reverse word
#+begin_src asm
value = $0200 ; 2 bytes
mod10 = $0202 ; 2 bytes
message = $0204 ; 6 bytes

  lda #0
  sta message

  ; Initialize value to be the number to convert
  lda number
  sta value
  lda number + 1
  sta value + 1

divide:
  ; Initialize the remainder to zero
  lda #0
  sta mod10
  sta mod10 + 1
  clc

  ldx #16 ; loop counter

divloop:
  ; Rotate quotation and reminder
  rol value
  rol value + 1
  rol mod10
  rol mod10 + 1

  ; a,y = dividend - divisor
  ; Subtracting to the mod10
  ; Since we can only subtract 8-bits at the time
  sec
  lda mod10 ; The right half of mod10
  sbc #10   ; Subtract with carry
  tay       ; Save the Low byte in Y
  lda mod10 + 1
  sbc #0
  bcc ignore_result ; branch if carry clear, if dividend is < divisor
  sty mod10         ; Store the result
  sta mod10 + 1

ignore_result:
  dex
  bne divloop
  rol value ; shift in the last bit of the quotient
  rol value + 1

  lda mod10
  clc
  add #"0"
  jsr push_char;print_char

  ; if value != 0, then continue dividing
  lda value
  ora value + 1
  bne divide ; branch if value not zero

  ldx #0
print:
  lda message,x
  beq loop
  jsr print_char
  inx
  jmp print

loop:
  jmp loop ; Halt

; Add the character in the A register to the beginning of the
; null-terminated string `message`
push_char:
  pha ; Push new first char onto stack
  ldy #0 ; index into the message

char_loop:
  lda message,y ; Get char on string and put into X
  tax
  pla
  sta message,y ; Pull char off stack and add it to the string
  iny
  txa
  pha           ; PUsh char from string onto stack
  bne char_loop

  pla
  sta message,y ; PUll the null off the stack and add to the end of the string

  rts

number: .word 1729
#+end_src
** TODO Part 11 - Hardware Interrupts
- 6502 pins
  IRQ: interrupt request pin, high on low
  NMI: non-masquable interrupt pin, high on low
- 0xfffa for NMI
  0xfffe for IRQ
#+NAME: setup the code that runs on interrupt
#+begin_src asm
nmi:
irq:
  .org $fffa
  .word nmi
  .word reset
  .word irq
#+end_src
** TODO Part 12 - Interrupt Handling
