
Guys what about?:
Core:
Official Website: https://clojure.org/
Documentation: https://clojuredocs.org/
Cheat-sheet: https://clojure.org/api/cheatsheet
Community Resources: https://clojure.org/community/resources
Clojure Libraries: https://clojars.org/
Libraries Documentation: https://cljdoc.org/

Practice:
4Clojure: https://www.4clojure.com/
Koans: https://github.com/functional-koans/clojure-koans
Clojure problems on Exercism: https://exercism.io/tracks/clojure

Tools:
Clojure Toolbox: https://www.clojure-toolbox.com/
EDN (extensible data notation): https://clojure.github.io/clojure/clojure.edn-api.html

- Transforming Data with ClojureScript¶ https://langintro.com/cljsbook/
- https://github.com/magomimmo/modern-cljs
- https://www.cs.utexas.edu/users/novak/cs378contents.html
- Simulating Machines in Clojure https://stopa.io/post/255
- Podcast - https://clojuredesign.club/
- Podcast - Clojurescript - https://open.spotify.com/show/3lnWCN0PAAywiN7gaxNzKZ
- Podcast - Eric Normad - https://www.youtube.com/channel/UC2riBMG3qf1Di20ouRc76BA/videos
- re:clojure https://www.youtube.com/c/reclojure/videos
- Course - Brian Will - the Clojure language - https://www.youtube.com/playlist?list=PLAC43CFB134E85266
- Clojure Study Group - https://www.youtube.com/playlist?list=PLpr9V-R8ZxiDjyU7cQYWOEFBDR1t7t0wv
- ClojuRU 2019 - https://www.youtube.com/playlist?list=PLvf-wiCQYkAVvrZr53Upxti9Hr3t7V4bW
- Fulcro – Part 1: Getting Started https://www.youtube.com/watch?v=wEjNWUMCX78
- https://github.com/functional-koans/clojure-koans/
- https://github.com/bbatsov/clojure-style-guide
- https://clojuredocs.org/quickref
* Personalities
** Rich Hickey
- Talks https://www.youtube.com/playlist?list=PLZdCLR02grLrEwKaZv-5QbUzK0zGKOOcr
- https://github.com/tallesl/Rich-Hickey-fanclub
* Tools
- nrepl, inserted with cider-jack-in, but needed on projects if "lein run"
  https://docs.cider.mx/cider/0.26/basics/middleware_setup.html
* Web
- https://www.youtube.com/watch?v=wEjNWUMCX78&list=PLVi9lDx-4C_T7jkihlQflyqGqU4xVtsfi
** threeagent
- https://martin.varela.fi/2019/11/01/webgl-react-and-no-javascript/
  https://www.youtube.com/watch?v=myigRnZHhTw
** quil
- https://github.com/quil/quil-templates/
- https://gist.github.com/mmzsource/340322e6ff4b17be8b7dcb84d16d5172
#+begin_src
:profiles {:dev {:source-paths ["src"]
                   :repl-options {:nrepl-middleware
                                  [cider.piggieback/wrap-cljs-repl]}
                   :dependencies [[figwheel-sidecar "0.5.19"]
                                  [cider/piggieback "0.4.1"]]}}
#+end_src
- https://www.reddit.com/r/Clojure/comments/a69wse/setup_dynamic_clojurescript_and_quil_environment/
* Overtone
- https://github.com/pjagielski/disclojure
* Book: Clojurescript unraveled
|        |     | New                       | pred? | IFn | Lookup        |
|--------+-----+---------------------------+-------+-----+---------------|
| map    | {}  | (hash-map :name 1)        | false | yes | (assoc)       |
| list   | ()  | (list 1 2) (cons 0 '(1 2) | false | no  | (peek) (pop)  |
| vector | []  | (vector 1 2) (vec '(1 2)) | true  | yes | (nth) (assoc) |
| set    | #{} | (set [1 2 3 1])           | true  | yes | (get)         |
** 3 Language (the basics)
*** 3.1 First steps
- Lisp has ~no operators~, it only has functions.
*** 3.2 The base data typs
- Types: symbols, keywords, regexes, vars, atoms, volatiles
  - Tries to use host language provided types
    - integers are JS floating points
  - symbols: start with a non-numeric character
  - strings: are immutable
  - chars: get converted to single char JS string \a \newline
  - arrays: like lists can contain any type
*** 3.3 Vars
- vars are always ~top level~ in the namespace
*** 3.4 Functions
- lambdas: (fn [p1 p2] (+ p1 p2))
           (def addme (fn [p1 p2] (+ p1 p2)))
           (defn addme [p1 p2] (+ p1 p2)))
- ~defn~ is a macro
- multiple arity support
- variadic support: in the form of a list
- Lambdas:
  #()
  #(+ %1 %2)
  #(* % %)
  #(set %&)
*** 3.5 Flow control
- ~(if)~ is an expression and not a statement
- (cond & clausules)
  static branches, uses =
- (condp pred expr & clausules)
  on each clausule evals (pred TEST-EXPR expr)
*** 3.6 Truthfulness
- nil and false are the 2 ONLY false values
- nil is not the empty list
- Datastructures can be used as predicates
  - (filter MAP/SET (range 1 10))
  - (MAP/SET (range 1 10))
*** 3.7 Locals, blocks and loops
- ~(do)~ blocks are usually used for side effects
- ~(loop)~
  (loop [x 1]
    (if (= x 2)
      (println "done!")
      (recur (inc x))))
- ~(recur)~
  (defn afunc
    [x 1]
    (if (= x 2)
      (println "done!")
      (recur (inc x))))
- ~(for)~ is NOT used for iteration but for ~sequence comprehension~
  aka generating sequences
  - :let - local bindings, to bind nonseq values (?) let*?
  - :when - stop the generation when is not valid
  - :while
- ~(doseq)~ is analogous to (for) but always returns nil
- ~(run!)~ (run! println [1 2 3]) -  uses fast reduction
*** 3.8 Collection types
- ~structural sharing~ is used to avoid creating new memory for the same data

- ~(rest)~ is just like ~(next)~ except for empty seqs
 (rest []) => ()
 (next []) => nil
 (seq  []) => nil
- ~nil-punning~ is testing for nil

- ~(map)~ - can work on any sequence.
  For maps, it receive a 2 item vector, key and value.

- ~(coll?)~ ~(seq?)~  ~(seqable?)~
- Collection: ~(count)~ ~(empty)~ ~(empty?)~
              ~(conj)~ (conj [1 2 3] 4) => [1 2 3 4]
- Maps: ~(vals)~ returns the values of a map
- Lazyness: (~range~)
            (~take-while~ #(< % 10) (range 100))
- List: peek, pop, cons
- Vector: vector, vector?, vec, nth, assoc
  (~assoc~ COLL IDX NEW) - sets instead of looking up
  (~mapv~) and (~filterv~) - variants that return vector
- (sorted-map) (sorted-map-by)
  (sorted-set) (sorted-set-by)
- (compare a b) =>
  -1 if less
   0 if equal
   1 if greater
- queues pop from the front and push from the back
*** DONE 3.9 Destructuring
- everwhere when binding happens
**** indexed sequences
- can happen on arguments, matches any seq(?)
#+begin_src clojure
  (let [[fst _ thrd] [0 1 2]]
    [thrd fst])
  (defn swap-pair [[fst snd]]
    [snd fst])
  (swap-pair [1 2]) ; => [2 1]
  (swap-pair '(3 4)); => [4 3]
#+end_src
- ~&~ for varying length
- ~:as~ to keep the original
**** associative sequences (maps,vectors)
- ~:as~
- keys the are binding symbols (!
  (let [{lang :language} {:language "Clojurescript"}]
     lang)
- ~:or~ support for default on missing keys
  (let [{name :name :or {name "Anon"}} {:language "Clojurescript"}]
     name)
- shorthand with ~:keys~ or :strs or :syms
  (let [{:keys [name surname]} {:name "Ciri" :surname "Fio"}]
     [name surname])
*** DONE 3.10 Threading Macros
- function call parens are *optional* on threading macros
- in Clojure(script), transformation functions use...
  - 1st arg for...datastructures
  - last arg for...sequences or collections
- ->      first
  ->>     last
  as->    replace any position marked with $
  some->  they shortcircuit after the first nil
  some->>
  cond->  conditionally threads, optionally thread for each step based on a cond
  cond->>
*** DONE 3.11 Reader Conditionals
- #? and #?@
- .clj vs .cljs vs .cljc AKA conditional, ONLY work on that extension
#+begin_src clojure

;; Standard (#?)
(defn parse-int [v]
  #?(:clj  (Integer/parseInt v)
     :cljs (js/parseInt v)))

;; Splicing (#?@)
(defn make-list
  []
  (list #?@(:clj  [5 6 7 8]
            :cljs [1 2 3 4])))
;; Multiple
#?(:cljs
   (do
     (defn func-a [] :a)
     (defn func-b [] :b)))
#+end_src
*** DONE 3.12 Namespaces
- myapp.core and myapp.main
- myapp/src/myapp/core.cljs
                 /main.cljs
- "cljs.core" is loaded by default
- "cljs.user" is the default ns
#+begin_src clojure
(ns N1 "docstring for the namespace")
(ns N1 (:require N2 N3))
(ns N1 (:require [N2 :as N2ALIAS] [N3 :as N3ALIAS]))
(ns N1 (:require NS2 :refer [FUNC]))
(ns N1 (:refer-clojure :exclude [min]))
#+end_src
*** DONE 3.13 Abstractions and Polymorphism
**** Protocols    - TYPES
- defprotocol, satisfies?, extend-protocol, extend-type
- Consists of a name(I) AND a set of functions.
  Each function with at least 1 argument, the "self" or "this".
  aka "type based dispatching"
- Checks if instance satisfies the protocol
  (satisfies? IFn #{1})
  => true
#+begin_src clojure
(ns myapp.testproto)

(defprotocol IProtocolName
  "A docstring"
  (sample-method [this] "A docstring"))

(extend-type TYPE
  PROTOCOL
  (FUNC-NAME [this] (FUNC-IMPL)))

(extend-protocol PROTOCOL
  TYPE
  (FUNC-NAME [this] (FUNC-IMPL)))
#+end_src
**** Multimethods - DISPATCHER
- defmulti, defmethod
- Like "filtered-functions" in CL library
  You define a dispatcher function (defmulti) and multiple matching functions (defmethod)
#+begin_src clojure
(defmulti say-hello
  "docstring"
  (fn [param] (:locale param))
  :default :en)

(defmethod say-hello :en
  [person]
  (str "Hello " (:name person "Anonymous")))

(defmethod say-hello :es
  [person]
  (str "Hola " (:name person "Anonimo")))
#+end_src
**** Hierarchies  - INHERITANCE
- derive, ancestors, descendants, isa?, make-hierarchy
  :hierarchy
- defmulti, defmethod
  By default multimethods call isa? without passing a local hierarchy
#+begin_src clojure
;; GLOBAL HIERARCHY
;;(derive ::circle ::shape)
;;(derive ::box    ::shape)

;; LOCAL HIERARCHY
(def h (-> (make-hierarchy)
           (derive :box :shape)
           (derive :circle :shape))

(defmulti stringify-shape
  "docstring"
  identity
  :hierarchy #'h)

(defmethod stringify-shape :box
  [_]
  "A box")

(defmethod stringify-shape :shape
  [_]
  "A Shape")

(defmethod stringify-shape :default
  [_]
  "Unexpected object")
#+end_src
*** DONE 3.14 Data types
- reify: create an protocol without a type beforehand
- specify: add a proto to an already existent instance
**** deftype
- deftype, defrecord(preferred), ->NAME, map->NAME
  reify
  specify, specify!
#+begin_src clojure
(deftype User [firstname lastname])
(def person (User. "Triss" "Merigold"))
(.-firstname person) ; => "Triss"
(defn make-user      ; Custom constructor
  [firstname lastname]
  (User. firstname lastname))
#+end_src
**** defrecord
- records implement the *map protocol*
          do NOT implement IFn
          support assoc
          dissoc! returns a dict if it is a mandatory field
#+begin_src clojure
(defrecord User [firstname lastname])
(def person (User. "Yeneffer" "of Vengerberg"))
(:firstname person)    ; => "Yeneffer"
(get person :firstname); => "Yeneffer"
#+end_src
**** Implementing protocols
- protocols, both types and records support inline proto implementations
#+begin_src clojure
(defprotocol IUser
  "docstring"
  (full-name [_] "docstring"))
(defrecord User [firstname lastname]
  IUser
  (full-name [_]
    (str firstname " " lastname)))
#+end_src
*** DONE 3.15 Host interoperability
- "ClojureScript is *not interpreted*; it is always compiled down to JavaScript."
- ~js/~ namespace interacts with platform
- ~#js~ reader macro for literal js declaration
  (def myobj #js {:country "FR"})
  translates to kind of
  var myobj = {country: "FR"};
- ~.-~ prefix for object properties
  e.g.
  (.-PI js/Math)
- ~.~ prefix for methods or properties
  e.g.
  (.sqrt js/Math 2)
  (js/Math.sqrt 2)
   js/Math.PI
- ~clj->js~ and ~js->clj~
  ~into-array~
  make-array, count, aset, aget
*** DONE 3.16 State management
**** Vars
cannot be changed outside their namespace
**** Atoms
- atoms: atom, deref, @, swap!, reset!
#+begin_src clojure
(def ciri (atom {:name "Cirilla"
                 :lastname "Fiona"
                 :age 20}))
(deref ciri) ; GET value
@ciri        ; GET value
(swap! ciri update :age inc) ; UPDATE age
(reset! ciri {:name "Cirilla", ; SET ciri
              :lastname "Fiona",
              :age 22})
#+end_src
**** Observers
- observers: for atoms, triggered when swap! or reset! are used
#+begin_src clojure
(def a (atom))
(add-watch a :logger
  (fn [key the-atom old-value new-value]
    (println "Key: " key "Old:" old-value "New:" new-value)))
(remove-watch a :logger)
#+end_src
**** Volatiles
- like atoms, without valiators or observers
- volatile!, volatile?, deref, vswap!, vreset!
** 4 Tooling & Compiler
*** 4.1 Build
| Target  | Print                       | Entrypoint                 |   |   |
|---------+-----------------------------+----------------------------+---+---|
| Node    | (nodejs/enable-util-print!) | (set! *main-cli-fn* -main) |   |   |
| Browser | (enable-console-print!)     | NO                         |   |   |
- Compiler tooling: leiningen, cljsbuild, boot
- ~execution environment~, where JavaScript code can executed.
  - Web Browser (firefox, chrome, etc...)
  - nodejs (needs an entry point)
  - rhino (jdk6+)
  - nashorn (jdk8+)
  - qtquick (qt)
- Basic project structure:
  * deps.edn: define the version of clojure/script
  * build.clj: define input and output dir, target environment, entrypoint
  * src/myapp/core.cljs
- Build:
  > clojure build.clj
  > node main.js
- cljs.build.api/build
  cljs.build.api/watch
- Build options:
  ~:source-map~ connects the source to the generated javascript, for errors
  ~:optimizations~ closure opts are none, whitespace, simple, advanced
- Compilation process:
  - Reader phase, static analysis?
  - Clojuscript compiler emits javascript code
  - Closure Compiler takes the JS code and does some optimizations
- *clj* uses rlwrap unlike *clojure* cli command
- Optimizations levels: none, whitespace, simple, advanced
*** 4.2 REPL
| Env     | deps | DOM | Completion |   |
|---------+------+-----+------------+---|
| nashorn |      |     |            |   |
| nodejs  |      | NO  |            |   |
| browser |      |     |            |   |
| rebel   | YES  |     | YES        |   |
- browser: needs a browser to run the js code connect back to the CLI repl.
- rebel: works over node
*** 4.3 Google Closure
- Using a module of the Closure library
#+begin_src clojure
(ns yourapp.core
  (:require [goog.dom :as dom]))

(def element (dom/getElement "body"))
#+end_src
- Using modules that behave like a class or object
#+begin_src clojure
(ns yourapp.core
  (:import goog.History))

(def instance (History.))
#+end_src
- :require are used for user defined types (classes)
- As a Javascript library, cross-browser functions for DOM
*** 4.3 Dependency managment
- src/ : Can contain clojurescript ns OR javascript goog closure compatible modules
- :externs (?)
**** Clojure Libraries https://clojars.org/
  - Add into dep.edn
  - (require)
**** Javascript Libraries https://cljsjs.github.io/
  - Add into dep.edn
  - (require) but not alias
    - call it from the js namespace (js/call-it)
  - (require) and alias
    - call just with the alias
**** figwheel
  - add into dep.edn
  - add into tools.clj
  - It does:
    - return a repl with completion
    - starts a ring server on :output-dir
    - with code reloading
**** Unit Testing
- Advantage: ClojureScript tends to use plain data instead of complex objects
- In namespace *cljs.test*, also *test.check*
- main.cljs
- :target :nodejs
- Separate b/build
  - Added b/inputs "src" "test"
  - Different :main, :output-to/dir
- Separate b/watch
- Async Testing???
** 5 Language (advanced topics)
*** 5.1 Transducers
- map,filter,mapcat can be written as reduce funtions
- when you have several transformations (map, filter, mapcat) you can:
  - ~comp~ the ~partial~ of each: but each step will generate intermediate results that will be dropped
  - ~comp~ the 1 arg of each: they return the transducer version of it
**** Transients
- map,vectors and sets have a transient counterpart
*** 5.5 CSP (with core.async)
**** Channels
- chan, put!, take!, close!
- if we close a channel with pending takes, it returns nil
- channels ~limit~ of 1024 take/put pending per channel
- ~buffers~ extend it by adding a queue
* Book: Reactive with ClojureScript Recipies
** 2 - ClojureScript
*** Elements
|               | Javascript              | Clojure                       |
|---------------+-------------------------+-------------------------------|
| new*          | document.createElement  |                               |
|               | document.createTextNode |                               |
|               | node.cloneNode          |                               |
|---------------+-------------------------+-------------------------------|
| remove        |                         | (.removeChild parent child)   |
|---------------+-------------------------+-------------------------------|
| attach        | node.appendChild        |                               |
|               | node.insertBefore       |                               |
|               | node.replaceChild       |                               |
|---------------+-------------------------+-------------------------------|
| get           | getElementById          | (.getElementById js/document) |
|               | getElementsByTagName    |                               |
|               | getElementsByClassName  |                               |
|---------------+-------------------------+-------------------------------|
| get attribute |                         | (aget) (.-)                   |
| set attribute |                         | (aset)                        |
- new nodes still need to get attached to the DOM tree on a separate step
- *innerHTML* is a property on all nodes that take a string of the childrens
*** Events
- Input events: blur, change, focus, submit reset, keypress
- Mouse events: click, dbclick, mousedown, mousemove, mouseover
- (.addEventListener element eventtype function boolean)
*** Window Object
- "Link" between the DOM and JS.
  - Each tab, each frame has a Window Object
  - alert, confirm, prompt, setTimeout, setInterval uses it
  - access it with *js/window*
- (.addEventListener
   (.getElementById js/document "neko.gif")
   "mouseover"
   #(.alert js/window "mouse detected")
   false)
* Book: Etudes for Clojurescript
*** 1
- (in 'formulas.core)
- (require 'formulas.core :reload)
- (.pow js/Math NUMBER POWER)
  (js/Math.pow NUMBER POWER)
* Book: Web development with Clojure - 2nd Edition
*** 1
- in (defproject) we can set the *entry point* with :main, :main myapp.core/foo, unset by default
  you can it with:
  > lein run
- add/use luminus template for a quick webapp template
  > lein new luminus guestbook +h2
- hardcode a version by adding in ~/.lein/profiles.clj
  {:user {:plugins [[luminus/lein-template "2.9.9.2"]]}}
