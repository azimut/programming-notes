* 15 | The Go Programming Language          | Alan A. Donovan   | Addison
Code: https://github.com/adonovan/gopl.io/
** DONE 6 Methods
*** Method Declaration
- ~Method receiver~, is the extra parameter from a regular function definition.
- ~Selector~, is the obj.MethodName alone
- No special *self* name being used
- Methods and (struct) Fields inhabit the same namespace
- Can define methods on slices, if they are declared a type.
*** Methods with a Pointer Receiver
For methods that need to update the receiver, or the variable is too big to copy.
- CONVENTION: if a method of the type has a pointer receiver, all should use point receiver
  - If any method has ~*T~ avoid copying instances of ~T~
  - Unless the type is a pointer (slice/map)
- ~receiver parameter~ what the method declares (p Point) func ...
  ~receiver argument~  what the method receives Point{1,2}
- Method calls:
  - Same type of receiver arg and receiver param
  - Receiver arg is ~T~ and receiver param is ~*T~ (implicit &)
  - Receiver arg is ~*T~ and receiver param is ~T~ (implicit *)
- Receiver can accept nil (empty maps/slices)
*** Structure Embedding
- Embedding != Subclassing
- Language facilities:
 | Field access            | can access the fields of the embedded struct directly |
 | Method access/promotion | can access methods of the embedded struct directly    |
 | No Inheritance          | I still can't use it inplace of the embedded          |
- Works with pointers to a named type on the ~anonymous field~ (aka "child")
- Works with unnamed struct types too
*** Method Values and Expressions
**** Method Values
distanceP = p.Distance
Is a function that bind the method to a specific receiver.
- You can ~select~ the method, bind it, and use it later
- sometimes we can shorter code
  #+begin_src go
  time.AfterFunc(10 * time.Second, func() { r.Launch() })
  time.AfterFunc(10 * time.Second, r.Launch)
  #+end_src
**** Method Expression
distance = Point.Distance (or (*Point).Distance )
Is a function where the first argument is the receiver.
Can be useful when the value can be a choice between many others.
#+begin_src go
if add {
    op = Point.Add
} else {
    op = Point.Sub
}
...
op(p[0], offset)
#+end_src

*** Example: Bit Vector for set operations
instead of using map[T]bool
Bit-vector: uses a slice of unsigned integer,
            each bit represents a element present
- bytes.Buffer, is often used in String() methods
  buf.WriteByte()
  fmt.Fprintf(&buf,,)
- while declaring String(), for ~*T~ won't make it for ~T~
  use & accordingly
- binary operators:
  << (binary left shift), &(binary and), |= (bitwise inclusive or and assignment)
*** Encapsulation
aka getters and setters
- The unit of encapsulation is the ~package~
- We encapsulate on a struct, even if it is ONE field
** 7 Interfaces
*** 7.1 Interfaces as contracts
    Definitions: abstract type, implictly implemented
    An interface is contract, of what the type can do.
    Some cannot be expressed by the language and is detailed in the comments of the interface.
~substitutability~ of a type that satisfies the interface for another.
*** 7.2 Interface Types
    Inteface embedding
*** 7.3 Interface Satisfaction
- <TYPE> "is a" <INTERFACE>, when type satisfies the interface
- Only the methods revealed by the interface type may be called, even if the concrete type has others.
- ~empty interface~ interface{}, we can assign it anything, but we can't do nothing with it directly (see shadowing)
- I can create interfaces as I need them, some might refer to common properties (getter methods)
- *Documenting and asserting* the relationship between a type and intefaces it satisfies
  var _ io.Writer = (*bytes.Buffer)(nil)
*** 7.4 Parsing Flags with flag.Value
fmt.Sscanf - to read in put in format
- flag.Value is an interface
  #+begin_src go
  package flag
  type Value interface {
      String()    string // value to stdout
      Set(string) error  // stdin to value
  }
#+end_src
- Satisfying it, 1) wraping it on a struct
#+begin_src go
type celsiusFlag struct { Celsius }

func (f *celsiusFlag) Set(s string) error {...}

func CelciusFlag(name string, value Celsius, usage string) *Celsius {
    f := celsiusFlag{value}
    flag.CommandLine.Var(&f, name, usage) // Adds the flag
    return &f.Celsius
}
#+end_src
*** 7.5 Interface Values
The potential to *panic*
- Two components:
  - A concrete type (dynamic type)
  - A value of that type (dynamic value)
- Zero value for an interface is both nil, a ~nil interface value~
  - restored when one assigns nil to the interface variabe
- If the value is not comparable (slices, map) comparisons between interface values wil panic
- makes an impact on *nil*, when passes as an argument it will go from nil interface to:
  - The Type can be the interface one, while
  - The Value is nil
  - Which is != of a plain *nil*
*** 7.6 Sorting with sort.Interface
tabwriter.Write
#+begin_src go
package sort // provides inplace sorting
type Interface interface {
    Len() int
    Less(i, j int) bool // i,j are indices
    Swap(i, j int)
}
#+end_src
- Satisfied by providing ALL the methods for the type to satisfy
  #+begin_src go
  type StringSlice []string
  fun (p StringSlice) Len() { return len(p) }
  #+end_src
- A sort of a slice of pointers to struct runs faster (faster swap)
  than a slice of structs.
- To sort for each field of the struct,
  I need to create separate types that satisfy the interface
- sort.Reverse
  it uses a non-exported type (reverse) that embeds sort.Interface and
        changes the Less() by swapping the arguments
- sort.Sort(sort.Reverse(byArtist(tracks)))
- Custom sorts
  - wrapping the tracks and a function to sort on a struct
    then instantiation on the sort, where we define it with a *lambda*
    #+begin_src go
   sort.Sort(customSort{tracks, func(x, y *Track) book {
       if x.Title != y.Title {
         return x.Title < y.Title
       }
       if x.Year != y.Year {
         return x.Year < y.Year
       }
       if x.Length != y.Length {
         return x.Length < y.Length
       }
       return false
   }})
    #+end_src
*** 7.7 The http.Handler Interface
#+begin_src go
package http

type Handler interface {
  ServeHTTP(w ResponseWriter, r *Request)
}

func ListenAndServe(addres string, h Handler) error
#+end_src
- To satisfy we create a type, which can or can't hold data
  - We can switch on req.URL.Path on the ServeHTTP() method
- ServMux(), a Server Multiplexer, collects several http.handler(s) into one http.handler
  * Either, we register the handlers, ~mux.Handle()~ passing the url path AND the method to handle the path
    - Wrapped in http.HandlerFunc() which is a type conversion, of a type which is a function that satisfies http.Handler
      aka an *adapter*
      - A function type that has methods and satisfies an interface (!!!!)
      #+begin_src go
      package http
      type HandlerFunc func(w ResposeWriter, r *Request)
      func (f HandlerFunc) ServeHTTP(w ResponseWriter, r *Request) {
         f(w,r)
      }
      #+end_src
  * Or briefly, ~mux.HandleFunc(PATH, METHOD)~
  * Or more briefly, use the DefaultServerMux
- Each handle in a new goroutine
*** 7.8 The error Interface
- fmt.Errorf() calls errors.New()
  - given every time it creates a new one, there no 2 errors ==
#+begin_src go
type error interface {
  Error() string
}
#+end_src
- syscall.Errno(2) creates a error of type syscall.Errno which satisfies Error()
*** TODO 7.9 Example: Expression Evaluator
*** 7.15 A few Words of Advice
- "Interfaces are *only* needed when there are two or more
   concrete types that must be dealt with ina uniform way."
- Exception being when the interface and the (single only) type can't be on the same package.
- ~ask only for what you need~, rule of thumb for interface design
* 16 | Go in practice                       | Matt Butcher      | Manning
** 4 Handling Errors and Panics
- errors.New
  fmt.Errorf
- Sometimes, when returning a meaningful non-nil value we can ignore the error check
- Custom error types
  - When we need to return more than a string
  - packages can export errors (errors.New) instances that can be ~err ==~
  - Custom error, to add more data to the error
    #+begin_src go
      type ParseError struct {
          Message    string,
          Line, Char int
      }
      func (p *ParseError) Error() string {
         format := "%s on Line %d, Char %d"
         return fmt.Sprintf(format, p.Message, p.Line, p.Char)
      }
  #+end_src
  - Default interface
     #+begin_src go
       type error interface {
           Error() string
       }
     #+end_src
- panics
  - unwind the stack
  - if unhandled unwind the whole stack
  - signature is ~panic(interface{})~
* 16 | Go Programming Blueprints            | Mat Ryer          | Packt
   https://github.com/matryer/goblueprints
** 1 - Chat Application with Web Sockets
- we are using *package main* because we want to build and run our program from the CLI
- if we were building a reusable chating package,
  we might choose to use something different, such as *package chat*
** 6 - Exposing data and functionality through a RESTful data web service API
*** Context
   - *context* To share data between different handlers/middleware in a request
   - every http.Request comes with a context.Context, accesible through .Context()
   - Simple usage
   #+begin_src go
   ctx := context.WithValue(r.Context(), "key", "value")
   Handler.ServeHTTP(w, r.WithContext(ctx))
   #+end_src
   - Using private types for the key
     #+begin_src go
     type contextKey struct {
       name string
     }
     var contextKeyAPIKey = &contextKey{"api-key"}
     func APIKey(ctx context.Context) (string, bool) {
       key, ok := ctx.Value(contextKeyAPIKey).(string)
       return key, ok
     }
     #+end_src
*** Tags
    - Since we can put multiple structure tags, we can have different *views* over the same *model* (the struct)
      Example: json and bson (for mongo)
** 8 - Filesystem Backup
- With interfaces, we can export an *instance* of the type, without exporting the *type* itself
  #+begin_src go
    package backup

    type Archiver interface {
      Archive(src, dest string) error
    }
    type zipper struct{}
    var ZIP Archiver = (*zipper)(nil)// We export ZIP, which satisfies Archiver
 #+end_src
- Writing a string into a Writer:
  - io.WriteString()
  - fmt.Fprintf()
- Passing around errors, can help on *error recovery* OR passing the problem to something else.
- To associate *data* to each interface (ex: extension name string) we can add a func to the interface,
  that returns said data, and each implementation will have to define it.
- log.Fatal(), same as print to sterr and os.exit(1)
- we can use a *defer* on main, to return an error if the program failed
  #+begin_src go
    func main() {
      var fatalErr error
      defer func() {
        if fatalErr != nil {
          flag.PrintDefaults()
          log.Fatalln(fatalErr)
        }
      }()
      // ...
    }
  #+end_src
* 17 | Concurrency in Go                    | Katherine-Cox B.  | OReilly
** 4 Concurrency Patterns in Go
- Safe operations on concurrent code
  - sync.Mutex: for sharing memory
  - channels: via communicating
* 18 | Get Programming with Go              | Nathan Youngman   | Manning
Code: https://github.com/nathany/get-programming-with-go
** 5 State and behavior
*** DONE 21 A little Structure
- For things that go together (ex: latitude and longitude)
- New structs can either:
  #+begin_src go
  var curiosity struct {
    lat  float64
    long float64
  }
  // OR
  type location struct {
    lat  float64
    long float64
  }
  var curiosity location
  #+end_src
- ~Composite literals~
  location{lat: 1.3, long: 231.4}
  location{1.3, 231.4}
- Copied on :=
- ~Struct tags~ are the comments that go right of struct fields
*** DONE 22 GO's got no class
- Attaching methods to structures (types)
- Struct constructors are idiomatic
  func newLocation(lat, long coordinate) location {}
  func newLocationDMS()..
  func newLocationDD()..
- Sometimes just New(), if the package name is self descriptive
*** DONE 23 Composition
- "In OO, objects are *composed* of smaller objects in the same way."
- Behavior:
  On ~inheritence~, you create hierarchies. Which can be tricky to think about and change.
  On ~composition~, you create methods and associate them to each "class".
  Example: classifing animals by families *VS* creating attributes (walk, swim, nursing) and attach it to each animal
- State:
  ~Composition~ also takes place on structures.
   Break down a dispair structure into smaller ones. And combine them.
- Forwarding methods:
  // Naive
  type report struct {
    sol         int
    temperature temperature
    location    location
  }
  func (r report) avg() celsius {
    return r.temperature.avg()
  }
  ~Struct embedding~: makes all methods/subfields accessible from the main
                      the fields still exists
  type report struct {
    sol int
    temperature
    location
  }
  ~Name Collision~, compiler warns ONLY on ambiguous usage
*** DONE 24 Interfaces
- ~Interfaces~ A way to express an ~abstract~ concept, a *Writer*. In place of a ~concrete~ thing.
   A common behavior shared between "things".
- declaring var t with an *interface type*
  #+begin_src go
  var t interface {
      talk() string
  }
  #+end_src
  ~Polimorphysm~ The var can be (re)assigned anything, which type satisfies the interface.
- declaring a named *interface type*, usually ended with ~-er~, like fmt.Stringer
  #+begin_src go
  type talker interface {
      talk() string
  }
  #+end_src
  - They can be used anywhere a type is used.
- Interfaces work along with ~structure embedding~.
  Regular functions that take the interface, would take structure embedded ones.
     (unlike with just using methods).
- Interfaces in go are *satisfied implicitly*.
  We don't need to explicitly say that a struct would satisfy our own interface.
- ~Interface embedding~ is a thing, like with io.ReadWriter
  They save some typing, but not much else.
- Try to keep interface small
** 6 Down the gopher hole
*** DONE 26 A few pointers
- A ~Pointer~ is a variable that points to the address of another variable.
- ~Maps~ are pointers in disguise, no need to dereference on a function arg
  ~Slices~ are, in part, pointers to elements on an array.
           A pointer to a slice is only needed when modifing the cap/length/offset.
           Though, it might been better return a new slice.
- & address operator, can't take addresses of literal strings, number or booleans
- * dereference operator, also used in pointer types (like *int)
  can be assigned: *adminpoint = "new admin"
- ~Automatic dereferencing~
  - struct fields
  - array indexes
- Unlike C:
  - Arrays and pointers are different types altogether
  - GO avoids potential unsafe operations with pointers
    a *int pointer can only point to a memory position where there is a int
  - parameters are ALWAYS passed by value, pointers enable ~mutation~
- Methods who have a *pointer receiver* (mutable), can be sent from a struct or a pointer
  #+begin_src go
  func (p *person) book (){
     p.foo += 1
  }
  p1 := person{}  // struct
  p2 := &person{} // pointer
  p1.book()
  p2.book()
  #+end_src
* 19 | Black Hat Go                         | Tom Steele        | nostarch
  https://github.com/blackhat-go/bhg/
** Chapter 5 DNS
- with "net" package you can't set the resolver or run deep inspection (? on the result
- RR interface doesn't have methods to get the response IP
- to get the IP from a RR struct we use *type assertion* to create the data
- you can "cheat " and let the *flag* package handle/get all the args even the non-optionals as optionals, by then adding a check if not provided
* 21 | Learn Go With Tests                  | Chris James       |
source https://github.com/quii/learn-go-with-tests
** Arrays and Slices
- Benchmarking: =go test -bench=.=
  #+begin_src go
    func BenchmarkRepeat(b *testing.B) {
        for i := 0; i < b.N; i++ {
            Repeat("a")
        }
    }
  #+end_src
- t.Run("used to separate tests", func(t *testing.T){}})
- =%v= can be used on slices
- The goal should be to have as much confidence as possible in your code base.
  Not as much tests as possible.
  Every test has a cost.
- =go test -cover=
  100% coverage should not be your end goal.
- =reflect.DeepEqual= to test for slice equality in a test
  note: it's not compile time type safe
- You can assign function lambdas into variables, using =t.Helper()= inside the lambda
  #+begin_src go
    funct TestSumAllTails(t *testing.T) {
        checkSums := func(t testing.TB, got, want []int) {
            t.Helper()
            if !reflect.DeepEqual(got, want) {
                t.Error("got %v want %v", got, want)
            }
        }
        t.Run("make the sums of tails of", func (t *testing.T) {
            got := SumAllTails([]int{1,2}, []int{0,9})
            want := []int{2,9}
            checkSums(t, got, want)
        })
        t.Run("safely sum empty slices", func(t *testing.T){
            got := SumAllTails([]int{}, []int{3,4,5})
            want := []int{0,9}
            checkSums(t, got, want)
        })
    }
  #+end_src
** Structs, methods & interfaces
- if we wanted to have a function, that could take different struct/shapes
  func Area(???) float64
- in go, we could instead
  1) functions with the same name on different packages
  2) define methods on the types
- To remove some code duplication.
  To allow us to make functions taht can be used ith different types.
  #+begin_src go
    type Shape interface {
        Area() float64
    } // ...
    checkArea := func(t testing.TB, shape Shape, want float64) {
        t.Helper()
        got := shape.Area()
        if got != want {
            t.Errorf("got %g want %g", got, want)
        }
    } // ...
    checkArea(t, rectangle, 72.0) // ...
    checkArea(t, circle, 314.15925)
  #+end_src
- =table drive tests=, aka []struct{}, aka *anonymous struct*
  - ofc it can have fields that are struct
  - be sure that you have a need for the extra noise in the test
  - great when you want to:
    1) test various implementations of an interface
    2) or if the data has a lots of different requirements that need testing
- sometimes naming the fields of a struct would make it more clear
- "The test speaks to us more clearly, as if it were an assertion of truth, not a sequence of operations"
- =%#v= will print out our struct with e values in its field
** Pointers & errors
- =%v= can be used to print a pointer address (&w.balance)
- *struct pointers* (*w) are automatically deferenced
  - By convention you should keep you r method receiver types the same for consistency.
- Implementing Stringer interface, defined in the fmt package, used when formatted with %s
  #+begin_src go
    type Bitcoin int
    type Stringer interface {
        String() string
    }
    func (b Bitcoin) String() string {
        return fmt.Sprintf("%d BTC", b)
    }
  #+end_src
- *error* is an interface, that's why it can be *nil*
- to compare an error, as a string, use =err.Error()= and =%q= to print them
  #+begin_src go
    assertError := func(t testing.TB, got error, want string) {
        t.Helper()
        if got == nil {
            t.Fatal("didn't get an error but wanted one") // stop, do not continue test
        }
        if got.Error() != want {
            t.Errorf("got %q, want %q", got, want)
        }
    }
  #+end_src
- to compare errors, as a type
  #+begin_src go
    var ErrInsufficientFunds = errors.New("cannot withdraw, insufficient funds")
    // func () Foo() error ...
    return ErrInsufficientFunds
    // ...
    return nil
  #+end_src
- go install github.com/kisielk/errcheck
** Maps
- use =%q= to safely print a string, escaping quotes, instead of =%s=
- I can define a type for it and define a method on it
  #+begin_src go
    type Dictionary map[string]string
    func (d Dictionary) Search(word string) string {
        return d[word]
    }
  #+end_src
- You can modify them without passing as an address to it.
  However they are NOT a "reference type"
- ="A map value is a pointer to a runtime.hmap structure."=
- A map itself can be a nil value
  - it behaves like an empty map when *reading*
  - but attempts to *write* to a nil map, will cause a ~runtime panic~
- =You should NEVER initialize an empty map variable=
 #+begin_src go
   var m map[string]string // NO

   dictionary := map[string]string{"foo": "bar"} // YES
   var dictionary = map[string]string{}          // YES
   var dictionary = make(map[string]string)      // YES
 #+end_src
- To make errors a *const* instead of a *var* requires us to create our own
  DictionaryErr type which implements the error interface.
  #+begin_src go
    const (
        ErrNotFound   = DictionaryErr("could not find the word you were lookig for")
        ErrWordExists = DictionaryErr("cannot add word because t already exists")
    )
    type DictionaryErr string
    func (e DictionaryErr) Error() string {
        return string(e)
    }
  #+end_src
- It is often better to have a precise error for when an .Update() fails.
  Having specific errors gives you more information about what went wrong.
- delete(MAP, KEY)
** TODO Dependency Injection
- About dependency injection
  1) you don't need a framework
  2) it does not overcomplicate your design
  3) it facilitates testing
  4) it allows you to write great, general-purpose functions
*** Example: to *inject* we have to pass in the dependency of printing
#+begin_src go
  func Greet(name string) {
      fmt.print("Hello,  %s", name)
  }
  #+end_src
- instead our function does't nee to care where o how the printing appens
  we should accept an interface rather than a concrete type
  Writer defined in fmt
 #+begin_src go
   type Writer interface {
       Write(p []byte) (n int, err error)
   }
 #+end_src
- Greet() with interface
 #+begin_src go
   func TestGreet(t *testing.T) {
       buffer := bytes.Buffer{}
       Greet(&buffer, "Chris")
       got := buffer.String()
       want := "Hello, Chris"
       if got != want {
           t.Errorf("got %q want %q", got, want)
       }
   }
 #+end_src
* 21 | Cloud Native Go                      | Matthew A. Titmus | OReilly
  Repo: https://github.com/cloudnativego/
** 9 Building Web Application with Go
   https://github.com/cloudnativego/web-application/3
   - Serve static resources, where /assets/ is the directory where the static files are
     PathPrefix("/").Handler(http.FileServer(http.Dir(webroot+"/assets/")))
   - We can add later other .HandlerFunc() for other paths
   - Cases when a AJAX based rendering might not be the best solution:
     - You want a JS variable with the username of the currently logged user
     - Or other cookie data you want to be on HTML before JS loads
   - ~text/template~ package
     t := template.Must(template.ParseFiles("./a/path/index.html"))
     t.Execute(w, data) // Where data is a instance of a user defined struct, with `json:` tags
   - ~r.Form~ is part of the http.Response
     1) run r.ParseForm()
     2) k,v range on r.Form, which is a map[string][]string
*** Cookies:
   - Never store confidential or sensitive information on them.
   - Most store a randomly generated ID
   - ~net/http~ defines the Cookie struct
     http.SetCookie(w, &cookie)
     r.Cookie("acookie")
* 21 | Network Programming with Go          | Adam Woodbeck     | nostarch
** Introduction
- Writing network software using Go's *Asynchronous* features
- Emphasis on security
- TCP, UDP, Unix Socket
  Application-level protocols (http, http/2, TLS)
  Fob, JSON, protocol buffers, gRPC
** 1 An Overview of Networked Systems
*** Choosing a Network Topology
- Organization of nodes in a network
  * point-to-point: o-o
  * daisy chain:    o-o-o-o, a series of point-to-point with "hops" between 2 separated nodes
  * bus: common network link, common on wireless, everyone sees everything
  * ring: was used on some fiber-optic deployments, single direction
  * star: there is a central node, individual point-to-point connections
  * mesh: every node is fully connected to every other node
- Hybrid topologies are more common: star-ring, star-bus
*** Bandwidth vs. Latency
- CDN, Caching
- Go's concurrency to minimize server-side blocking of the response.
*** OSI: The Open Systems Interconnection Reference Model
Software application
7) Application (http)
6) Presentation (encryption, decoding)
5) Session (connection life cycle?)
4) Transport (tcp, udp)
3) Network (ip)
2) Data Link/Logical link control/Media Access control (mac) (error correction, common in wireless)
1) Physical (bit to electric/optical signal)
Physical transmission media
**** Payloads
Payload=Message Body=SDU=Service Data Unit
Layer4: TCP Payloads=Segments=Datagrams
Layer3: IP Payloads=Packet
Layer2: Frame (containing MAC and FCS, frame check sequence)
*** The TCP/IP Model
Software Application
- Application (7,6,5) (http,ftp,smtp,dhcp,dns)
- Transport (4)
- Internet/Network (3) (ip,bgp,icmp,igmp,ipsec)
- Link (2,1) (arp)
Physical Transmission Media

SLIP or PPP, were part of serial connections to the ISP.
No link layer protocol.
** 8 Writting HTTP Clients
URL = Uniform Resourse Locator
scheme://authority/path?query=abc&d=1#fragment
- Methods
  POST: for new data
  PUT: for updates
  PATCH: partial changes
  CONNECT: to request an *HTTP tunneling*
  TRACE: to echo what you send (test tampering?) (bad for XST)
- Response codes:h
  3XX-It needs further action from the client
  4XX-Error with the request
  5XX-Server side error
  304 Not Modified, works with the ETag header
  404 Not Found, sometimes as a ~glomar response~, not confirming or dening the resource exists or not
  426 Upgrade Required, when it needs to update to TLS before accessing the resource
- Versions:
  HTTP/1.0: requires separate TCP connections for different requests
  HTTP/1.1: ~keepalive~ allows different request in the same TCP connection
  HTTP/2  : allows server to push resources to the client.
- Go automatically consumes the Response headers, but leaves the body unread
  until is consumed or the connection closed.
- To reuse the connection you need to consume the body, which also happens when you .close() the body
- Default HTTP client has no timeout.
  context.WithTimeout()
  context.WithCancel() - and usin a timer time.AfterFunc()
- Disable reuse:
  req.Close = true
- Server must explicitly drain the request body before closing it.
- MIME: Multipupose Internet Mail Extension
  "mime/multipart" package
  Allows to send "field data" (key-values) or "form field"
  Sets a boundary for the date and sent on header Content-Type:
** 9 Building HTTP Services
- Client
  - We should get used to close the body
  #+begin_src go
  _ = resp.Body.Close()
  #+end_src
- In Go, a webservice relies on:
  - Handlers
  - Middleware: changes the handlers behavior or perform aux tasks (logging, authentication or access control)
  - Multiplexer
- Bare bones server implementation creates srv as a http.Server{} struct and then does:
  - net.Listen()
  - srv.Serve(listener)
  - srv.Close() - abruptly closes the server
*** http.Server{} timeouts
  - IdleTimeout: timout of how long keep the connection open (keepalive)
  - ReadHeaderTimeout: timout reading request headers (not body)
  - ReadTimeout: time the client has to send both header and body (ReadDeadLine of tcp socket)
  - WriteTimeout: time it has the client to read the server reply (WriteDeadLine of tcp socket)
*** TLS
    .Serve(l)
    .ServeTLS(l,CERT,KEY)
*** Handlers
  http.HandlerFunc(
     func(w http.ResponseWrite, r *http.Request) {...})
  - Usually we ignore any potential (response) write error
    - We can keep track however of the frequency they occur.
  - Drain and close the request body. http.Server{} only close it by default. So closing here is optional.
    #+begin_src go
    // Inside a Handler
    defer func(r io.ReadCloser) {
        _, _ = io.Copy(ioutil.Discard, r)
        _    = r.Close()
    }(r.Body)
    #+end_src
  - Use ~html/template~ package to escape HTML code, especially when part of the data comes from client.
  - To inject additional resources (than the request and response), like a database connection.
    - Use a *closure*:
    #+begin_src go
    dbHandler = func(db *sql.Db) http.Handler {
        return http.HandlerFunc(
            func(w http.Response, r *http.Request) {
                err := db.Ping()
            }
        )
    }
    #+end_src
    - Or add a field to the struct/type that satisfies the http.Handler interface
*** Testing with *net/http/httptest* package
  - httptest.NewRequest() will panic instead of throwing an error
    - unlike http.NewRequest
  - httptest.NewRecorder() returns a pointer to httptest.ResponseRecorder
     - use the .Result() method to return a pointer to http.Response
  - Pass the request/recorder to the Handler
  - Go assumes a 200 response if you write the body, before explicitly sending a header.
    - use http.Error(w, BODY, ERRORCODE)
*** Middleware
    - func(http.Handler) http.Handler
    - To inspect/act on the request.
      To add headers to the response
      Collect metrics
      Control access
    - If you find yourself writing the same handler, might be you can rewrite it as a middleware
    - This works by closuring the next handler
    - is NOT recommended performing many tasks on a single middleware
    - http.TimeoutHandler, middleware that sets an internal timer for the given duration. Returns 503 if timeout.
*** Multiplexers
    - The http.ServeMux multiplexer is a http.Handler that routes the incoming request into the proper Handler
    - You can drain and close the connection directly to the mux
      There is no harm in drain a close a previously drain and closed request
    - Subtree (/a/path/) vs absolute path (/another/path)
      Go will try to match the absolute path, if not matches, will add a / and try to match and 301 to it
* 21 | Distributed Services with Go         | Travis Jeffery    | Pragmatic Bookshelf
Source: https://pragprog.com/titles/tjgo/distributed-services-with-go/
Source: https://github.com/travisjeffery/proglog
- Author: Works at Confluence (kafka)
  https://twitter.com/travisjeffery
  https://travisjeffery.com/
  https://github.com/travisjeffery/jocko/
- Book uses code from Hashicorp's *Serf* and *Raft* packages
  Studied from Consul source code.
- "Designing data intense applications" by Martin Kleppman
  Covers data structures and algorithms for distributed services, abstractly.
- https://github.com/hashicorp/serf embeded service discovery
- https://github.com/uber-go/zap logging
- https://github.com/stretchr/testify/ testing lib
- https://github.com/travisjeffery/go-dynaport get a random free port
** Chapter 1: Let's Go
- On C, author was bugged by the lack of modules
- Author's project *Jocko*, and implementation of Kafka in Go
- JSON over HTTP, most common APIs on the web.
  - For internal web APIs, might use *protobuf/gRPC* for features not provided by it.
    Like type checking and versioning. (performance?)
- $ go mod init github.com/travisjeffery/proglog
  $ ls
  go.mod
- ~internal/server/log.go~ (package server)
  With the append log datastructure and basic .Append() .Read() methods
- Each JSON/HTTP handler should
  1. *Unmarshall* the JSON request into a struct
  2. *Run* the endpoint logic with the request
  3. *Marshal* and write that result to the response
  If handlers become much more complicated, move code out
- ~internal/server/http.go~ (package server)
  - Uses https://github.com/gorilla/mux
    Like http.ServMux, mux.Router implements http.Handler but provides easier ways to match different things on the URI
  - The producer and consumer handler code
- ~cmd/server/main.go~ (package main)
   - just .NewHTTPserver() and .ListenAndServe()
- encoding/json package encodes []byte as a base64 string
** Chapter 2: Structure with Protocol Buffers
- For internal APIs (with control of the clients)
  * Guarentees type-safety
  * Prevents schema-violations (across several microservices/teams)
  * Enables fast serialization (six times faster than JSON)
  * Offers backward compatibility
  * Language agnosticism
- From a .proto file you generate/compile to .go code
  #+begin_src
  syntax = "proto3"
  package twitter;
  message Tweet {
    string message = 1
  }
  #+end_src
- *protoc* is the compiler binary name
- Go convention is to put the .proto files on the *api/v1* directory
  - Using the *repeated* protobuf keyword to describe the slice of Records
  - You assign an "unique field number" to each field of the Message
- History: gogoprobuf was a fork of googles runtime to run protobuf, later replaced with Go API (APIv2)
- $ go get google.golang.org/protobuf/...@v1.25.0
  $ protoc api/v1/*.proto --go_out=. --go_opt=source_relative --proto_path=.
- Use a ~Makefile~
- You will end up creating *interfaces*, to handle the *getters* you get from the autogenerated code
  Or you will end up writting plugins for the protobuf generator (like to generate setters?)
** Chapter 3: Write a Log Package
- Other names:
  * write-ahead logs
  * transaction logs
  * commit logs
- Examples: ext journal, postgres WAL, raft append logs, Redux logs (?
- "Logs not only holds the latest state, but all states that have existed."
- Some implemetations split logs into *segments*, 1 active one.
  The index part of the logs can be *memory-map*
- Name convention:
  * Record: the data stored in our log.
  * Store: the file we store records in.
  * Index: the file we store index entries in.
  * Segment: the abstraction that ties a *store* and an *index* together.
  * Log: the abstraction that ties all the *segments* together.
*** internal/log/store.go
  - creates the filestorage abstraction struct
  - .Append()
    We write to the buffered writer instead of directly to the file
    to reduce the number of system calls and improve performance.
  - .Read()
    Call to .Flush() to clear the write buffer
    make() buffers to read from, in the memory stack
    We read directly from disk with s.File.ReadAt()
    We enc.Uint64 to get it from a read []byte
  - .ReadAt(), wrapper over .File.ReadAt() that calls buf.Flush()
  - .Close(),  wrapper over .File.Close() that cals to buf.Flush()
  - ~internal/log/store_test.go~
    Uses https://github.com/stretchr/testify for require.NoError() require.Equal()
    ioutil.TempFile(os.TempDir(), "some_extra_stuff")
*** internal/log/index.go
  Uses https://github.com/tysonmote/gommap to use the gommap.MMap
  - Once memory mapped we can't resize it, so we grow/os.Truncate() the file before mapping it.
  - .Close() syncs the mmap and file, and truncates back the file
  - NewIndex() reads and maps the index file, growing it before hand
  - .Read(in) (out, pos, error), *enc.Uint32(src)*
  - .Write(off, pos) *appends* off and pos to the index, *enc.PutUint32(dst,src)*
  - ~internal/log/index_test.go~
*** internal/log/config.go
  - Place for the Config struct
*** internal/log/segment.go
  Integrates both the *store* and *log* part
  newSegment()
  .Append(record *api.Record) protobuf marshalled the entry into the store
  .Read(uint64) (*api.Record, error) argument is used to lookup into the index which returns a position on the .store.Read()
  .IsMaxed() bool
  .Remove(), calls .Close() AND removes the assoc index and store from disk
  .Close(), closes both index and store
  .nearestMultiple(uint64, uint64) uint64
  - ~internal/log/segment_test.go~
    ioutil.Tempdir()
    os.RemoveAll()
*** internal/log/log.go
- Has a sync.RWMutex
- Manages the list of segments.
- Has an active segment, and a slice of segments
- NewLog()
- .setup(), reads all files names and gets the base offsets from it.
          , it creates the segments from them.
- .Append(*api.Record) (uint64, error), appends to the current segment, check if maxed to create a new segment
- .Read(offset uint64) (*api.Record, error), finds the segment where the offset falls in, s.Read(offset)
- .Close() error, closes every segment
- .Remove() error, .Close() and nukes it all os.RemoveAll(l.Dir)
- .Reset() error, .Reset() and .setup()
- .LowestOffset() (uint64, error), baseOffset from the [0] segment
  .HighestOffset() (uint64, error), nextOffset from the last segment
- .Truncate(lowest uint64) error, drops segments that are higher nextOffset than lowest
- .Reader() io.Reader, retuns a io.MultiReader, from each segment store, wrapped on a struct to make sure we read all the file using .ReadAt()
  - io.MultiReader is a concatenation of all input readers. After which it returns EOF.
- .newSegment(uint64) error, calls newSegment(), appends to the list, and makes it the active one
- ~internal/log/log_test.go~
  - uses t.Run(), ran under a loop of map[string]fn(*testing.T,*Log)
** Chapter 4: Serve Requests with gRPC
"A high performance, open source universal RPC framework"
https://www.grpc.io/
https://github.com/grpc-ecosystem
https://github.com/grpc-ecosystem/go-grpc-middleware
- "The best tool for serving request across distributed services."
  - Maintains these for both client and servers, for free
    - Compatibility
    - Performance
- Requests/Responses/Models/Serialization is type checked
- ~internal/~ packages are magical packages in Go that can only be imported by nearby code.
   code in /a/b/c/internal/d/e/f can be imported from /a/b/c, but not from /a/b/g
*** Goals when building a service
  - Simplicity: Abstract no-business logic away, while still having control. Express>gRPC>Rails
  - Maintainability: for backwards compatibility, the easiest is to *version* and *run* multiple instances of your API.
  - Security
  - Ease of use: type system will tell users when they do something wrong.
  - Performance
  - Scalability: Load balancing is possible.
    - thich client-side lb
    - proxy lb
    - look-aside lb
    - service mesh
*** Defining a gRPC service: is essentially a group of related RPC *endpoints*
  - Adding this on the previous ~.proto~ file
    #+begin_src
  service Log {
    rpc Consume(ConsumeRequest)              returns (ConsumeResponse) {}
    rpc Produce(ProduceRequest)              returns (ProduceResponse) {}
    rpc ConsumeStream(ConsumeRequest)        returns (stream ConsumeResponse) {}
    rpc ProduceStream(stream ProduceRequest) returns (stream ProduceResponse) {}
  }
  message ProduceRequest {
    Record record = 1;
  }
  message ProduceResponse {
    uint64 offset = 1;
  }
  message ConsumeRequest {
    uint64 offset = 1;
  }
  message ConsumeResponse {
    Record record = 2;
  }
  #+end_src
  - Compile
    $ go get google.golang.org/grpc@v1.32.0
    $ go get google.golang.org/grpc/cmd/protoc-gen-go-grpc@v1.0.0
    $ protoc api/v1/*.proto --go_out=. --go-grpc_out=. --go_opt=paths=source_relative --go-grpc_opt=paths=source_relative --proto_path=.
*** internal/server/server.go
- We need a struct whose methods match the service definition in your .proto
#+begin_src go
package server
import (
    "context"
    api "github.com/travisjeffery/proglog/api/v1"
    "google.golang.org/grpc"
)
type Config struct {
    CommitLog CommitLog
}
var _ api.LogServer = (*grpcServer)(nil)
type grpcServer struct {
    api.UnimplementedLogServer
    *Configp
}
func newgrpcServer(config *Config) (srv *grpcServer, err error) {
    srv = &grpcServer{
        Config: config,
    }
    return srv, nil
}
#+end_src
#+begin_src go
func (s *grpcServer) Produce(ctx context.Context, req *api.ProduceRequest) (*api.ProduceResponse, error) {
    offset, err := s.CommitLog.Append(req.Record)
    if err != nil {
        return nl, err
    }
    return &api.ProduceResponse{Offset: offset}, nil
}
func (s *grpcServer) Consume(ctx context.Context, req *api.ConsumeRequest) (*api.ConsumeResponse, error) {
    record, err := s.CommitLog.Read(req.Offset)
    if err != nil {
        return nil, err
    }
    return &api.ConsumeResponse{Response: record}, nil
}
#+end_src
#+begin_src go
func (s *grpcServer) ProduceStream(stream api.Log_ProduceStreamServer) error {
    for {
        req, err := stream.Recv()
        if err != nil {
            return err
        }
        res, err := s.Produce(stream.Context(), req)
        if err != nil {
            return err
        }
        if err = stream.Send(res); err != nil {
            return err
        }
    }
}
func (s *grpcServer) ConsumeStream(req *api.ConsumeRequest, stream api.Log_ConsumeStreamServer) error {
    for {
        select {
           case <-stream.Context().Done():
               return nil
           default:
               res, err := s.Consume(stream.Context(), req)
               switch err.(type) {
                   case nil:
                   case api.ErrOfsetOutOfRange:
                        continue
                   default:
                        return err
               }
        }
    }
}
#+end_src
** Chapter 7: Server-to-Server Service Discovery
- It must keep an up-to-date list (aka *registry*) of services/locations/health
- When?: for server-to-server communication, where you control the servers and don't need a LB
  - If you manage 10's or 100's of microserv1ices.
    Otherwise you will need the same ammount of LB's and DNS records.
- Two different service-discovery problems to solve
  - servers to discover each other (ch7,ch8)
  - clients to discover the servers (ch9)
- https://github.com/hashicorp/serf golang library that can be embeded SD to provide
  * decentralized cluster membership
  * failure detection
  * orchestration
- Serf uses a lightweight *gossip protocol* to communicate between the service nodes.
- Every instance on the cluster runs a *serf node*
*** Service Discovery
- go get github.com/hashcorp/serf@v0.8.5
- m.Config.Tags
  serf shares these tags to the other nodes in the cluster.
  eg: voter or non-voter
- m.EventCh
  where you receive sefs events when a node joins or leaves the cluster
**** internal/discover/membership.go
  #+begin_src go
    package discovery
    import (
            "net"
            "go.uber.org/zap"
            "github.com/hashicorp/serf/serf"
    )
    type Membership struct {
            Config
            handler Handler
            serf    *serf.Serf
            events  chan serf.Event
            logger  *zap.Logger
    }
    func New(handler Handler, config Config) (*Membership, error) {
            c := &Membership{
                    Config: config,
                    handler: handler,
                    logger: zap.L().Named("membership"),
            }
            if err := c.setupSerf(); err != nil {
                    return nil, err
            }
            return c, nil
    }
    type Config struct {
            NodeName       string
            BindAddr       string
            Tags           map[string]string
            StartJoinAddrs []string
    }
  #+end_src
**** setupSerf()
#+begin_src go
  func (m *Membership) setupSerf() (err error) {
          add, err := net.ResolveTCPAddr("tcp", m.BindAddr)
          if err != nil {
                  return err
          }
          config := serf.DefaultConfig()
          config.Init()
          config.MemberlistConfig.BindAddr = addr.IP.String()
          config.MemberlistConfig.BindPort = addr.Port
          m.events = make(chan serf.Event)
          config.EventCh = m.events
          config.Tags = m.Tags
          config.NodeName = m.Config.NodeName
          m.serf, err = serf.Create(config)
          if err != nil {
                 return err
          }
          go m.eventHandler()
          if m.StartJoinAddrs != nil {
                  _, err = m.serf.Join(m.StartJoinAddrs, true)
                  if err != nil {
                         return err
                  }
                  return nil
          }
          return nil
  }
#+end_src
**** eventHandler()
- runs in a loop, reading from the event channel
- an event can have multiple *members* (like if 2 joins happened in the same time span)
#+begin_src go
  type Handler interface {
          join(name, addr string) error
          Leave(name string) error
  }
  func (m *Membership) eventHandler() {
       for e := range m.events {
             switch e.EventType() {
             case serf.EventMemberJoin:
                  for _, member := range e.(serf.MemberEvent).Members {
                        if m.isLocal(member) {
                            continue
                        }
                        m.handleJoin(member)
                  }
             case serf.EventMemberLeave, serf.EventMemberFailed:
                  for _, member := range e.(serf.MemberEvent).Members {
                      if m.isLocal(member) {
                          return
                      }
                      m.handleLeave(member)
                  }
             }
       }
  }
  func (m *Membership) handleJoin(member serf.Member) {
       if err := m.handler.Join(member.Name, member.Tags["rpc_addr"]); err != nil {
             m.logError(err, "failed to join", member)
       }
  }
  func (m *Membership) handleLeave(member serf.Member) {
       if err := m.Handler.Leave(member.Name); err != nil {
             m.logError(err, "failed to leave", member)
       }
  }
#+end_src
**** rest
#+begin_src go
  func (m *Membership) isLocal(member serf.Member) bool {
          return m.serf.LocalMember().Name == member.Name
  }
  func (m *Membership) Members() []serf.Member {
          return m.serf.Members()
  }
  func (m *Membership) Leave() error {
          return m.serf.Leave()
  }
  func (m *Membership) logError(err error, msg string, member serf.Member) {
          m.logger.Error(msg, zap.Error(err), zap.String("name", member.Name), zap.String("rpc_addr", member.Tags["rpc_addr"])
  }
#+end_src
**** internal/discover/membership_test.go
#+begin_src go
  package discovery_test
  func TestMembership(t *testing.T) {
          m, handler := setupMember(t, nil)
          m, _        = setupMember(t, m)
          m, _        = setupMember(t, m)
          require.Eventually(t, func() bool {
                return 2 == len(handler.joins) &&
                       3 == len(m[0].Members()) &&
                       0 == len(handler.leaves)
          }, 3*time.Second, 250*time.Millisecond)
          require.NoError(t, m[2].Leave())
          require.Eventually(t, func() bool {
                return 2 == len(hanler.joins) &&
                       3 == len(m[0].Members()) &&
                       serf.StatusLeft == m[0].Members()[2].Status &&
                       1 == len(handler.leaves)
          }, 3*time.Second, 250*time.Millisecond)
          require.Equal(t, fmt.Sprintf("%d", 2), <-handler.leaves)
  }
  func setupMember(t *testing.T, members []*Membership) ([]*Membership, *handler) {
      id    := len(members)
      ports := dynaport.Get(1)
      addr  := fmt.Srpintf("%s:%d", "127.0.0.1", ports[0])
      tags  := map[string]string{ "rpc_addr": addr }
      c     := Config{
                 NodeName: fmt.Srpintf("%d", id),
                 BindAddr: addr,
                 Tags:     tags,
                }
      h     := &handler{}
      if len(members) == 0 {
          h.joins = make(chan map[string]string, 3)
          h.leaves = make(chan string, 3)
      } else {
          c.StartJoinAddrs = []string{ members[0].BindAddr }
      }
      m, err := New(h, c)
      require.NoErro(t, err)
      memebers = append(members, m)
      return members, h
  }
  type handler struct {
      joins  chan map[string]string
      leaves chan string
  }
  func (h *handler) Join(id, addr string) error {
      if h.joins != nil {
          h.joins <- map[string]string{ "id": id, "addr": addr }
      }
      return nil
  }
  func (h *handler) Leave(id string) error {
      if h.leaves != nil {
          h.leaves <- id
      }
      return nil
  }
#+end_src
*** Replication
- Eventually our replication will have a *leader-follower relationship*
- Start by replicating when they discover each other
- Types
  1) pull-based: the consumer polls the *data source* to check fr new data to consume.
     great for systems where consumers have different work loads
  2) push-based: the *data sources* pushes the data to the replica (eg:raft)
* 21 | Ultimate Go Notebook                 | William Kennedy   |
** Chapter 4: Decoupling
*** Method receiver, data semantics
- Pick between value and pointer
- Check the constructor
- Ask yourself, if the value can be copied
  - If yes, it can be passed as value
  - If no,  it needs to be passed as pointer
- Keep the same across all for the type
  - Exception being, if you are strictly implementing an interface
- OK      value->pointer
- NEVER pointer->value
*** Interfaces
- Use when
  1) Pluggable Implementation, is needed by the user of an API
  2) Multiple API Implementations
  3) Changability, parts of the API can change and need decoupling
- Do NOT use when
  1) For the sake of it
  2) To generalize an algorithm
  3) When the user can declare their own interfaces
  4) It is not clear if an interface would make the code clear
- Generalized interfaces that focus on *behavior* are the best
- Interfaces with >1 method, have >1 reason to change
- Interfaces based on nouns, tend to be less reusable
*** Polymorphism
- "The concrete type file now implements the reader interface using value semantics"
- Interface, has two words
  1) iTable
     1) describes the type of value stored
     2) has function poitners to the concrete implementations of the method set, for the type of value stored
  2) value being stored (a copy of it, or a pointer, depending the data semantics)
*** Method Set Rules
- A value         has attached all methods, for that type value
- A value address has attached all methods, for that type
*** Slice of Interfaces
- Reason why GO doesn't need *sub-typing*
  - it's all about =common behavior=, not *data*
*** (struct) Embedding
- Can also be either by value or pointer
- This is NOT *sub-classing*
  - NOT about reusing *state* is about =promoting behavior=
- Being METHOD a method of INNER
  OUTER.INNER.METHOD // direct call
  OUTER.METHOD       // calling the promoted method
*** Exporting
- Be consistent when exporting struct fields of an embedded structure.
- Returning a value of an unexported type is meaningless.
  Since the caller won't be able to reference it.
  #+begin_src go
  package counters
  type alertCounter int
  func New(value int) alertCounter {
    return alertCounter(value)
  }
  #+end_src
** Chapter 5: Software Design
*** Grouping different types of data
- Do not try to mimick inheritance in GO, with struct embedding
  - Embedding Is like a 1 way relationship, can't make a slice of the embedded type
  - "A Dog is a Dog, a Cat is a Cat, and a Animal an Animal"
  - It's not about grouping through common DNA,
    It's about grouping through common =behavior=.
- AVOID: Declaring a type just to share a set of common state.
- Interfaces give you the way to create slices of things with common behavior.
- Guidelines on creating types
  - Something new or unique
  - Do NOT create types for readability
  - Embed not for the state but for the behavior
    - If not, it will lock/rot the design
  - Question types that are aliases or abstractions of an existent type
  - Question types whose sole purpose is to share a common state
*** Don't design with interfaces
- Program then engineer
- "Don't design with interfaces, discover them" - Rob Pike
*** Decoupling with interfaces
- Work towards composing larger interfaces from smaller one
*** Error handling
- Create New() errors
  #+begin_src go
  var (
    ErrBadRequest = errors.New("Bad Request")
    ErrPageMoved = errors.New("Page Moved")
  )
  func webCall(b bool) error {
    if b {
      return ErrBadRequest
    }
    return ErrPageMoved
  }
  #+end_src
** TODO Chapter 6: Concurrency
*** 6.11 Channel Patterns
- for range on a channel is a blocking way to read a channel, shorter syntax for
  1) a infinite for{}
  2) a read from a channel with their second return value
  3) using that return value to /break/ from the for{}
- if a buffered channel is closed, data would flush out before routines receive close signal
  when using a for range
| Pattern Name         | Description                                                                    | C/B     | G | R | k | W | ctx |
|----------------------+--------------------------------------------------------------------------------+---------+---+---+---+---+-----|
| Wait 4 result        | spawed goroutine signals (channel) the result to the routine that create it    | 1/      | 1 | 1 | 1 |   |     |
| Fan Out/in           | Spawn as many goroutines as work to do, uses "Wait for result"                 | 1/n     | n | n | n |   |     |
| Wait 4 task          | spawns a goroutine before there is work, waiting a work on unbuffered channel  | 1/      | 1 | - | 1 |   |     |
| Pooling              | for efficienct *resource usage*, spawns a well defined number of goroutines    | 1/      | n | - | m |   |     |
| Drop                 | drops work on heavy loads, for range goroutine, select with default to drop    | 1/n     | 1 | - | m |   |     |
| Cancellation         | select{} with timeout, no notification to the goroutine of exit                | 1/1     | 1 | 1 | 1 |   |   1 |
| Fan Out/In Semaphore | goroutine per work, with a sem buffered channel to limit the nr of active ones | 1/n 1/m | n | n | n |   |     |
| Bounded Work Pooling | wg adds 1 for each goroutine, which closes once for range{} exits              | 1/g     | g | - | n | g |     |
| Retry Timeout        | after a failure, i want to retry for a fixed ammount of time, ctx & timer      |         |   |   |   |   |   1 |
| Channel Cancellation | takes a channel used for cancellation and converts it to a context             |         |   |   |   |   |   1 |
|----------------------+--------------------------------------------------------------------------------+---------+---+---+---+---+-----|
**** Retry Timeout
  #+begin_src go
    func retryTimeout(ctx context.Context, retryInterval time.Duration,
                      check func(ctx context.Context) error) {
        for {
            fmt.Println("perform usercheck call")
            if err := check(ctx); err == nil {
                fmt.Println("work finished successfully")
                return
            }
            fmt.Println("check if timeout has expired")
            if ctx.Err() != nil {
                fmt.Println("time expired 1 :", ctx.Err())
                return
            }
            fmt.Printf("wait %s before trying again\n", retryInterval)
            t := time.NewTimer(retryInterval)
            select {
            case <-ctx.Done():
                fmt.Println("timed expired 2:", ctx.Err())
                t.Stop()
                return
            case <-t.C:
                fmt.Println("retry again")
            }
        }
    }
  #+end_src
**** Channel Cancellation
#+begin_src go
  func channelCancellation(stop <-chan struct{}) {
      ctx, cancel := context.WithCancel(context.Background())
      defer cancel()
      go func() {
          select {
          case <-stop:
              cancel()
          case <-ctx.Done():
          }
      }()
      func(ctx context.Context) error {
          req, err := http.NewRequestWithContext(
              ctx,
              http.MethodGet,
              "https://www.ardanlabs.com/blog/index.xml",
              nil,
          )
          if err != nil {
              return err
          }
          _, err = http.DefaultClient.Do(req)
          if err != nil {
              return err
          }
          return nil
      }(ctx)
  }
#+end_src
** TODO Chapter 7: Testing
*** Basic Unit Testing
#+begin_src go
  package sample_test
  import (
      "testing"
  )
  func TestDownload(t *testing.T) {}
  func TestUpload(t *testing.T) {}
#+end_src
- Go defines a unit of code as a *package*, represented as a folder in the source tree
  The compiler builds a static library from each folder, and then links them all together.
- Always write tests like production code
- *Unit testing*, means testing the code of a single package, usually exported function
  - one convention is to define a new package for test
- *Integration tests*, will run test across multiple packages
- t.Fatal, will cause the test function to return
  t.Error, will allow the test function to continue and report potential more failures within the test
  t.Log, logs showed when using -v on go test
*** Table Unit Test
- When I have code that can the run through a series of inputs and expected outputs
- Perfect for *negative path testing*
#+begin_src go
  tt := []struct{
          url        string
          statusCode int
  }{
      {"http://def...", http.StatusOK}, // positive path test
      {"http://abc...", http.StatusNotFound}, // negative path test, for a bad url
  }
#+end_src
*** Web Call Mocking
- Mocking is better avoided. Eg: You can hit a docker container.
- A mock is only as good as the behavior being simulated.
  If the behavior chanegs in an upgrade of a system, the mock is no longer representative.
- Can be useful on Negative Path Testing, when it's difficult to cause real systems to fail on demand.
- stdlib already provides support for mocking http requests
#+begin_src go
  func mockServer() *httptest.Server{
      f := func() {
          w.WriteHeader(200)
          w.Header().Set("Content-Type", "application/xml")
          fmt.Fprintln(w, "<?xml version=...") // elided
      }
      return httptest.NewServer(http.HandlerFunc(f))
  }
#+end_src
* 22 | Network Programming with Go Language | Dr Jan Newmarch   | Apress
** 15 Websockets
 - HTTP 1.1 added "keep alive" keeping the connection open for a short while, helped mostly for images
 - AJAX (Asynchronous Javascript and XML) too helped interaction.
 - ws://, still user-agent initiated, but where is possible a server-to-browser communication
 - RFC https://datatracker.ietf.org/doc/html/rfc6455
 - starts listening as http:// and then switches to ws://
*** golang.org/x/net/websocket   | official
 - HTTP stream based protocol
 - WS  frame based protocol
 - TYPES
   var Message = Codec{marshal, unmarshal}
   var JSON = Codec{jsonMarshal, jsonUnmarshal}
 - SERVER
   websocket.Message.Send(ws, s)
   websocket.Message.Receive(ws, &s)
   websocket.Handler() // args is a func that takes a *websocket.Conn
 - CLIENT
   websocket.Dial(URL,PROTO,ORIGIN)
   websocket.Message.Receive
   websocket.Message.Send
 - JSON
   websocket.JSON.Receive(ws, &someStruct) error
   websocket.JSON.Send(conn, somestruct) error
**** echoserver.go
   #+begin_src go
   package main
   import (
     "fmt"
     "golang.org/x/net/websocket"
     "log"
     "net/http"
   )
   func Echo(ws *websocket.Conn) {
     fmt.Println("Echoing")
     for n := 0; n< 10; n++ {
       msg := "Hello " + string(n+48)
       fmt.Println("Sending to client: " + msg)
       err := websocket.Message.Send(ws, msg)
       if err != nil {
         fmt.Println("Can't send")
         break
       }
       var reply string
       err = websocket.Message.Receive(ws, &reply)
       if err != nil {
         fmt.Println("Can't receive")
         break
       }
       fmt.Println("Received back from client: " + reply)
     }
   }
   func main() {
     http.Handle("/", websocket.Handler(Echo))
     err := http.ListenAndServe(":12345", nil)
     checkError(err)
   }
   func checkError(err error) {
     if err != nil {
       log.Fatalln("Fatal error ", err.Error())
     }
   }
   #+end_src
**** echoclient.go
 #+begin_src go
 import (
   "fmt"
   "golang.org/x/net/websocket"
   "io"
   "os"
   "log"
 )
 func main() {
   if len(os.Args) != 2 {
     log.Fatalln("Usage: ", os.Args[0], "ws://host:port")
   }
   service := os.Args[1]
   conn, err := websocket.Dial(service, "", "http://localhost:12345")
   checkError(err)
   var msg string
   for {
     err := websocket.Message.Receive(conn, &msg)
     if err != nil {
       if err == io.EOF {
         break
       }
       fmt.Println("Couldn't receive msg " + err.Error())
       break
     }
     fmt.Println("Reeived from server: " + msg)
     err = websocket.Message.Send(conn, msg)
     if err != nil {
       fmt.Println("Couldn't return msg")
       break
     }
   }
 }
 func checkError(err error) {
   if err != nil {
     log.Fatalln("Fatal error ", err.Error())
   }
 }
 #+end_src
**** Codec and Implementing and XML codec
 - Codec signature
 #+begin_src go
 type Codec struct {
   Marshal   func(v interface{})                                (data []byte, payloadType byte, err error)
   Unmarshal func(data []byte, payloadType byte, v interface{}) (err error)
 }
 #+end_src
 - XML decoder
 #+begin_src go
 package main
 import (
   "encoding/xml"
   "golang.org/x/net/websocket"
 )
 func xmlMarshal(v interface{}) (msg []byte, payloadType byte, err error) {
   msg, err = xml.Marshal(v)
   return msg, websocket.TextFrame, nil
 }
 func xmlUnmarshal(msg []byte, payloadType byte, v interface{}) (err error) {
   err = xml.Unmarshal(msg, v)
   return err
 }
 var XMLCodec = websocket.Codec{xmlMarshal, xmlUnmarshal}
 #+end_src
*** github.com/gorilla/websocket | 3rd party
 - websoket.Upgrader{} // GLOBAL
   .Upgrade()
 - SERVER
   conn.WriteMessage(websocket.TextMessage, []byte(STRINGVAR))
   conn.ReadMessage()
   conn.Close()
 - CLIENT
   websocket.DefaultDialer.Dial(SERVNAME, make(http.Header))
   conn.ReadMessage()
   conn.WriteMessage()
   websocket.IsCloseError(err, websocket.CloseAbnormalClosure)
**** echoserver.go
 #+begin_src go
 package main
 import (
   "fmt"
   "github.com/gorilla/websocket"
   "log"
   "net/http"
 )
 var upgrader = websocket.Upgrader{
   ReadBufferSize:  1024,
   WriteBufferSize: 1024,
 }
 func Handler(w http.ResponseWriter, r *http.Request) {
   fmt.Println("Handling /")
   conn, err := upgrader.Upgrade(w, r, nil)
   if err != nil {
     fmt.Println(err)
     return
   }
   for n := 0; n < 10; n++ {
     msg := "Hello " + string(n+48)
     fmt.Println("Sending to client: " + msg)
     err = conn.WriteMessage(websocket.TextMessage, []byte(msg))
     _, reply, err := conn.ReadMessage()
     if err != nil {
       fmt.Println("Can't receive")
       break
     }
     fmt.Println("Received back from client: " + string(reply[:]))
   }
   conn.Close()
 }
 func main() {
   http.HandleFunc("/", Handler)
   err := http.ListenAndServe("loalhost:12345", nil)
   if err != nil {
     log.Fatalln("Fatal error ", err.Error())
   }
 }
 #+end_src
**** echoclient.go
 #+begin_src go
 package main
 import (
   "fmt"
   "github.com/gorilla/websocket"
   "io"
   "log"
   "net/http"
   "os"
 )
 func main() {
   if len(os.Args) != 2 {
     log.Fatalln("Usage: ", os.Args[0], "ws://host:port")
   }
   service := os.Args[1]
   header := make(http.Header)
   con, _, err := websocket.DefaultDialer.Dial(service, header)
   if err != nil {
     log.Fatalln("Fatal error ", err.Error())
   }
   for {
     _, reply, err := conn.ReadMessage()
     if err != nil {
       if err == io.EOF {
         fmt.Println("EOF from the server")
         break
       }
       if websocket.IsCloseError(err, websocket.CloseAbnormalClosure) {
         fmt.Println("Close from server")
         break
       }
       fmt.Prinln("Could not receive msg " + err.Error())
       break
     }
     fmt.Println("received from server: " + string(reply[:]))
     err = conn.WriteMessage(websocket.TextMessage, reply)
     if err != nil {
       fmt.Println("could not return msg")
       break
     }
   }
 }
 #+end_src
* 22 | 100 Go Mistakes and How Avoid Them   | Teiva Harsanyi    | Manning
source https://github.com/teivah/100-go-mistakes
** 05 Strings
- A *string* is an immutable data structure (aka slice) holding
  1) A ~pointer~ to an immutable byte sequence
  2) The total ~number of bytes~ in a sequence
*** Not understanding the concept of a *rune*
#+begin_src go
  type rune = int32
#+end_src
- charset != encoding
 | charset  | is a set characters          | Unicode (2^21 characters) |
 | encoding | is the translation to binary | UTF-8 (1-4bytes)          |
- In Unicode we use the concept of ~code point~ to refer to an item represented by a single value.
  U+6C49 in Unicode
  0xE6 0xB1 0x89 in UTF-8
- In Go, a ~rune~ is a Unicode ~code point~
- golang.org/x a repository that provies extensions to the standard library,
  contains packages to work with UTF-16 and UTF-32
- len(string) returns the *numbers of bytes* in string
*** Inaccurate string *iteration*
- we can use unicode/utf8's =utf8.RuneCountInString(string)= to get the number of runes in string
- Iterating with a range
  s[i], prints the utf-8 representation of *the single byte* at index
  #+begin_src go :imports "fmt"
    s := "h€llo"
    for i, r := range s {
        fmt.Printf("position %d: %c - %c\n", i, s[i], r)
    }
    fmt.Println(len(s))
  #+end_src

  #+RESULTS:
  : position 0: h - h
  : position 1: â - €
  : position 4: l - l
  : position 5: l - l
  : position 6: o - o
  : 7
- we can convert the string to a slice of rune, the indexes now will be proper positions
  #+begin_src go :imports "fmt"
    s := "hełło"
    runes := []rune(s)
    for i, r := range runes {
        fmt.Printf("position %d: %c\n", i, r)
    }
  #+end_src

  #+RESULTS:
  : position 0: h
  : position 1: e
  : position 2: ł
  : position 3: ł
  : position 4: o
*** Misusing *Trim* function
- strings.TrimRight != strings.TrimSuffix
  strings.TrimLeft  != strings.TrimPrefix
- TrimRight: removes all the trailing runes contained in a given set
  #+begin_src go :imports '("fmt" "strings")
    fmt.Println(strings.TrimRight("123oxo", "xo"))
  #+end_src

  #+RESULTS:
  : 123

*** Under-optimized string *concatenation*
- Given strings are immutable.
  Modifications don't update, they reallocate a new string memory.
**** Solution: use strings.Builder() instead of += for concatenating strings, internally uses a slice of bytes
  - .WriteString(s)
  - .Write(b)
  - .WriteRune(r)
  - .Grow(n)
   #+begin_src go
     func concat(values []string) string {
         sb := strings.Builder()
         for _, value := range values {
             _, _ := sb.WriteString(value) // errors can never happen with this usage
         }
         return sb.String()
     }
  #+end_src
**** Solution: using .Grow()
  #+begin_src go
    func concat(values []string) string {
        total := 0 // total number of bytes the final string will contain
        for i := 0; i < len(values); i++ {
            total += len(values[i])
        }
        sb := strings.Builder{}
        sb.Grow(total) // efficient slice initialization
        for _, value := range values {
            _, _ = s.WriteString(value)
        }
        return sb.String()
    }
  #+end_src
*** Useless string *conversions*
- Most I/O is actually done with []byte (eg: io.Reader, io.Writer and io.ReadAll)
- Example of the problem: casting from/to []byte and string
  #+begin_src go
    return []byte(sanitize(string(b))), nil
  #+end_src
- Solution: use *bytes* package analogue functions
  strings.TrimSpace has bytes.TrimSpace
*** Substrings and ~memory leaks~
**** substring slicing, would index by bytes NOT runes
- convert it to *[]rune* first to index by runes, and then back to *string*
  #+begin_src go :imports "fmt"
    s1 := "H€llo, World!"
    fmt.Println(s1[:5])
    fmt.Println(string([]rune(s1)[:5]))
  #+end_src

  #+RESULTS:
  : H€l
  : H€llo
**** When slicing a string, the new reference shares the same data behind it.
  You need to a deep copy of the slice. To not keep in memory the sliced string.
- Example: Where _log_ could be thousands of bytes long
  #+begin_src go
    uuid := log[:36]
    s.store(uuid)
  #+end_src
- Solution: do a deep copy
  #+begin_src go
    uuid := string([]byte(log[:36]))
    s.store(uuid)
  #+end_src
- Solution: use *strings.Clone* (>1.18)
  #+begin_src go
    uuid := strings.Clone(log[:36])
  #+end_src
** 06 Functions and Methods
*** DONE #42 Not knowing which *type of receiver* to use
- =Passing by reference doesn't exist in Go=.
- Mixing receiver types should be avoided in general, but is not forbidden in 100% of cases.
- Method Receiver Types:
  - Value
    - cannot be used with: map, function, or channel
    - use if
      - enforce immutability
  - Pointer
    - Go passes the address of an object to the method.
    - Intrinsically, it remains a copy, but we only copy a pointer, not the object itself.
    - Use if
      - you need to mutate the receiver, including a slice.
      - it contains a field that cannot be copied
      - object is too big
*** DONE #43 Never using *named result parameters*

- Naked returns
  - usage should be consistent in the scope, dont mix them with returns with arguments.
  - only for short functions

**** When to use it

1) on an interface signature, to make it more clear to readers.
   #+begin_src go
     type locator interface {
         getCoordinates(address string) (lat, lng float32, err error)
     }
   #+end_src
   - Although we could also create an adhoc struct with meaninful field names

2) on regular methods/functions when aids code readers (we could have chosen instead to return a struct an an error)
   #+begin_src go
     func (l loc) getCoordinates(address string) (lat, long float32, err erorr) {
     }
   #+end_src

**** When NOT to use it

- when it's convenient to have the results already initialized
- when it is NOT helpful to readers
  #+begin_src go
    func StoreCustomer(customer Customer) (err error) {}
  #+end_src

*** #44 Unintended side effects with *named result parameters*

- We might use the default value of the NRP incorrectly
  #+begin_src go
    func (l loc) getCoordinates(ctx context.Context, address string) (lat, lng float32, err error) {
        isValid := l.validateAddress(address)
        if !isValid {
            return 0, 0, errors.New("invalid address")
        }
        if ctx.Err() != nil {
            return 0, 0, err // HERE, we are returning err initialized with the default value "nil"
        }
        // ...get and return coordinate
    }
  #+end_src

*** Returning a *nil receiver*
- In Go, *nil* can be a valid _pointer receiver_,
  because in Go methods are just syntactic sugar for functions accepting the receiver as another function parameters
  #+begin_src go :main no
    package main
    import "fmt"
    type Foo struct{}
    func (foo *Foo) Bar() string {
        return "bar"
    }
    func main() {
        var foo *Foo
        fmt.Println(foo.Bar()) // foo is nil, still it compiles and prints "bar"
    }
  #+end_src

  #+RESULTS:
  : bar
- In Go, an interface is a dispatch wrapper.
  The wrappee might be nil. eg: a pointer to struct
  While the wrapper might not be nil. eg: an interface
- Example: This code does NOT returns *nil*, but a *nil pointer* (aka <nil>)
  aka the nil receiver is converted into a non-nil interface
  #+begin_src go
    func (c Customer) Validate() error {
        var m *MultiError
        if c.Age < 0 {
            // ...
        }
        if c.Name == "" {
            // ...
        }
        return m // returns a nil pointer if not implemented
    }
  #+end_src
- Solution: return "m" only if is not nil
  #+begin_src go
    func (c Customer) Validate() error {
        var m *MultiError
        if c.Age < 0 {
            // ...
        }
        if c.Name == "" {
            // ...
        }
        if m != nil {
            return m
        }
        return nil
    }
  #+end_src
*** Using a *filename* as a function input
- It is NOT considered the /best practice/ and can make unit tests harder to write.
  - Similarly with taking a http.Request as input
- Solution 1: accept a =*bufio.Scanner=, but is NOT idiomatic
**** Solution 2: accept a =io.Reader=, aka start from the reader's absraction
#+begin_src go
  func countEmptyLines(reader io.Reader) (int, error) {
      scanner := bufio.NewScanner(reader)
      for scanner.Scan() {
      }
  }
#+end_src
- One a unit test we can then pass a =strings.NewReader(``)= to the function
*** TODO Ignoring how defer arguments and recievers are evaluated
** 07 Error Managment
- go doesn't rely on the traditional _try/catch_ mechanism as most programming languages do
  errors are returned as normal return values
*** Panicking
- Once a panic is triggered, it continues up the call stack until either
  1) the current goroutine has returned
  2) or panic is caught with recover
- =recover()= is *only* useful inside a /defer/ function otherwise,
  the function would return *nil* and have no other effect.
- /defer/ functions are also executed when the surrounding function panics
- ~panic~ should be used sparingly
- ~panic~ is used to signal genuinely exceptional conditions
  1) such as a programmer error.
     - an invalid http code
     - received a nil instead of a pointer to struct (when receiving an interface)
     - received an already registered sql driver (in a map)
  2) when our application requires a dependency but fails to initialize it
     - regexp: Compile and MustCompile
- main.go
  #+begin_src go :imports '("fmt")
    func main() {
      defer func() {
         if r := recover(); r != nil {
           fmt.Println("recover", r)
         }
      }()
      f()
      fmt.Println("end main")
    }
    func f() {
      fmt.Println("a")
      panic("foo")
      fmt.Println("b")
    }
  #+end_src

  #+RESULTS:
  : a
  : recover foo
*** Ignoring when to wrap an error
- Since GO 1.13, "%w" directive allows us to wrap errors conveniently
- Use cases for error wrapping
  1) adding additional context to an error
     - if we get a "permission denied" error during a query, we might want to add the "user"
  2) marking an error as a specific error
     - like marking all 40X errors as a *Forbidden* error type
**** How to wrap an error?
| options                  | extra content | marking | source error availables |
|--------------------------+---------------+---------+-------------------------|
| returning error directly | no            | no      | *yes*                   |
| custom error type        | possible      | *yes*   | possible                |
| "%w"                     | *yes*         | no      | *yes*                   |
| "%v"                     | *yes*         | no      | no                      |
|--------------------------+---------------+---------+-------------------------|
- <1.13, =err.Err.Error()= creating a custom error type
  #+begin_src go
    type BarError struct {
        Err error
    }
    func (b BarError) Error() string {
        return "bar failed:" + b.Err.Error()
    }
    //...
    if err != nil {
        return BarError(Err: err)
    }

  #+end_src
- >1.13, =fmt.Errorf= "%w" wraps the source error to add context without having to create another error type (for internal API)
  #+begin_src go
    if err != nil {
        return fmt.Errorf("bar failed: %w", err)
    }
  #+end_src
- all,   =fmt.Errorf= "%v" not wrapped but transformed (for client API)
  #+begin_src go
    if err != nil {
        return fmt.Errorf("bar failed: %v", err)
    }
  #+end_src
*** TODO Checking an *error type*  inaccurately
*** TODO Checking an *error value* inaccurately
*** TODO *Handling* an error twice
*** TODO Not *handling* an error
*** TODO Not *handling* defer errors
** 08 Concurrency: Foundation
*** Mixing concurrency and Parallelism
*** Thinking concurrency is always faster
*** Being puzzled about when to use channels or mutexes
*** Not understanding race problems
*** Not understanding the concurrency impacts of a workload type
*** Misunderstanding Go contexts
** 11 Testing
*** Not categorizing tests *t.Skip*
- The testing pyramid, from top to bottom
  - E2E tests
  - Integration tests
  - Unit tests
- From cheaper to write, fast to execute, and highly deterministic. At the bottom. To less so at the top.
- How to categorize tests
  1) Build tags:
     - for example to give the tag "foo" to a file add "//go:build foo" or "// +build foo"
     - use a negative flag =//go:build !integration=
     - go test --tags=integration -v . # integration only
       go test -v .                    # unit test only
  2) Environment variables: https://peter.bourgon.org/blog/2021/04/02/dont-use-build-tags-for-integration-tests.html
     - Using tags, "go test" does NOT show what test were skipped.
     - os.GetEnv() + =t.Skip(MSG)=, the MSG is printed when running the tests
       #+begin_src go
         func TestInsert(t *testing.T) {
             if os.Getenv("INTEGRATION") != "true" {
                t.Skip("skipping integration test")
             }
             // ...
         }
       #+end_src
  3) Short mode: per test, not per file
     - =testing.Short()=
     - categorize by slowness. Some unit-test might be particularily slow.
     - go test -short -v .
     #+begin_src go
       // TestLongRunning ...
       func TestLongRunning(t *testing.T) {
           if testing.Short() {
               t.Skip("skipping long-running test")
           }
           // ...
       }
     #+end_src
*** Not enabling the *-race* flag
- go test -race ./...
- In Go, the race detector isn't a static analysis tool used during compilation.
  Instead it's a tool to find data races that occur at runtime.
- Adds a runtime overhead, by tracking all memory accesses and recording when and how they occur.
  - Memory usage +5-10x
  - Execution time +2-20x
- If a race is detected, Go raises a *warning*
- TIPS:
  - ensure that concurrent code is tested throughly against data races
  - to avoid false negative, put the data racy logic inside a loop, increasing the changes of caching it
  - //go:build !race
*** Not using test executables modes *-parallel* and *-shuffle*
- -parallel
  - go test -parallel 16 .
  - to speed up long running tests
  - executed alongside all the other parallel tests
    #+begin_src go
      func TestFoo(t *testing.T) {
          t.Parallel()
          // ...
      }
    #+end_src
- -shuffle (>1.17)
  - go test -shuffle=on -v .
  - To sus out hidden dependencies on non isolated tests
  - =on will return a "seed" value that we can use later to repeat the shuffle order
*** Not using table-driven tests *map[string]struct{}*
- t.Run("subtest 1") on TestFoo()
- go test -run=TestFoo/subtext_1 -v
- we could use a map to struct (code inside a TestFoo())
  #+begin_src go
    tests := map[string]struct{
        input    string
        expected string
    }{
        `empty`: {"", ""},
        `ending with \r\n`: {"a\r\n", "a"},
        `ending with \n`: {"a\n", "a"},
        `ending with multiple \n`: {"a\n\n\n", "a"},
        `ending without newline`: {"a","a"},
    }
    for name, tt := range tests {
        // tt := tt // if parallel
        t.Run(name, func(t *testing.T) {
            // t.Parallel()
            got := removeNewLineSuffixes(t.input)
            if got != tt.expected {
                t.Errorf("got: %s, expected: %s", got, tt.expected)
            }
        })
    }
  #+end_src
*** TODO Sleeping in unit tests
- caling *time.Sleep* can be a signal of flakyness
  - flaky means, that it can both pass or fail without any code change
*** TODO Not dealing with the time API efficiently
*** TODO Not using testing utility packages
*** TODO Writing innacurate benchmarks
*** Not exploring all the Go testing features
**** Code coverage
- go test -coverprofile=coverage.out ./... # by default coverage only is showed if tested on the same package
- go test -coverprofile=coverage.out ./... -coverpkg=./...
- go tool cover -html=coverage.out # opens the web browser and shows the coverage for each line of code
**** Testing from a different =package_test=
- aka using a different package on our _test.go
- One approach to unit tests, is to focus on behaviors instead of internals.
  We might want to focus on test on what's visible from the outside, not the implementation details.
  This way, if the implementation changes, the tests will remain the same.
  Also serves as an example of our API is used.
**** Utility functions, pass =t= as an argument to those
- We can simplify error handling, by passing t directly on helper functions instead of returning multiple values
  #+begin_src go
    func createCustomer(t *testing.T, someArg string) Customer {
        // Create customer
        if err != nil {
            t.Fatal(err)
        }
        return customer
    }
  #+end_src
**** Setup and teardown, =t.Cleanup()=
- t.Cleanup(fn), registers a function to be executed at the end of the test
#+begin_src go
  func createConnection(t *testing.T, dsn string) *sql.DB {
      db ,err := sql.Open("mysql", dsn)
      if err != nil {
          t.FailNow()
      }
      t.Cleanup(
          func() {
              _ = db.Close()
          })
      return db
  }
#+end_src
- To handle setup and teardown per package, we have to use TestMain
  #+begin_src go
    func TestMain(m *testing.M) {
        setupMySQL()
        ret := m.Run()
        teardownMySQL()
        os.Exit(ret)
    }
  #+end_src
