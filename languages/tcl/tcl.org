- Book: TCL for Web Nerds https://philip.greenspun.com/tcl/
- Tutorial https://wiki.tcl-lang.org/page/Tcl+Tutorial+Lesson+0
- Rules
  https://www.tcl.tk/man/tcl/TclCmd/Tcl.html
  https://wiki.tcl-lang.org/page/Dodekalogue
- Code eggdrop's twitter https://github.com/horgh/twitter-tcl
* Standard Library
- https://core.tcl-lang.org/tcllib/doc/trunk/embedded/md/toc.md
- https://www.tcl.tk/software/tcllib/
| calendar   | date & time operations. In development.                                                                                              |
| cmdline    | command line argument processor similar to opt                                                                                       |
| comm       | socket based 'send'.                                                                                                                 |
| counter    | Event counters, interval timers, and histogram display                                                                               |
| csv        | Handling of comma separated values                                                                                                   |
| doctools   | Writing manpages, the tcl way                                                                                                        |
| exif       | Handling of EXIF information generated by digital cameras                                                                            |
| fileutil   | Tcl implementations of some standard Unix utilities                                                                                  |
| math       | common math functions like min, max, and others                                                                                      |
| ncgi       | new CGI processing module                                                                                                            |
| nntp       | NNTP (news) client                                                                                                                   |
| ntp        | time clients                                                                                                                         |
| report     | Tabular ascii reporting. Interoperates with struct::matrix.                                                                          |
| soundex    | Phonetic string comparison                                                                                                           |
| struct     | Tcl implementations of common data structures (tree, graph, queue, matrix, pool, skiplist, priority queue, records, list operations) |
| stooop     | Pure Tcl OO package                                                                                                                  |
| textutil   | Text processing utilities, including a macro processor                                                                               |
** Web
| uri        | URI parsing module                          |
| mime       | MIME encoder and decoder                    |
| html       | HTML generation procedures. This uses ncgi. |
| htmlparse  | Parsing of HTML strings.                    |
| javascript | Javascript generation procedures.           |
** Dev
| log      | General logging and tracing facility.   |
| profiler | function level Tcl source code profiler |
** Crypto, Hash, Encoding
| base64 | base64, uuencode, yencode encoder and decoder      |
| crc    | Calculation of various CRC checksums               |
| des    | Tcl implementation of the Data Encryption Standard |
| md4    | MD4 hashes                                         |
| md5    | MD5 hashes                                         |
| sha1   | Secure Hash Algorithm                              |
** Protocols
| dns  | Tcl implementations of the DNS protocol |
| ftp  | FTP client library                      |
| irc  | Tcl implementation of the IRC protocol. |
| pop3 | POP3 protocol implementation            |
** Servers
| pop3d | POP3 server implementation and helper packages |
| ftpd  | FTP server                                     |
| smtpd | SMTP server implementation                     |
* Code: First version of redis
  https://gist.github.com/antirez/6ca04dd191bdb82aad9fb241013e88a8
#+begin_src tcl
  # LVDB - LLOOGG Memory DB
  # Copyriht (C) 2009 Salvatore Sanfilippo <antirez@gmail.com>
  # All Rights Reserved

  # TODO
  # - cron with cleanup of timedout clients, automatic dump
  # - the dump should use array startsearch to write it line by line
  #   and may just use gets to read element by element and load the whole state.
  # - 'help','stopserver','saveandstopserver','save','load','reset','keys' commands.
  # - ttl with milliseconds resolution 'ttl a 1000'. Check ttl in dump!
  # - cluster. Act as master, send write ops to all servers, get from one at random. Auto-serialization.
  # - 'hold' and 'continue' command, for sync in cluster mode
  # - auto-sync, consider lazy copy or log of operations to re-read at start
  # - client timeout
  # - save dump in temp file.[clock ticks] than rename it

  package require Tclx ;# For [fork]

  array set ::clients {}
  array set ::state {}
  array set ::readlen {}
  array set ::readbuf {}
  array set ::db {}
  array set ::ttl {}
  set ::dirty 0
  set ::lastsaved 0
  set ::listensocket {}

  signal -restart block SIGCHLD

  # the K combinator is using for Tcl object refcount hacking
  # in order to avoid useless object copy.
  proc K {x y} {
      set x
  }

  proc headappend {var e} {
      upvar 1 $var l
      set l [lreplace [K $l [set l {}]] -1 -1 $e]
  }

  proc log msg {
      puts stderr "[clock format [clock seconds]]\] $msg "
  }

  proc warning msg {
      log "*** WARNING: $msg"
  }

  proc writemsg {fd msg} {
      puts -nonewline $fd $msg
      puts -nonewline $fd "\r\n"
  }

  proc resetclient {fd} {
      set ::clients($fd) [clock seconds]
      set ::state($fd) {}
      set ::readlen($fd) 0
      set ::readbuf($fd) {}
  }

  proc accept {fd addr port} {
      resetclient $fd
      fconfigure $fd -blocking 0 -translation binary -encoding binary
      fileevent $fd readable [list readrequest $fd]
  }

  proc readrequest fd {
      if [eof $fd] {
          closeclient $fd
          return
      }

      # Handle bulk read
      if {$::state($fd) ne {}} {
          set buf [read $fd [expr {$::readlen($fd)-[string length $::readbuf($fd)]}]]
          append ::readbuf($fd) $buf
          if {[string length $::readbuf($fd)] >= $::readlen($fd)} {
              set ::readbuf($fd) [string range $::readbuf($fd) 0 end-2]
              lappend ::state($fd) $::readbuf($fd)
              cmd_[lindex $::state($fd) 0] $fd $::state($fd)
          }
          return
      }

      # Handle first line request
      set req [string trim [gets $fd] "\r\n "]
      if {$req eq {}} return

      # Process command
      set args [split $req]
      set cmd [string tolower [lindex $args 0]]
      foreach ct $::cmdtable {
          if {$cmd eq [lindex $ct 0] && [llength $args] == [lindex $ct 1]} {
              if {[lindex $ct 2] eq {inline}} {
                  cmd_$cmd $fd $args
              } else {
                  set readlen [lindex $args end]
                  if {$readlen < 0 || $readlen > 1024*1024} {
                      writemsg $fd "protocol error: invalid bulk read length"
                      closeclient $fd
                      return
                  }
                  bulkread $fd [lrange $args 0 end-1] $readlen
              }
              return
          }
      }
      writemsg $fd "protocol error: invalid command '$cmd'"
      closeclient $fd
  }

  proc bulkread {fd argv len} {
      set ::state($fd) $argv
      set ::readlen($fd) [expr {$len+2}]  ;# Add two bytes for CRLF
  }

  proc closeclient fd {
      unset ::clients($fd)
      unset ::state($fd)
      unset ::readlen($fd)
      unset ::readbuf($fd)
      close $fd
  }

  proc cron {} {
      # Todo timeout clients timeout
      puts "lmdb: [array size ::db] keys, [array size ::clients] clients, dirty: $::dirty, lastsaved: $::lastsaved"
      after 1000 cron
  }

  set ::cmdtable {
      {ping 1 inline}
      {quit 1 inline}
      {set 3 bulk}
      {get 2 inline}
      {exists 2 inline}
      {delete 2 inline}
      {incr 2 inline}
      {decr 2 inline}
      {lpush 3 bulk}
      {rpush 3 bulk}
      {save 1 inline}
      {bgsave 1 inline}
  }

  proc okreset {fd {msg OK}} {
      writemsg $fd $msg
      flush $fd
      resetclient $fd
  }

  proc cmd_ping {fd argv} {
      writemsg $fd "PONG"
      flush $fd
      resetclient $fd
  }

  proc cmd_quit {fd argv} {
      okreset $fd
      closeclient $fd
  }

  proc cmd_set {fd argv} {
      set ::db([lindex $argv 1]) [lindex $argv 2]
      incr ::dirty
      okreset $fd
  }

  proc cmd_get {fd argv} {
      if {[info exists ::db([lindex $argv 1])]} {
          set val $::db([lindex $argv 1])
      } else {
          set val {}
      }
      writemsg $fd [string length $val]
      writemsg $fd $val
      flush $fd
      resetclient $fd
  }

  proc cmd_exists {fd argv} {
      if {[info exists ::db([lindex $argv 1])]} {
          set res 1
      } else {
          set res 0
      }
      writemsg $fd $res
      flush $fd
      resetclient $fd
  }

  proc cmd_delete {fd argv} {
      unset -nocomplain -- ::db([lindex $argv 1])
      incr ::dirty
      writemsg $fd "OK"
      flush $fd
      resetclient $fd
  }

  proc cmd_incr {fd argv} {
      cmd_incrdecr $fd $argv 1
  }

  proc cmd_decr {fd argv} {
      cmd_incrdecr $fd $argv -1
  }

  proc cmd_incrdecr {fd argv n} {
      if {[catch {
          incr ::db([lindex $argv 1]) $n
      }]} {
          set ::db([lindex $argv 1]) $n
      }
      incr ::dirty
      writemsg $fd $::db([lindex $argv 1])
      flush $fd
      resetclient $fd
  }

  proc cmd_lpush {fd argv} {
      cmd_push $fd $argv -1
  }

  proc cmd_rpush {fd argv} {
      cmd_push $fd $argv 1
  }

  proc cmd_push {fd argv dir} {
      if {[catch {
          llength $::db([lindex $argv 1])
      }]} {
          if {![info exists ::db([lindex $argv 1])]} {
              set ::db([lindex $argv 1]) {}
          } else {
              set ::db([lindex $argv 1]) [split $::db([lindex $argv 1])]
          }
      }
      if {$dir == 1} {
          lappend ::db([lindex $argv 1]) [lindex $argv 2]
      } else {
          headappend ::db([lindex $argv 1]) [lindex $argv 2]
      }
      incr ::dirty
      okreset $fd
  }

  proc savedb {} {
      set err [catch {
          set fp [open "saved.lmdb" w]
          fconfigure $fp -encoding binary -translation binary
          set search [array startsearch ::db]
          set elements [array size ::db]
          for {set i 0} {$i < $elements} {incr i} {
              set key [array nextelement ::db $search]
              set val $::db($key)
              puts $fp "[string length $key] [string length $val]"
              puts -nonewline $fp $key
              puts -nonewline $fp $val
          }
          close $fp
          set ::dirty 0
          set ::lastsaved [clock seconds]
      } errmsg]
      if {$err} {return $errmsg}
      return {}
  }

  proc backgroundsave {} {
      unset -nocomplain ::dbcopy
      array set ::dbcopy [array get ::db]
  }

  proc cmd_bgsave {fd argv} {
      backgroundsave
      okreset $fd
  }

  proc cmd_save {fd argv} {
      set errmsg [savedb]
      if {$errmsg ne {}} {
          okreset $fd "ER"
          warning "Error trying to save: $errmsg"
      } else {
          okreset $fd
          log "State saved"
      }
  }

  proc loaddb {} {
      set err [catch {
          set fp [open "saved.lmdb"]
          fconfigure $fp -encoding binary -translation binary
          set count 0
          while {[gets $fp len] != -1} {
              set key [read $fp [lindex $len 0]]
              set val [read $fp [lindex $len 1]]
              set ::db($key) $val
              incr count
          }
          log "$count keys loaded"
          close $fp
      } errmsg]
      if {$err} {
          warning "Loading DB from file: $errmsg"
      }
      return $err
  }

  proc main {} {
      log "Server started"
      if {[file exists saved.lmdb]} loaddb
      set ::dirty 0
      set ::listensocket [socket -server accept 6379]
      cron
  }

  main
  vwait forever
#+end_src
* Commands
| apply     | applies an anonymous function                             |
| array     |                                                           |
| catch     |                                                           |
| coroutine | create and produce values from coroutines                 |
| dict      | are lists with an even number of elements, k,v            |
| expr      |                                                           |
| list      | creates a list with arguments, or an emtpy string         |
| namespace | create/access/destroy contexts for commands and variables |
| regexp    | matches                                                   |
| regsub    | substitution                                              |
| try       |                                                           |
| uplevel   | allows a command to be executed in a different scope      |
| upvar     | create s alink to a variable in a different stack frame   |
| yield     | ditto                                                     |
| yieldto   | ditto                                                     |
| zlib      | zlib library                                              |
* https://en.wikipedia.org/wiki/Tcl
- 1990-2012
- Scripting Language, embeded in C
- "Tcl casts everything into the mold of a _command_, even programming constructs".
- OO + FP + Imperative + Procedural
- Dynamically typed, everything can be treated as a string
- Bytecode Compiler
- Unicode support
- Regular expressions
- bignums
- lambdas
- tailcall/coroutine/yield
- variables are NOT declared but assigned to
- Event Driven interfaces to sockets/files
- Things written in it
  - expect
  - tk
- Supports ~line continuation~ by backslash
- Curly braces and variable substitution
  #+begin_src tcl
    # with them, VS is performed by expr
    set x 1
    set sum [expr {$x + 2 + 3 + 4 + 5}];
    # without them, VS ocurrs at the definition site
    set x 2
    set op *
    set y 3
    set res [expr $x$opt$y];
  #+end_src
- commands can be variadic, and with default values
- Substitution, happens from left-to-right. Just once.
- Types of substitution
  - Command: the content of a balanced square brackets []
  - Variable: variables with the dollar sign $
  - Backslash: a backslash and a letter like \n
- Values are immutable, not variables.
- {*} works as ,@ does on LISP
  causes the word to be splitted appart and passed to the command as separate arguments.
** uplevel
allows a command to be exeucted ina scope other thant the current
has the net effect of transformint the call stack into a call tree
#+begin_src tcl
  proc ffor {initCmd testExpr advanceCmd bodyScript} {
      uplevel 1 $initCmd
      set testCmd [list expr $testExpr]
      while {[uplevel 1 $testCmd]} {
          uplevel 1 $bodyScript
          uplevel 1 $advanceCmd
      }
  }
#+end_src
** upvar
arranges for one or more local variables in the current procedure
to ~refer~ to  variables in an enclosing procedure call or _global variables_
#+begin_src tcl
  proc decr {varName {decrement 1}} {
      upvar 1 $varName var
      incr var [expr {-$decrement}]
  }
#+end_src
