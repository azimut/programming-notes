- https://talks.golang.org/2013/bestpractices.slide  Francesc Campoy Flores 
- Write web applications in Go without using a framework
  https://www.youtube.com/playlist?list=PL41psiCma00wgiTKkAZwJiwtLTdcyEyc4
- https://www.youtube.com/playlist?list=PLJbE2Yu2zumCe9cO3SIyragJ8pLmVv0z9
- flags custom arg http://blog.ralch.com/tutorial/golang-custom-flags/
- SOCKS5 https://play.golang.org/p/l0iLtkD1DV (it also support HTTP_PROXY)
- a set of vulnerable Golang programs https://github.com/trailofbits/not-going-anywhere
- https://blog.golang.org/maps
- Going Infinite, handling 1M websockets connections in Go
  https://github.com/eranyanay/1m-go-websockets
n- Source analysis of sync.Mutex in golang
  https://programmer.group/source-analysis-of-sync.mutex-in-golang.html
- sync.RWMutex
  https://medium.com/golangspec/sync-rwmutex-ca6c6c3208a0
- https://github.com/guardrailsio/awesome-golang-security
- https://github.com/parsiya/Hacking-with-Go
* Personalities
** Rob Pike
https://www.youtube.com/playlist?list=PL3NQHgGj2vtsJkK6ZyTzogNUTqe4nFSWd
- GopherFest 2015: Rob Pike on the move from C to Go in the toolchain
  https://www.youtube.com/watch?v=cF1zJYkBW4A
  - llvm was slow
  - writing a compiler for your own language makes a language good for that...
  - own abi
  - own file format
  - translated the C code of the compiler to Go using a "translator"
* Learn
- https://github.com/golang-standards/project-layout/
- Learn Go Programming - Golang Tutorial for Beginners
  https://www.youtube.com/watch?v=YS4e4q9oBaU
- https://github.com/Alikhll/golang-developer-roadmap
- https://github.com/GoesToEleven/GolangTraining
- https://github.com/SuperPaintman/the-evolution-of-a-go-programmer
- https://github.com/ardanlabs/gotraining/tree/master/reading
- https://github.com/dariubs/GoBooks
- https://github.com/hoanhan101/ultimate-go
- https://github.com/inancgumus/learngo/
- https://github.com/quii/learn-go-with-tests
- https://github.com/re4lity/Hacking-With-Golang
- https://github.com/smallnest/go-best-practices
- https://go101.org/article/tips.html#force-to-use-keyed-struct-literals
- https://learnxinyminutes.com/docs/go/
- Style
  https://github.com/dgryski/awesome-go-style lists of good practices
  https://github.com/golang/go/wiki/CodeReviewComment
** Interview questions
  https://github.com/shomali11/go-interview
  https://github.com/hoanhan101/algo
  https://github.com/goquiz/goquiz.github.io
* Video: Practical Go: Real world advice for writing maintainable Go programs
   https://www.youtube.com/watch?v=gi7t6Pl9rxE
   https://dave.cheney.net/practical-go/presentations/qcon-china.html
   - Avoid naming with type, or  ex:
     - companiesMap map[string]*Company
     - config Config* // c Config* or conf *Config
     - config1 Config*, config2 Config* // original Config*, updated Config*
     - context context.Context // ctx context.Context
* Video: Will contracts replace interfaces? / Francesc Campoy
  https://www.youtube.com/watch?v=E75b9kuyRKw
  - Go has 2 types, abstract or concrete.
  - Interfaces
    - Canonical examples of interfaces are Reader/Writer with Read/Write methods.
    - They create a "set" of types
      - Can define an "union" interface of those interfaces
    - You can translate some of the behaviour of something (an object in other languages)
      to an interface with methods associated. Like a Stack which has Pop, Push, Empty methods.
    - And then you have algoritms that can work with that interface.
    - However there are types that are not completely defined by JUST an interface. So it is
      kind of an incomplete idea.
    - "Return concrete types, accept interfaces"
  - Call Dispatch: f.Do()
  - Interception Points: when an interface is provided for a struct type, the methods
    of the interface are the interception points.
  - ~Implicit interface satisfaction~ no implements. Instead of import the type of the interface you can declare it
    locally. "give me something that can Eval() or Pop() ... etc"
* Video: 7 common mistakes in Go and when to avoid them / Steve Francia
  https://www.youtube.com/watch?v=29LLRKIL_TI
  - Types can express State and Behavior
    - State = struct
    - Behavior = interface
  - 1) Accept interfaces parameters
  - 2) Use io.Reader, io.Writer
  - 3) Do not abuse broader interfaces
  - 4) Methods vs Functions
       - functions do not depend of state or do not change, same input same output. Can accept interfaces
       - method defines a behaviour of a type, depend of the state. Bound to a type.
  - 5) pointer vs value
  - 6) Custom error
* Tutorial: Learn go with tests
** Hello world
- Rules for "testing" package
  - files should be {file}_test.go
  - functions should be prefix TestSOMETHING()
  - functions only argument should be (t *testing.T)
- t.Errorf - formated output and fail test
  t.Run - Subtests
  t.Helper() - used by helper functions inside TestSOMETHING() to clean stacktrace
- Named return values are a thing, they create the var
- functions naming:
  - public functions start with CAPITAL letter
  - private functions start with a lowercase letter
* Tutorial: Effective Go
  https://golang.org/doc/effective_go.html
- "go fmt" uses tabs
- Unlike C, is OK return the address of a local variable (!
** Control structures
- if and switch accept an optional initialization statement like that of for
- break and continue statements take an optional label to identify what to break or continue
- for
  - Go's for has no comma operator
  - ++ and -- are statements not expressions.
  - for pos, char := range "ANUTF8STRING"
    works and steps over each unicode code points
- switch
  - do not need to be constants
  - if no expression, it switches true, so if-else-if-else chain is possible ina switch
  - cases can be comma separated
  - case or default
** Functions
- named result parameters: get zeroed and if return has not args they are returned
- defer: runs just before function returns, arguments are evaluated when defer executes not when call executes (immediatly)
** Data
*** New(T) allocates a zeroed pointer of type *T, often ready to use.
    but different than a mere var
  #+begin_src
  p := new(SyncedBuffer)  // type *SyncedBuffer
  var v SyncedBuffer      // type  SyncedBuffer
  #+end_src
*** when just New() isn't enough a constructor is provided, which calls New()
    and initiializes the struct with some values.
*** Composite Literal
  - Can be used for arrays, slices and maps.
    [4]string
    []string
    map[int]string
  #+begin_src go
  a := [...]string    {Enone: "no error", Eio: "Eio", Einval: "invalid argument"}
  s := []string       {Enone: "no error", Eio: "Eio", Einval: "invalid argument"}
  m := map[int]string {Enone: "no error", Eio: "Eio", Einval: "invalid argument"}
  #+end_src
  - On a map, for a constructor
  #+begin_src go
    f := new(File)
    f.fd = fd
    f.name = name
    f.dirinfo = nil
    f.nepipe = 0
    return f

    File{fd, name, nil, 0}
    return &F

    return &File{fd, name, nil, 0}

    return &File{fd: fd, name: name}

    new(File) .. is the same as .. &File{} .. which is a .. *File
  #+end_src
*** make(T,...)
  - for slices, maps and channels
  - returns a not zeroed value of type T (not *T)
*** arrays (building blocks for slices)
  - arrays are values, you assign the whole thing
    - or pass to a function a copy the whole thing not a reference
  - [10]int and [20]int are different datatypes
*** slices
  - cap() returns the max length or capacity it might have
  - Slices hold references to an underlying array,
      and if you assign one slice to another, both refer to the same array.
  - If a function takes a slice argument,
      changes it makes to the elements of the slice will be visible to the caller.
  - However, the metadata (structure holding the pointer, length and capacity) is passed
      by value. So we need to return the slice again.
*** 2d slices...
*** Maps
  - Like slices, maps hold references to an underlying data structure.
     If you pass a map to a function that changes the contents of the map,
     the changes will be visible in the caller.
  - An attempt to fetch a map value with a key that is not present in the map
     will return the zero value for the type of the entries in the map.
  - Indexing also returns a second boolean value if is or isn't on the map.
  - delete(Map, Key)
*** Printing
  - fmt.Print() fmt.Println() accept multiple args and print default format
  - fmt.Print(), adds space between each
  - fmt.Println(), adds space between each IF an arg is not a string, and adds newlin
  - fmt.FPrint.. functions prints to a buffer (an object that implements the io.Writer interface)
  - Format
    -  %d format prints based on the type (uint/int)
    -  %v prints the default...what fmt.Print() will show
    - %+v prints with struct field names
    - %#v prints in full Go syntax
    -  %q quotes string or []byte
          creates a rune from integer or rune
    - %#q backquotes
    -  %x hexa
    -  %x spaced hexa
    -  %T type
  - to change the default printing define, *T is more effective to use than T for structs
      func (t *T) String() string
  - We write ...v after v in the nested call to Sprintln to tell the compiler
      to treat v as a list of arguments; otherwise it would just pass v
      as a single slice argument.
  - There is also ...T for a variadic number of arguments of type T
*** Append
  - You can't actually write a function in Go where the type T is determined by the caller.
** Initialization
- Constants
  - Defined at compile time.
  - Either: numbers, charachters, strings or booleans.
- init() function on each file, to verify or repair correctness of the program state.
    packages initialization >
** Interfaces and other types
- Interfaces
  - if something can do this, then it can be used here.
  - Interfaces with only one or two methods are common in Go code
  - A type can implement multiple interfaces.
  - For instance, a collection can be sorted by the routines in package sort if it implements
    - sort.Interface
      - Len()
      - Less(i, j int) bool
      - Swap(i, j int)
- Convertions
  - It's an idiom in Go programs to convert the type of an expression to access a different set of methods. 
** Blank Identifier
  - unused import AND variables
    #+begin_src go
   var _ = fmt.Println
   _ = fd
    #+end_src
  - Import for side effects
    #+begin_src go
    import _ "net/http/pprof"
    #+end_src
  - Interface checks
* Book: Get Programming with Go (Manning)
Code: https://github.com/nathany/get-programming-with-go
** 5 State and behavior
*** DONE 21 A little Structure
- For things that go together (ex: latitude and longitude)
- New structs can either:
  #+begin_src go
  var curiosity struct {
    lat  float64
    long float64
  }
  // OR
  type location struct {
    lat  float64
    long float64
  }
  var curiosity location
  #+end_src
- ~Composite literals~
  location{lat: 1.3, long: 231.4}
  location{1.3, 231.4}
- Copied on :=
- ~Struct tags~ are the comments that go right of struct fields
*** DONE 22 GO's got no class
- Attaching methods to structures (types)
- Struct constructors are idiomatic
  func newLocation(lat, long coordinate) location {}
  func newLocationDMS()..
  func newLocationDD()..
- Sometimes just New(), if the package name is self descriptive
*** DONE 23 Composition
- "In OO, objects are *composed* of smaller objects in the same way."
- Behavior:
  On ~inheritence~, you create hierarchies. Which can be tricky to think about and change.
  On ~composition~, you create methods and associate them to each "class".
  Example: classifing animals by families *VS* creating attributes (walk, swim, nursing) and attach it to each animal
- State:
  ~Composition~ also takes place on structures.
   Break down a dispair structure into smaller ones. And combine them.
- Forwarding methods:
  // Naive
  type report struct {
    sol         int
    temperature temperature
    location    location
  }
  func (r report) avg() celsius {
    return r.temperature.avg()
  }
  ~Struct embedding~: makes all methods/subfields accessible from the main
                      the fields still exists
  type report struct {
    sol int
    temperature
    location
  }
  ~Name Collision~, compiler warns ONLY on ambiguous usage
*** DONE 24 Interfaces
- ~Interfaces~ A way to express an ~abstract~ concept, a *Writer*. In place of a ~concrete~ thing.
   A common behavior shared between "things".
- declaring var t with an *interface type*
  #+begin_src go
  var t interface {
      talk() string
  }
  #+end_src
  ~Polimorphysm~ The var can be (re)assigned anything, which type satisfies the interface.
- declaring a named *interface type*, usually ended with ~-er~, like fmt.Stringer
  #+begin_src go
  type talker interface {
      talk() string
  }
  #+end_src
  - They can be used anywhere a type is used.
- Interfaces work along with ~structure embedding~.
  Regular functions that take the interface, would take structure embedded ones.
     (unlike with just using methods).
- Interfaces in go are *satisfied implicitly*.
  We don't need to explicitly say that a struct would satisfy our own interface.
- ~Interface embedding~ is a thing, like with io.ReadWriter
  They save some typing, but not much else.
- Try to keep interface small
** 6 Down the gopher hole
*** DONE 26 A few pointers
- A ~Pointer~ is a variable that points to the address of another variable.
- ~Maps~ are pointers in disguise, no need to dereference on a function arg
  ~Slices~ are, in part, pointers to elements on an array.
           A pointer to a slice is only needed when modifing the cap/length/offset.
           Though, it might been better return a new slice.
- & address operator, can't take addresses of literal strings, number or booleans
- * dereference operator, also used in pointer types (like *int)
  can be assigned: *adminpoint = "new admin"
- ~Automatic dereferencing~
  - struct fields
  - array indexes
- Unlike C:
  - Arrays and pointers are different types altogether
  - GO avoids potential unsafe operations with pointers
    a *int pointer can only point to a memory position where there is a int
  - parameters are ALWAYS passed by value, pointers enable ~mutation~
- Methods who have a *pointer receiver* (mutable), can be sent from a struct or a pointer
  #+begin_src go
  func (p *person) book (){
     p.foo += 1
  }
  p1 := person{}  // struct
  p2 := &person{} // pointer
  p1.book()
  p2.book()
  #+end_src
* Book: Go in practice (Manning)
** 4.1
- errors.New
  fmt.Errorf
- Sometimes, when returning a meaningful non-nil value we can ignore the error check
- Custom error types
  - When we need to return more than a string
  - packages can export errors (errors.New) instances that can be ~err ==~
  - Custom error, to add more data to the error
     #+begin_src go
type ParseError struct {
    Message    string,
    Line, Char int
}
func (p *ParseError) Error() string {
   format := "%s on Line %d, Char %d"
   return fmt.Sprintf(format, p.Message, p.Line, p.Char)
}
  #+end_src
  - Default interface
     #+begin_src go
type error interface {
    Error() string
}
     #+end_src
- panics
  - unwind the stack
  - if unhandled unwind the whole stack
  - signature is ~panic(interface{})~
* Book: Black Hat Go (nostarch)
  https://github.com/blackhat-go/bhg/
** Chapter 5 DNS
- with "net" package you can't set the resolver or run deep inspection (? on the result
- RR interface doesn't have methods to get the response IP
- to get the IP from a RR struct we use *type assertion* to create the data
- you can "cheat " and let the *flag* package handle/get all the args even the non-optionals as optionals, by then adding a check if not provided
* Book: The Go Programming Language (Addison)
Code: https://github.com/adonovan/gopl.io/
** DONE 6 Methods
*** Method Declaration
- ~Method receiver~, is the extra parameter from a regular function definition.
- ~Selector~, is the obj.MethodName alone
- No special *self* name being used
- Methods and (struct) Fields inhabit the same namespace
- Can define methods on slices, if they are declared a type.
*** Methods with a Pointer Receiver
For methods that need to update the receiver, or the variable is too big to copy.
- CONVENTION: if a method of the type has a pointer receiver, all should use point receiver
  - If any method has ~*T~ avoid copying instances of ~T~
  - Unless the type is a pointer (slice/map)
- ~receiver parameter~ what the method declares (p Point) func ...
  ~receiver argument~  what the method receives Point{1,2}
- Method calls:
  - Same type of receiver arg and receiver param
  - Receiver arg is ~T~ and receiver param is ~*T~ (implicit &)
  - Receiver arg is ~*T~ and receiver param is ~T~ (implicit *)
- Receiver can accept nil (empty maps/slices)
*** Structure Embedding
- Embedding != Subclassing
- Language facilities:
  - Field access: I can access the fields of the embedded struct directly
  - Method access/promotion: can access methods of the embedded struct directly
  - No Inheritance: I still can't use it inplace of the embedded
- Works with pointers to a named type on the ~anonymous field~ (aka "child")
- Works with unnamed struct types too
*** Method Values and Expressions
**** Method Values
distanceP = p.Distance
Is a function that bind the method to a specific receiver.
- You can ~select~ the method, bind it, and use it later
- sometimes we can shorter code
  #+begin_src go
  time.AfterFunc(10 * time.Second, func() { r.Launch() })
  time.AfterFunc(10 * time.Second, r.Launch)
  #+end_src
**** Method Expression
distance = Point.Distance (or (*Point).Distance )
Is a function where the first argument is the receiver.
Can be useful when the value can be a choice between many others.
#+begin_src go
if add {
    op = Point.Add
} else {
    op = Point.Sub
}
...
op(p[0], offset)
#+end_src

*** Example: Bit Vector for set operations
instead of using map[T]bool
Bit-vector: uses a slice of unsigned integer,
            each bit represents a element present
- bytes.Buffer, is often used in String() methods
  buf.WriteByte()
  fmt.Fprintf(&buf,,)
- while declaring String(), for ~*T~ won't make it for ~T~
  use & accordingly
- binary operators:
  << (binary left shift), &(binary and), |= (bitwise inclusive or and assignment)
*** Encapsulation
aka getters and setters
- The unit of encapsulation is the ~package~
- We encapsulate on a struct, even if it is ONE field
** 7 Interfaces
- ~satisfied implicitly~ is a key feature of GO.
  No need to write all interfaces it satisfy on the type.
- are an ~abstract type~
* Language features
** slices
- http://blog.golang.org/go-slices-usage-and-internals
** errors
- http://blog.golang.org/error-handling-and-go
** everything is pass-by-value in Go.
** interfaces: different from classes as they not hold data
https://jordanorelli.com/post/32665860244/how-to-use-interfaces-in-go
#+begin_src
This is a core concept in Go’s type system;
instead of designing our abstractions in terms of what kind of data our types
can hold, we design our abstractions in terms of what actions our types can
execute.
#+end_src
