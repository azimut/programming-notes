- For minimal size file:
  > go build -ldflags="-s -w"
  - -w turns off DWARF debugging information (no gdb/pprof)
  - -s turns off the generation of symbol table (no go tool nm)
  > strip -x
* Videos
- GameDev with GO https://www.youtube.com/user/Velovix
- Learn Go Programming - Golang Tutorial for Beginners
  https://www.youtube.com/watch?v=YS4e4q9oBaU
- Make a chess program https://www.youtube.com/watch?v=zlPDWBLhn6c
- Write web applications in Go without using a framework
  https://www.youtube.com/playlist?list=PL41psiCma00wgiTKkAZwJiwtLTdcyEyc4
- Tutorial: https://www.youtube.com/playlist?list=PLJbE2Yu2zumCe9cO3SIyragJ8pLmVv0z9
- /r/golang/ favorite go conference talks https://www.reddit.com/r/golang/comments/ei54kv/what_are_your_favorite_go_conference_talks/
- /r/golang/ youtube.com https://www.reddit.com/r/golang/search?q=site%3Ayoutube.com&restrict_sr=1&sort=top
** Channels
- GopherCon UK https://www.youtube.com/c/GopherConUK/videos
- Learn To Code https://www.youtube.com/c/toddmcleod-learn-to-code/videos
- Go Class https://www.youtube.com/channel/UCC2ot8w_U6yQsq7jdpbECvQ/videos
- Justforfunc https://www.youtube.com/c/JustForFunc/videos
- Microservices: https://www.youtube.com/c/NicJackson/videos
- The Go Programming Language https://www.youtube.com/c/golang/videos
- Gopher Academy https://www.youtube.com/channel/UCx9QVEApa5BKLw9r8cnOFEA
- GopherCon Europe https://www.youtube.com/channel/UCxm3-iHEMy7IkU0_gwDVGAQ
- GopherCon UK https://www.youtube.com/channel/UC9ZNrGdT2aAdrNbX78lbNlQ
- Gophercon Israel https://www.youtube.com/channel/UCV_ox3kVvV5HrUz4JOuZpdQ
- Gophercon Russia https://www.youtube.com/channel/UCq-OB01F8YnS-FJpeJRCvMQ/videos
- Singapore Gophers https://www.youtube.com/channel/UCazkIMpjghmT8fugD1WF_DQ
* Personalities
** Rob Pike
https://www.youtube.com/playlist?list=PL3NQHgGj2vtsJkK6ZyTzogNUTqe4nFSWd
- GopherFest 2015: Rob Pike on the move from C to Go in the toolchain
  https://www.youtube.com/watch?v=cF1zJYkBW4A
  - llvm was slow
  - writing a compiler for your own language makes a language good for that...
  - own abi
  - own file format
  - translated the C code of the compiler to Go using a "translator"
** Dave Ceney
* Learn
- https://www.akitasoftware.com/blog-posts/taming-gos-memory-usage-or-how-we-avoided-rewriting-our-client-in-rust
- https://blog.twitch.tv/en/2019/04/10/go-memory-ballast-how-i-learnt-to-stop-worrying-and-love-the-heap-26c2462549a2/
- https://github.com/tmrts/go-patterns
- https://github.com/dgryski/go-perfbook
- http://blog.golang.org/go-slices-usage-and-internals
- http://blog.golang.org/error-handling-and-go
- https://jordanorelli.com/post/32665860244/how-to-use-interfaces-in-go
- https://talks.golang.org/2013/bestpractices.slide  Francesc Campoy Flores
- flags http://blog.ralch.com/tutorial/golang-custom-flags/
- SOCKS5 https://play.golang.org/p/l0iLtkD1DV (it also support HTTP_PROXY)
- a set of vulnerable Golang programs https://github.com/trailofbits/not-going-anywhere
- Source analysis of sync.Mutex in golang https://programmer.group/source-analysis-of-sync.mutex-in-golang.html
- sync.RWMutex https://medium.com/golangspec/sync-rwmutex-ca6c6c3208a0
- Layout https://github.com/golang-standards/project-layout/
- Roamap https://github.com/Alikhll/golang-developer-roadmap
- Meme: https://github.com/SuperPaintman/the-evolution-of-a-go-programmer
- Links https://github.com/ardanlabs/gotraining/tree/master/reading
- Links https://github.com/guardrailsio/awesome-golang-security
- Links https://github.com/smallnest/go-best-practices
- Links https://github.com/enocom/gopher-reading-list
- Links/Tools https://github.com/re4lity/Hacking-With-Golang
- Books: https://github.com/dariubs/GoBooks
- Exercises https://github.com/inancgumus/learngo/
- Tutorial https://github.com/parsiya/Hacking-with-Go
- Tutorial https://github.com/geektutu/7days-golang
- Tutorial Basics https://learnxinyminutes.com/docs/go/
- Tutorial Basics https://blog.golang.org/maps
- Tutorial Basics https://github.com/GoesToEleven/GolangTraining
- Tutorial Web https://github.com/astaxie/build-web-application-with-golang/
- Tutorial https://github.com/hoanhan101/ultimate-go https://github.com/ardanlabs/gotraining-studyguide
- Style https://github.com/dgryski/awesome-go-style lists of good practices
- Style https://github.com/uber-go/guide/
** Interview questions
   https://github.com/shomali11/go-interview
   https://github.com/hoanhan101/algo
   https://github.com/goquiz/goquiz.github.io
* TODO Video: Golang UK Conference 2015 - Andrew Gerrand - Stupid Gopher Tricks
  https://www.youtube.com/watch?v=UECh7X07m6E
  - struct{} is a type literal, on var foo struct{}
    - sometimes used on anonymous structs
    - used on template/json (when pulling a field) or enconding
    - can be nested
  - embeddes structs, inherit the methods of the childs
  - anynoymous, interfaces, used for type assertion
* TODO Video: GOTO 2020 â€¢ GraphQL, gRPC and REST, Oh My! A Method for Unified API Design (2020) / Mike Amundsen
  https://www.youtube.com/watch?v=oG6-r3UdenE
  Author of Book: "Design and Build Great Web APIs" (Prag Bookshelf)
- Designing API/Experience
  - Dealing with HTTP details, is implementation NOT design
- Case study:
  - Large company
  - Pick OpenApi as the backbone of the practice
* DONE Video: Intro to gRPC: A Modern Toolkit for Microservice Communication (2017)
https://www.youtube.com/watch?v=RoXT_Rkg8LA
REST: is the architectural principle (most use HTTP+JSON
Implementations:
  - C++/Java/Python/Go/Ruby/C#/Javascript/Objective-C/PHP
  - C/Java/Go (real implementations, other are bindings)
"Rest is actually not that great"
  - No formal (machine-readable) API *contract*
    - Writing client libraries requires humans
    - Humans are expensive(?) and don't like writing client libraries
  - *Streaming* is difficult.
  - *Bi-directional streaming* isn't possible at all
  - Operations are difficult to *model*
  - *Inefficient* (text isn't optimal for networks)
  - Internal services aren't RESTful, they are just HTTP endpoints (?)
Written in IDL (Interface Definition Language)
  - While protobuf defines the data, gRPC defines interface and data for accepted and returned by it
  - Machine readable
  - Can be compiled
    - Into Client libraries
    - Combined with a server stub (to create your tcp server of your protocol in few lines).
Alternatives
  - WSDL, tried to do this in the past for SOAP.
    - Tied to XML
  - Swagger:
    - Machine readable (on json...)
    - Still http/json (performance, streaming, modeling problems still present)
  - Thrift
    - less documented?
Born from Google's Project "stubby".
What really *IS*:
  - Built on top of HTTP/2
  - protobuf serialization
  - Allows client/server side streaming
*Interceptors* that are kind of "middleware" (on the http.Context sense of the word)
  - Can be used to add logging
  - On the server or client
Problems:
  - Load Balancing (needs to be a grpc aware lb)
  - Error handling is bad (no easy to add details of the error)
  - No support for browser JS
  - Breaking API changes (grpc side)
* DONE Video: Things In Go I Never Use (2018) / Mat Ryer
  https://www.youtube.com/watch?v=5DVV36uqQ4E
  Author of "Go Programming Blueprints"
- Arrays
- http.Handler, insted use http.HandlerFunc. So no need to implement the Serve(),
                we just need a function that return a http.HandlerFunc
  Might get slower on initialization: but with *var init Sync.Once* it solves it
- Keywords: goto, fallthrough, else
  - *goto*, the code gets difficult to "see". "Ok", when small and local.
  - *else*, don't for glanceability
  - *new*, just *AThing{}* or *var thing Athing*
- Build-In Functions: cap, complex, imag, new, panic, real, print, println
  - *panic*, only panic to give a better panic(), like with an argument explaining what happned
* DONE Video: dotGo 2014 - John Graham-Cumming - I came for the easy concurrency I stayed for the easy composition
- Problem: identify if site is cloudflare or not (check NS)
  #+begin_src go
type lookup struct {
  name       string
  err        error
  cloudflare bool
}
  #+end_src
- Problem: score exit tor nodes and score them on *Project Honeypot*
  Reusing code above with interfaces.
  With the ~factory pattern~.
  #+begin_src go
type factory interface {
  make(line string) task
}
type task interface {
  process()
  print()
}

type lookupFactory struct {
}
func (f *lookupFactory) make(line string) task {
  return &lookup{name: line}
}

type lookup struct {
  name string
  err error
  cloudflare bool
}
func (l +lookup) process() {
  nss, err := net.LookupNS(l.name)
  if err != nil {
    l.err = err
  } else {
    for _, ns := range nss {
        if strings.HasSuffix(ns.Host, ".ns.cloudflare.com") {
          l.cloudflare = true
          break
        }
    }
  }
}
  #+end_src
* TODO Video: Practical Go: Real world advice for writing maintainable Go programs / Dave Cheney (2019)
  https://www.youtube.com/watch?v=gi7t6Pl9rxE
  https://dave.cheney.net/practical-go/presentations/qcon-china.html
- "Waterfall way of writting books" (how books are written?)
- Bryan Cantrill talk about operative systems (LINK??)
** Identifiers
- Names have an *oversized* impact in go
- consise
  descriptive, on vars "how" is used not "what" it has, on methods "what" it does not "how"
  predictable
- DO not short already short names, like oid to just o
- Avoid naming with:
  | do NOT                           | instead                           |
  |----------------------------------+-----------------------------------|
  | companiesMap map[string]*Company | companies map[string]*Company     |
  | config Config*                   | c Config* or conf *Config         |
  | config1 Config*, config2 Config* | original Config*, updated Config* |
  | context context.Context          | ctx context.Context               |
- "a" and "b" are usually names given to variables that are going to be compared
** Comments
"Good code has a lot comments, bad code requires a lot of comments" -- Dave Thomas (on The Pragmatic Programmer)
- Start writting the comment fo rthe function.
  - If you found an *and* while writing the function, it is doing 2 things, and needs refactoring.
- Comment exported symbols
  - NOT implementation of an interface
** Package Design
- "Your one word elevator pitch word to define your package"
- Unique (a name that needs a partner like, client and server, is likely not a good name)
1:18:32
* TODO Video: Will contracts replace interfaces? / Francesc Campoy (2019)
  https://www.youtube.com/watch?v=E75b9kuyRKw
  - Go has 2 types, abstract or concrete.
  - Interfaces
    - Canonical examples of interfaces are Reader/Writer with Read/Write methods.
    - They create a "set" of types
      - Can define an "union" interface of those interfaces
      - The ~empty interface~ interface{} "contains" all the types
    - You can translate some of the behaviour of something (an object in other languages)
        to an interface with methods associated.
      Like a Stack which has Pop, Push, Empty methods.
    - And then you have algoritms that can work with that interface.
    - However there are types that are not completely defined by JUST an interface. So it is
      kind of an incomplete idea.
    - "Return concrete types, accept interfaces"
  - Call Dispatch: f.Do()
  - Interception Points: when an interface is provided for a struct type, the methods
    of the interface are the interception points.
  - ~Implicit interface satisfaction~ no implements. Instead of import the type of the interface you can declare it
    locally. "give me something that can Eval() or Pop() ... etc"
* DONE Video: 7 common mistakes in Go and when to avoid them / Steve Francia (2015)
  https://www.youtube.com/watch?v=29LLRKIL_TI
  - Types can express State and Behavior
    - State = struct
    - Behavior = interface
  - (Below are translated as DO)
    1) Accept interfaces parameters:
        Example: instead of translated a buffer to .Bytes()
                 just send it and accept the interface as argument
    2) Use io.Reader, io.Writer
    3) Do not abuse broader interfaces, use the smaller for the job
    4) Methods vs Functions
       - functions do not depend of state or do not change it, same input same output.
         Can accept interfaces
       - method defines a behaviour of a type, depend of the state.
         Bound to a type.
    5) pointer vs value: shared access vs value copied
    6) Custom error: implement the interface when needed
    7) Know what is Safe and what is Unsafe
* Video: Golang University
  https://www.youtube.com/playlist?list=PLEcwzBXTPUE_5m_JaMXmGEFgduH8EsuTs
** 2016 - Mat Ryer - Idiomatic Go Tricks - Golang UK Conference
   - No empty lines
   - Line of sight: 1 indentation at most
     - Make the happy treturn the last statement if possible
   - Single method interfaces
     - Function type alternatives for single method interfaces (like HandlerFunc)
     - can also use them as a slice of interface
   - Log Blocks
     log.Println("----")
     defer log.Println("----")
   - return teardown functions as an argument
     - so it can be immediatly defer after assigment
   - You can check if a element implements an interface.
     #+begin_src go
                          // where v is an interface{}
     obj, ok := v.(Valid) // where Valid is an interface, that implements OK()
     if !ok {
       return nil // no OK method
     }
     #+end_src
   - Sometimes somebody elese provides the struct (and not the interface)
     - Make your own interface
   - We can leave the receiver part of a method empty, just specify the type
   - We can use channels as semaphores to limit the ammount of work.
** TODO 2019 - Dave Cheney - Clear is better than clever - GopherCon SG
   https://www.youtube.com/watch?v=NwEuRO_w8HE
   - Source code is the intermediate form, between the idea and what the machine does
   - Readability is subjective
   - Clarity != Readability
   - you can either use new() or &Thing{}
   - When you see something complicated, it should be complicated
     12:00
* TODO Video: Going Infinite, handling 1 millions websockets connections in Go / Eran Yanay
  https://www.youtube.com/watch?v=LI1YTFMi8W4
  https://github.com/eranyanay/1m-go-websockets
- First problem is not having long lived connections. (ignores keep alive?)

* TODO Tutorial: Learn go with tests
  https://github.com/quii/learn-go-with-tests
** Hello world
- Rules for "testing" package
  - files should be {file}_test.go
  - functions should be prefix TestSOMETHING()
  - functions only argument should be (t *testing.T)
- t.Errorf - formated output and fail test
  t.Run - Subtests
  t.Helper() - used by helper functions inside TestSOMETHING() to clean stacktrace
- Named return values are a thing, they create the var
- functions naming:
  - public functions start with CAPITAL letter
  - private functions start with a lowercase letter
   * TODO Tutorial: Effective Go
  https://golang.org/doc/effective_go.html
- "go fmt" uses tabs
- Unlike C, is OK return the address of a local variable (!
** Control structures
- if and switch accept an optional initialization statement like that of for
- break and continue statements take an optional label to identify what to break or continue
- for
  - Go's for has no comma operator
  - ++ and -- are statements not expressions.
  - for pos, char := range "ANUTF8STRING"
    works and steps over each unicode code points
- switch
  - do not need to be constants
  - if no expression, it switches true, so if-else-if-else chain is possible ina switch
  - cases can be comma separated
  - case or default
** Functions
- named result parameters: get zeroed and if return has not args they are returned
- defer: runs just before function returns, arguments are evaluated when defer executes not when call executes (immediatly)
** Data
*** New(T) allocates a zeroed pointer of type *T, often ready to use.
    but different than a mere var
  #+begin_src
  p := new(SyncedBuffer)  // type *SyncedBuffer
  var v SyncedBuffer      // type  SyncedBuffer
  #+end_src
*** when just New() isn't enough a constructor is provided, which calls New()
    and initiializes the struct with some values.
*** Composite Literal
  - Can be used for arrays, slices and maps.
    [4]string
    []string
    map[int]string
  #+begin_src go
  a := [...]string    {Enone: "no error", Eio: "Eio", Einval: "invalid argument"}
  s := []string       {Enone: "no error", Eio: "Eio", Einval: "invalid argument"}
  m := map[int]string {Enone: "no error", Eio: "Eio", Einval: "invalid argument"}
  #+end_src
  - On a map, for a constructor
  #+begin_src go
    f := new(File)
    f.fd = fd
    f.name = name
    f.dirinfo = nil
    f.nepipe = 0
    return f

    File{fd, name, nil, 0}
    return &F

    return &File{fd, name, nil, 0}

    return &File{fd: fd, name: name}

    new(File) .. is the same as .. &File{} .. which is a .. *File
  #+end_src
*** make(T,...)
  - for slices, maps and channels
  - returns a not zeroed value of type T (not *T)
*** arrays (building blocks for slices)
  - arrays are values, you assign the whole thing
    - or pass to a function a copy the whole thing not a reference
  - [10]int and [20]int are different datatypes
*** slices
  - cap() returns the max length or capacity it might have
  - Slices hold references to an underlying array,
      and if you assign one slice to another, both refer to the same array.
  - If a function takes a slice argument,
      changes it makes to the elements of the slice will be visible to the caller.
  - However, the metadata (structure holding the pointer, length and capacity) is passed
      by value. So we need to return the slice again.
*** 2d slices...
*** Maps
  - Like slices, maps hold references to an underlying data structure.
     If you pass a map to a function that changes the contents of the map,
     the changes will be visible in the caller.
  - An attempt to fetch a map value with a key that is not present in the map
     will return the zero value for the type of the entries in the map.
  - Indexing also returns a second boolean value if is or isn't on the map.
  - delete(Map, Key)
*** Printing
  - fmt.Print() fmt.Println() accept multiple args and print default format
  - fmt.Print(), adds space between each
  - fmt.Println(), adds space between each IF an arg is not a string, and adds newlin
  - fmt.FPrint.. functions prints to a buffer (an object that implements the io.Writer interface)
  - Format
    -  %d format prints based on the type (uint/int)
    -  %v prints the default...what fmt.Print() will show
    - %+v prints with struct field names
    - %#v prints in full Go syntax
    -  %q quotes string or []byte
          creates a rune from integer or rune
    - %#q backquotes
    -  %x hexa
    -  %x spaced hexa
    -  %T type
  - to change the default printing define, *T is more effective to use than T for structs
      func (t *T) String() string
  - We write ...v after v in the nested call to Sprintln to tell the compiler
      to treat v as a list of arguments; otherwise it would just pass v
      as a single slice argument.
  - There is also ...T for a variadic number of arguments of type T
*** Append
  - You can't actually write a function in Go where the type T is determined by the caller.
** Initialization
- Constants
  - Defined at compile time.
  - Either: numbers, charachters, strings or booleans.
- init() function on each file, to verify or repair correctness of the program state.
    packages initialization >
** Interfaces and other types
- Interfaces
  - if something can do this, then it can be used here.
  - Interfaces with only one or two methods are common in Go code
  - A type can implement multiple interfaces.
  - For instance, a collection can be sorted by the routines in package sort if it implements
    - sort.Interface
      - Len()
      - Less(i, j int) bool
      - Swap(i, j int)
- Convertions
  - It's an idiom in Go programs to convert the type of an expression to access a different set of methods. 
** DONE Blank _ Identifier
#+begin_src go
_, err := os.Stat(path) // 1. on multiple assignment
var _ = fmt.Println // 2. To silence, unused imports
_ = fd              // 2. To silence, unsused variables
import _ "net/http/pprof" // 3. To import for his side-effects
// 4. to check at compile time that a type satisfies an interface
//    Only when there are no static conversion already present in the code (rare).
//    Global declaration.
var _ json.Marshaler = (*RawMessage)(nil)
#+end_src
** Embedding
- Interface embedding:
  - Only interfaces can be embedded within interfaces
* DONE Tutorial: Clean Go Code (Lasse Martin Jakobsen)
https://github.com/Pungyeon/clean-go-article
- AWS re:Invent 2017: Embracing Change without Breaking the World (DEV319) https://www.youtube.com/watch?v=kJq81Y7OEx4
  Golang Scopes https://idiallo.com/blog/golang-scopes
- Ensure readability, estability and maintainability of the codebase
s topic, as well as a talk:
- About choosing between a closure or an interface
  https://dave.cheney.net/2016/11/13/do-not-fear-first-class-functions
  https://www.youtube.com/watch?v=5buaPyJ0XeQ&t=9s
  https://www.youtube.com/watch?v=5IKcPMJXkKs
** Preface: Why Write Clean Code?
> "We don't read code, we decode it -- Peter Siebel"
- ...homogenous code id more important than having complete expressive *freedom*
** Introduction to Clean Code
- TDD: short dev cycles, invites to question *functionality* and *purpose*
  1. Write (or execute) a test
  2. If the test fails, make it pass
  3. Refactor your code accordingly
  4. Repeat
*** Naming conventions
  - Comments:
    - goftm, all public variables and functions should be annotated
    - "tutorial comments" are useless in production code
    - "Document ~why~, not how -- Venkat Subramaniam (Agile advocate)"
  - Functions:
    - "The more specific the function, the more general its name"
      Start with a very broad and short function name. Run() Parse()
    - IMO, Part of the OO that is loss, (sometimes) is translated into names (less than in C tho)
  - Variables:
    - Opposite to functions: should be named from more to less specific, the deeper we go into nested scopes.
    - Do NOT name your variables the same as the type
      "You shouldn't name your variables after their types for the same reason you wouldn't name your pets 'dog' or 'cat' -- Dave Cheney"
    - Do NOT mix short and long variable names inconsistently
*** Cleaning Functions
- Function length
  "How small should a function be? Smaller than that! -- Robert C. Martin"
  - Code comprehension > Code deduplication
  - Avoid *Indentation hell*
  - TIP: if the *value, err :=* pattern id repeated more than once in a function
- Function Signatures
  - IT should contain one or two input parameters. Might be three.
  - Use and "Options" struct instead
*** Variable Scope
- Global variables are problematic and don't belong in clean code
- Non-Global variables with a large scope can cause problems (too).
  - Instead of expanding the mutable scope, we can just return a new value.
  - Variable shadowing can creep when doing ~:=~ inside a block, that (re)declares the variable
  - OK DUDE
    "Developers need to take responsibility for their own code rather than blaming these issues on the variable
     declaration syntax of a particular language like Go."
*** Variable Declaration
- Declare the variables as close to their usage as possible
  - Avoid C-style declaration first
- Make constructors for channels, that make() and start the consumption
  - Alternatively
    - wrap the channel in a struct, making the channel private
    - make a newNAME()
    - make a Send()
** Clean Go
*** Return Values
- Returning defined errors
  - Do NOT rely on the *magic string* provided on errors.New() to compare
    Make it global (4Head)
- Return default values.
  Like a global empty struct of the type needed.
- Returning Dynamic Errors
  - When there context details to be returned
  - Create a new interface:
    #+begin_src go
type ErrorDetails interface {
  Error() string
  Type()  string
}

type errDetails struct {
  errtype error
  details interface{}
}
func NewErrorDetails(err error, details ...interface{}) ErrorDetails {
  return &errDetails{
    errtype: er,
    details: details,
  }
}
func (err *errDetails) Error() string {
  return fmt.Sprintf("%v: %v", err.errtype, err.details)
}
func (err *errDetails) Type() error {
  return err.errtype
}

NewErrorDetails(
  ErrItemNotFound,
  fmt.Sprintf("could not find item with id: %s", id))
.Error()
.Type()
    #+end_src
*** Nil Values
- Try to not return nil values
- Avoid access to potential unitialized values with getters
*** Pointers in Go
- Pointer mutability
- Scope/Mutability:
  - When passing pointers as an input parameter of a function,
     we are expanding the scope of the variable whose data is being pointed to.
  - Same with returning pointers, we leak scope.
  - Common Go constructores are still fine
    They keep the scope the same.
*** Closures Are Function Pointers
- We can use closure to partially overcome the lack of generics
  - Making it easier to add functionality without affecting other parts of the code.
  - Keeping the arguments of the closure small (1?) helps to decouple later
- Sometimes there is a choice between using a closure or an interface
*** Interfaces in Go
- Java or C#, intefaces are explicit
- In Go being implicit, it can be difficult to see which intefaces are implemented by a struct (aka ~contract fulfillment~)
  - Resulting in interfaces with few methods (to make it easy to identify satisfying types)
  - Or creating constructors that return an interface1, along with code to implement the interface1
  - Or we can check by asserting that the interface is fullfilled
    #+begin_src go
   var _ io.Writer = &NullWriter{}
    #+end_src
  - Or interface embedding in a struct field.
    "An interface method in Go is essentially a function pointer".
    Embedded interfaces:
    - are always public.
    - You can partially overwrite interface methods
    Some argue that interface embedding is good for mocking (implement just what you need for testing)
- Struct embedding, helps introduce new functionality quickly (clean code)
- You should be able to accept and *interface argument* but return a *specific type*
TODO: NewDocument() is missing a user argument for NewMetadata
*** The Empty interface{}
Type reflection or Type Casting
- An alternative developers use for the lack of *generics*
  - A way to accept all the types for argument
    - In print() family of functions
    - Or in .Decode() (in json package)
- In general avoid directly dealing with interface{},
  write wrappers (Get, Put) for the type you want (like when using tinyKV package)
* Book: Cloud Native Go
  Repo: https://github.com/cloudnativego/
** 9 Building Web Application with Go
   https://github.com/cloudnativego/web-application/3
   - Serve static resources, where /assets/ is the directory where the static files are
     PathPrefix("/").Handler(http.FileServer(http.Dir(webroot+"/assets/")))
   - We can add later other .HandlerFunc() for other paths
   - Cases when a AJAX based rendering might not be the best solution:
     - You want a JS variable with the username of the currently logged user
     - Or other cookie data you want to be on HTML before JS loads
   - ~text/template~ package
     t := template.Must(template.ParseFiles("./a/path/index.html"))
     t.Execute(w, data) // Where data is a instance of a user defined struct, with `json:` tags
   - ~r.Form~ is part of the http.Response
     1) run r.ParseForm()
     2) k,v range on r.Form, which is a map[string][]string
*** Cookies:
   - Never store confidential or sensitive information on them.
   - Most store a randomly generated ID
   - ~net/http~ defines the Cookie struct
     http.SetCookie(w, &cookie)
     r.Cookie("acookie")
* Book: Get Programming with Go (Manning)
Code: https://github.com/nathany/get-programming-with-go
** 5 State and behavior
*** DONE 21 A little Structure
- For things that go together (ex: latitude and longitude)
- New structs can either:
  #+begin_src go
  var curiosity struct {
    lat  float64
    long float64
  }
  // OR
  type location struct {
    lat  float64
    long float64
  }
  var curiosity location
  #+end_src
- ~Composite literals~
  location{lat: 1.3, long: 231.4}
  location{1.3, 231.4}
- Copied on :=
- ~Struct tags~ are the comments that go right of struct fields
*** DONE 22 GO's got no class
- Attaching methods to structures (types)
- Struct constructors are idiomatic
  func newLocation(lat, long coordinate) location {}
  func newLocationDMS()..
  func newLocationDD()..
- Sometimes just New(), if the package name is self descriptive
*** DONE 23 Composition
- "In OO, objects are *composed* of smaller objects in the same way."
- Behavior:
  On ~inheritence~, you create hierarchies. Which can be tricky to think about and change.
  On ~composition~, you create methods and associate them to each "class".
  Example: classifing animals by families *VS* creating attributes (walk, swim, nursing) and attach it to each animal
- State:
  ~Composition~ also takes place on structures.
   Break down a dispair structure into smaller ones. And combine them.
- Forwarding methods:
  // Naive
  type report struct {
    sol         int
    temperature temperature
    location    location
  }
  func (r report) avg() celsius {
    return r.temperature.avg()
  }
  ~Struct embedding~: makes all methods/subfields accessible from the main
                      the fields still exists
  type report struct {
    sol int
    temperature
    location
  }
  ~Name Collision~, compiler warns ONLY on ambiguous usage
*** DONE 24 Interfaces
- ~Interfaces~ A way to express an ~abstract~ concept, a *Writer*. In place of a ~concrete~ thing.
   A common behavior shared between "things".
- declaring var t with an *interface type*
  #+begin_src go
  var t interface {
      talk() string
  }
  #+end_src
  ~Polimorphysm~ The var can be (re)assigned anything, which type satisfies the interface.
- declaring a named *interface type*, usually ended with ~-er~, like fmt.Stringer
  #+begin_src go
  type talker interface {
      talk() string
  }
  #+end_src
  - They can be used anywhere a type is used.
- Interfaces work along with ~structure embedding~.
  Regular functions that take the interface, would take structure embedded ones.
     (unlike with just using methods).
- Interfaces in go are *satisfied implicitly*.
  We don't need to explicitly say that a struct would satisfy our own interface.
- ~Interface embedding~ is a thing, like with io.ReadWriter
  They save some typing, but not much else.
- Try to keep interface small
** 6 Down the gopher hole
*** DONE 26 A few pointers
- A ~Pointer~ is a variable that points to the address of another variable.
- ~Maps~ are pointers in disguise, no need to dereference on a function arg
  ~Slices~ are, in part, pointers to elements on an array.
           A pointer to a slice is only needed when modifing the cap/length/offset.
           Though, it might been better return a new slice.
- & address operator, can't take addresses of literal strings, number or booleans
- * dereference operator, also used in pointer types (like *int)
  can be assigned: *adminpoint = "new admin"
- ~Automatic dereferencing~
  - struct fields
  - array indexes
- Unlike C:
  - Arrays and pointers are different types altogether
  - GO avoids potential unsafe operations with pointers
    a *int pointer can only point to a memory position where there is a int
  - parameters are ALWAYS passed by value, pointers enable ~mutation~
- Methods who have a *pointer receiver* (mutable), can be sent from a struct or a pointer
  #+begin_src go
  func (p *person) book (){
     p.foo += 1
  }
  p1 := person{}  // struct
  p2 := &person{} // pointer
  p1.book()
  p2.book()
  #+end_src
* Book: Go in practice (Manning)
** 4.1
- errors.New
  fmt.Errorf
- Sometimes, when returning a meaningful non-nil value we can ignore the error check
- Custom error types
  - When we need to return more than a string
  - packages can export errors (errors.New) instances that can be ~err ==~
  - Custom error, to add more data to the error
     #+begin_src go
type ParseError struct {
    Message    string,
    Line, Char int
}
func (p *ParseError) Error() string {
   format := "%s on Line %d, Char %d"
   return fmt.Sprintf(format, p.Message, p.Line, p.Char)
}
  #+end_src
  - Default interface
     #+begin_src go
type error interface {
    Error() string
}
     #+end_src
- panics
  - unwind the stack
  - if unhandled unwind the whole stack
  - signature is ~panic(interface{})~
* Book: Black Hat Go (nostarch)
  https://github.com/blackhat-go/bhg/
** Chapter 5 DNS
- with "net" package you can't set the resolver or run deep inspection (? on the result
- RR interface doesn't have methods to get the response IP
- to get the IP from a RR struct we use *type assertion* to create the data
- you can "cheat " and let the *flag* package handle/get all the args even the non-optionals as optionals, by then adding a check if not provided
* Book: The Go Programming Language (Addison)
Code: https://github.com/adonovan/gopl.io/
** DONE 6 Methods
*** Method Declaration
- ~Method receiver~, is the extra parameter from a regular function definition.
- ~Selector~, is the obj.MethodName alone
- No special *self* name being used
- Methods and (struct) Fields inhabit the same namespace
- Can define methods on slices, if they are declared a type.
*** Methods with a Pointer Receiver
For methods that need to update the receiver, or the variable is too big to copy.
- CONVENTION: if a method of the type has a pointer receiver, all should use point receiver
  - If any method has ~*T~ avoid copying instances of ~T~
  - Unless the type is a pointer (slice/map)
- ~receiver parameter~ what the method declares (p Point) func ...
  ~receiver argument~  what the method receives Point{1,2}
- Method calls:
  - Same type of receiver arg and receiver param
  - Receiver arg is ~T~ and receiver param is ~*T~ (implicit &)
  - Receiver arg is ~*T~ and receiver param is ~T~ (implicit *)
- Receiver can accept nil (empty maps/slices)
*** Structure Embedding
- Embedding != Subclassing
- Language facilities:
  - Field access: I can access the fields of the embedded struct directly
  - Method access/promotion: can access methods of the embedded struct directly
  - No Inheritance: I still can't use it inplace of the embedded
- Works with pointers to a named type on the ~anonymous field~ (aka "child")
- Works with unnamed struct types too
*** Method Values and Expressions
**** Method Values
distanceP = p.Distance
Is a function that bind the method to a specific receiver.
- You can ~select~ the method, bind it, and use it later
- sometimes we can shorter code
  #+begin_src go
  time.AfterFunc(10 * time.Second, func() { r.Launch() })
  time.AfterFunc(10 * time.Second, r.Launch)
  #+end_src
**** Method Expression
distance = Point.Distance (or (*Point).Distance )
Is a function where the first argument is the receiver.
Can be useful when the value can be a choice between many others.
#+begin_src go
if add {
    op = Point.Add
} else {
    op = Point.Sub
}
...
op(p[0], offset)
#+end_src

*** Example: Bit Vector for set operations
instead of using map[T]bool
Bit-vector: uses a slice of unsigned integer,
            each bit represents a element present
- bytes.Buffer, is often used in String() methods
  buf.WriteByte()
  fmt.Fprintf(&buf,,)
- while declaring String(), for ~*T~ won't make it for ~T~
  use & accordingly
- binary operators:
  << (binary left shift), &(binary and), |= (bitwise inclusive or and assignment)
*** Encapsulation
aka getters and setters
- The unit of encapsulation is the ~package~
- We encapsulate on a struct, even if it is ONE field
** 7 Interfaces
*** 7.1 Interfaces as contracts
    Definitions: abstract type, implictly implemented
    An interface is contract, of what the type can do.
    Some cannot be expressed by the language and is detailed in the comments of the interface.
~substitutability~ of a type that satisfies the interface for another.
*** 7.2 Interface Types
    Inteface embedding
*** 7.3 Interface Satisfaction
- <TYPE> "is a" <INTERFACE>, when type satisfies the interface
- Only the methods revealed by the interface type may be called, even if the concrete type has others.
- ~empty interface~ interface{}, we can assign it anything, but we can't do nothing with it directly (see shadowing)
- I can create interfaces as I need them, some might refer to common properties (getter methods)
- *Documenting and asserting* the relationship between a type and intefaces it satisfies
  var _ io.Writer = (*bytes.Buffer)(nil)
*** 7.4 Parsing Flags with flag.Value
fmt.Sscanf - to read in put in format
- flag.Value is an interface
  #+begin_src go
  package flag
  type Value interface {
      String()    string // value to stdout
      Set(string) error  // stdin to value
  }
#+end_src
- Satisfying it, 1) wraping it on a struct
#+begin_src go
type celsiusFlag struct { Celsius }

func (f *celsiusFlag) Set(s string) error {...}

func CelciusFlag(name string, value Celsius, usage string) *Celsius {
    f := celsiusFlag{value}
    flag.CommandLine.Var(&f, name, usage) // Adds the flag
    return &f.Celsius
}
#+end_src
*** 7.5 Interface Values
The potential to *panic*
- Two components:
  - A concrete type (dynamic type)
  - A value of that type (dynamic value)
- Zero value for an interface is both nil, a ~nil interface value~
  - restored when one assigns nil to the interface variabe
- If the value is not comparable (slices, map) comparisons between interface values wil panic
- makes an impact on *nil*, when passes as an argument it will go from nil interface to:
  - The Type can be the interface one, while
  - The Value is nil
  - Which is != of a plain *nil*
*** 7.6 Sorting with sort.Interface
tabwriter.Write
#+begin_src go
package sort // provides inplace sorting
type Interface interface {
    Len() int
    Less(i, j int) bool // i,j are indices
    Swap(i, j int)
}
#+end_src
- Satisfied by providing ALL the methods for the type to satisfy
  #+begin_src go
  type StringSlice []string
  fun (p StringSlice) Len() { return len(p) }
  #+end_src
- A sort of a slice of pointers to struct runs faster (faster swap)
  than a slice of structs.
- To sort for each field of the struct,
  I need to create separate types that satisfy the interface
- sort.Reverse
  it uses a non-exported type (reverse) that embeds sort.Interface and
        changes the Less() by swapping the arguments
- sort.Sort(sort.Reverse(byArtist(tracks)))
- Custom sorts
  - wrapping the tracks and a function to sort on a struct
    then instantiation on the sort, where we define it with a *lambda*
    #+begin_src go
   sort.Sort(customSort{tracks, func(x, y *Track) book {
       if x.Title != y.Title {
         return x.Title < y.Title
       }
       if x.Year != y.Year {
         return x.Year < y.Year
       }
       if x.Length != y.Length {
         return x.Length < y.Length
       }
       return false
   }})
    #+end_src
*** 7.7 The http.Handler Interface
#+begin_src go
package http

type Handler interface {
  ServeHTTP(w ResponseWriter, r *Request)
}

func ListenAndServe(addres string, h Handler) error
#+end_src
- To satisfy we create a type, which can or can't hold data
  - We can switch on req.URL.Path on the ServeHTTP() method
- ServMux(), a Server Multiplexer, collects several http.handler(s) into one http.handler
  * Either, we register the handlers, ~mux.Handle()~ passing the url path AND the method to handle the path
    - Wrapped in http.HandlerFunc() which is a type conversion, of a type which is a function that satisfies http.Handler
      aka an *adapter*
      - A function type that has methods and satisfies an interface (!!!!)
      #+begin_src go
      package http
      type HandlerFunc func(w ResposeWriter, r *Request)
      func (f HandlerFunc) ServeHTTP(w ResponseWriter, r *Request) {
         f(w,r)
      }
      #+end_src
  * Or briefly, ~mux.HandleFunc(PATH, METHOD)~
  * Or more briefly, use the DefaultServerMux
- Each handle in a new goroutine
*** 7.8 The error Interface
- fmt.Errorf() calls errors.New()
  - given every time it creates a new one, there no 2 errors ==
#+begin_src go
type error interface {
  Error() string
}
#+end_src
- syscall.Errno(2) creates a error of type syscall.Errno which satisfies Error()
*** TODO 7.9 Example: Expression Evaluator
*** 7.15 A few Words of Advice
- "Interfaces are *only* needed when there are two or more
   concrete types that must be dealt with ina uniform way."
- Exception being when the interface and the (single only) type can't be on the same package.
- ~ask only for what you need~, rule of thumb for interface design
* Book: Network Programming with Go (nostarch)
** Introduction
- Writing network software using Go's *Asynchronous* features
- Emphasis on security
- TCP, UDP, Unix Socket
  Application-level protocols (http, http/2, TLS)
  Fob, JSON, protocol buffers, gRPC
** 1 An Overview of Networked Systems
*** Choosing a Network Topology
- Organization of nodes in a network
  * point-to-point: o-o
  * daisy chain:    o-o-o-o, a series of point-to-point with "hops" between 2 separated nodes
  * bus: common network link, common on wireless, everyone sees everything
  * ring: was used on some fiber-optic deployments, single direction
  * star: there is a central node, individual point-to-point connections
  * mesh: every node is fully connected to every other node
- Hybrid topologies are more common: star-ring, star-bus
*** Bandwidth vs. Latency
- CDN, Caching
- Go's concurrency to minimize server-side blocking of the response.
*** OSI: The Open Systems Interconnection Reference Model
Software application
7) Application (http)
6) Presentation (encryption, decoding)
5) Session (connection life cycle?)
4) Transport (tcp, udp)
3) Network (ip)
2) Data Link/Logical link control/Media Access control (mac) (error correction, common in wireless)
1) Physical (bit to electric/optical signal)
Physical transmission media
**** Payloads
Payload=Message Body=SDU=Service Data Unit
Layer4: TCP Payloads=Segments=Datagrams
Layer3: IP Payloads=Packet
Layer2: Frame (containing MAC and FCS, frame check sequence)
*** The TCP/IP Model
Software Application
- Application (7,6,5) (http,ftp,smtp,dhcp,dns)
- Transport (4)
- Internet/Network (3) (ip,bgp,icmp,igmp,ipsec)
- Link (2,1) (arp)
Physical Transmission Media

SLIP or PPP, were part of serial connections to the ISP.
No link layer protocol.
** 8 Writting HTTP Clients
URL = Uniform Resourse Locator
scheme://authority/path?query=abc&d=1#fragment
- Methods
  POST: for new data
  PUT: for updates
  PATCH: partial changes
  CONNECT: to request an *HTTP tunneling*
  TRACE: to echo what you send (test tampering?) (bad for XST)
- Response codes:h
  3XX-It needs further action from the client
  4XX-Error with the request
  5XX-Server side error
  304 Not Modified, works with the ETag header
  404 Not Found, sometimes as a ~glomar response~, not confirming or dening the resource exists or not
  426 Upgrade Required, when it needs to update to TLS before accessing the resource
- Versions:
  HTTP/1.0: requires separate TCP connections for different requests
  HTTP/1.1: ~keepalive~ allows different request in the same TCP connection
  HTTP/2  : allows server to push resources to the client.
- Go automatically consumes the Response headers, but leaves the body unread
  until is consumed or the connection closed.
- To reuse the connection you need to consume the body, which also happens when you .close() the body
- Default HTTP client has no timeout.
  context.WithTimeout()
  context.WithCancel() - and usin a timer time.AfterFunc()
- Disable reuse:
  req.Close = true
- Server must explicitly drain the request body before closing it.
- MIME: Multipupose Internet Mail Extension
  "mime/multipart" package
  Allows to send "field data" (key-values) or "form field"
  Sets a boundary for the date and sent on header Content-Type:
** 9 Building HTTP Services
- Client
  - We should get used to close the body
  #+begin_src go
  _ = resp.Body.Close()
  #+end_src
- In Go, a webservice relies on:
  - Handlers
  - Middleware: changes the handlers behavior or perform aux tasks (logging, authentication or access control)
  - Multiplexer
- Bare bones server implementation creates srv as a http.Server{} struct and then does:
  - net.Listen()
  - srv.Serve(listener)
  - srv.Close() - abruptly closes the server
*** http.Server{} timeouts
  - IdleTimeout: timout of how long keep the connection open (keepalive)
  - ReadHeaderTimeout: timout reading request headers (not body)
  - ReadTimeout: time the client has to send both header and body (ReadDeadLine of tcp socket)
  - WriteTimeout: time it has the client to read the server reply (WriteDeadLine of tcp socket)
*** TLS
    .Serve(l)
    .ServeTLS(l,CERT,KEY)
*** Handlers
  http.HandlerFunc(
     func(w http.ResponseWrite, r *http.Request) {...})
  - Usually we ignore any potential (response) write error
    - We can keep track however of the frequency they occur.
  - Drain and close the request body. http.Server{} only close it by default. So closing here is optional.
    #+begin_src go
    // Inside a Handler
    defer func(r io.ReadCloser) {
        _, _ = io.Copy(ioutil.Discard, r)
        _    = r.Close()
    }(r.Body)
    #+end_src
  - Use ~html/template~ package to escape HTML code, especially when part of the data comes from client.
  - To inject additional resources (than the request and response), like a database connection.
    - Use a *closure*:
    #+begin_src go
    dbHandler = func(db *sql.Db) http.Handler {
        return http.HandlerFunc(
            func(w http.Response, r *http.Request) {
                err := db.Ping()
            }
        )
    }
    #+end_src
    - Or add a field to the struct/type that satisfies the http.Handler interface
*** Testing with *net/http/httptest* package
  - httptest.NewRequest() will panic instead of throwing an error
    - unlike http.NewRequest
  - httptest.NewRecorder() returns a pointer to httptest.ResponseRecorder
     - use the .Result() method to return a pointer to http.Response
  - Pass the request/recorder to the Handler
  - Go assumes a 200 response if you write the body, before explicitly sending a header.
    - use http.Error(w, BODY, ERRORCODE)
*** Middleware
    - func(http.Handler) http.Handler
    - To inspect/act on the request.
      To add headers to the response
      Collect metrics
      Control access
    - If you find yourself writing the same handler, might be you can rewrite it as a middleware
    - This works by closuring the next handler
    - is NOT recommended performing many tasks on a single middleware
    - http.TimeoutHandler, middleware that sets an internal timer for the given duration. Returns 503 if timeout.
*** Multiplexers
    - The http.ServeMux multiplexer is a http.Handler that routes the incoming request into the proper Handler
    - You can drain and close the connection directly to the mux
      There is no harm in drain a close a previously drain and closed request
    - Subtree (/a/path/) vs absolute path (/another/path)
      Go will try to match the absolute path, if not matches, will add a / and try to match and 301 to it
* Book: Distributed Services with Go (Pragmatic Bookshelf) Travis Jefferey
Source: https://pragprog.com/titles/tjgo/distributed-services-with-go/
Source: https://github.com/travisjeffery/proglog
- Author: Works at Confluence (kafka)
  https://twitter.com/travisjeffery
  https://travisjeffery.com/
  https://github.com/travisjeffery/jocko/
- Book uses code from Hashicorp's *Serf* and *Raft* packages
  Studied from Consul source code.
- "Designing data intense applications" by Martin Kleppman
  Covers data structures and algorithms for distributed services, abstractly.
** Chapter 1: Let's Go
- On C, author was bugged by the lack of modules
- Author's project *Jocko*, and implementation of Kafka in Go
- JSON over HTTP, most common APIs on the web.
  - For internal web APIs, might use *protobuf/gRPC* for features not provided by it.
    Like type checking and versioning. (performance?)
- $ go mod init github.com/travisjeffery/proglog
  $ ls
  go.mod
- ~internal/server/log.go~ (package server)
  With the append log datastructure and basic .Append() .Read() methods
- Each JSON/HTTP handler should
  1. *Unmarshall* the JSON request into a struct
  2. *Run* the endpoint logic with the request
  3. *Marshal* and write that result to the response
  If handlers become much more complicated, move code out
- ~internal/server/http.go~ (package server)
  - Uses https://github.com/gorilla/mux
    Like http.ServMux, mux.Router implements http.Handler but provides easier ways to match different things on the URI
  - The producer and consumer handler code
- ~cmd/server/main.go~ (package main)
   - just .NewHTTPserver() and .ListenAndServe()
- encoding/json package encodes []byte as a base64 string
** Chapter 2: Structure with Protocol Buffers
- For internal APIs (with control of the clients)
  * Guarentees type-safety
  * Prevents schema-violations (across several microservices/teams)
  * Enables fast serialization (six times faster than JSON)
  * Offers backward compatibility
  * Language agnosticism
- From a .proto file you generate/compile to .go code
  #+begin_src
  syntax = "proto3"
  package twitter;
  message Tweet {
    string message = 1
  }
  #+end_src
- *protoc* is the compiler binary name
- Go convention is to put the .proto files on the *api/v1* directory
  - Using the *repeated* protobuf keyword to describe the slice of Records
  - You assign an "unique field number" to each field of the Message
- History: gogoprobuf was a fork of googles runtime to run protobuf, later replaced with Go API (APIv2)
- $ go get google.golang.org/protobuf/...@v1.25.0
  $ protoc api/v1/*.proto --go_out=. --go_opt=source_relative --proto_path=.
- Use a ~Makefile~
- You will end up creating *interfaces*, to handle the *getters* you get from the autogenerated code
  Or you will end up writting plugins for the protobuf generator (like to generate setters?)
** Chapter 3: Write a Log Package
- Other names:
  * write-ahead logs
  * transaction logs
  * commit logs
- Examples: ext journal, postgres WAL, raft append logs, Redux logs (?
- "Logs not only holds the latest state, but all states that have existed."
- Some implemetations split logs into *segments*, 1 active one.
  The index part of the logs can be *memory-map*
- Name convention:
  * Record: the data stored in our log.
  * Store: the file we store records in.
  * Index: the file we store index entries in.
  * Segment: the abstraction that ties a *store* and an *index* together.
  * Log: the abstraction that ties all the *segments* together.
*** internal/log/store.go
  - creates the filestorage abstraction struct
  - .Append()
    We write to the buffered writer instead of directly to the file
    to reduce the number of system calls and improve performance.
  - .Read()
    Call to .Flush() to clear the write buffer
    make() buffers to read from, in the memory stack
    We read directly from disk with s.File.ReadAt()
    We enc.Uint64 to get it from a read []byte
  - .ReadAt(), wrapper over .File.ReadAt() that calls buf.Flush()
  - .Close(),  wrapper over .File.Close() that cals to buf.Flush()
  - ~internal/log/store_test.go~
    Uses https://github.com/stretchr/testify for require.NoError() require.Equal()
    ioutil.TempFile(os.TempDir(), "some_extra_stuff")
*** internal/log/index.go
  Uses https://github.com/tysonmote/gommap to use the gommap.MMap
  - Once memory mapped we can't resize it, so we grow/os.Truncate() the file before mapping it.
  - .Close() syncs the mmap and file, and truncates back the file
  - NewIndex() reads and maps the index file, growing it before hand
  - .Read(in) (out, pos, error), *enc.Uint32(src)*
  - .Write(off, pos) *appends* off and pos to the index, *enc.PutUint32(dst,src)*
  - ~internal/log/index_test.go~
*** internal/log/config.go
  - Place for the Config struct
*** internal/log/segment.go
  Integrates both the *store* and *log* part
  newSegment()
  .Append(record *api.Record) protobuf marshalled the entry into the store
  .Read(uint64) (*api.Record, error) argument is used to lookup into the index which returns a position on the .store.Read()
  .IsMaxed() bool
  .Remove(), calls .Close() AND removes the assoc index and store from disk
  .Close(), closes both index and store
  .nearestMultiple(uint64, uint64) uint64
  - ~internal/log/segment_test.go~
    ioutil.Tempdir()
    os.RemoveAll()
*** internal/log/log.go
- Has a sync.RWMutex
- Manages the list of segments.
- Has an active segment, and a slice of segments
- NewLog()
- .setup(), reads all files names and gets the base offsets from it.
          , it creates the segments from them.
- .Append(*api.Record) (uint64, error), appends to the current segment, check if maxed to create a new segment
- .Read(offset uint64) (*api.Record, error), finds the segment where the offset falls in, s.Read(offset)
- .Close() error, closes every segment
- .Remove() error, .Close() and nukes it all os.RemoveAll(l.Dir)
- .Reset() error, .Reset() and .setup()
- .LowestOffset() (uint64, error), baseOffset from the [0] segment
  .HighestOffset() (uint64, error), nextOffset from the last segment
- .Truncate(lowest uint64) error, drops segments that are higher nextOffset than lowest
- .Reader() io.Reader, retuns a io.MultiReader, from each segment store, wrapped on a struct to make sure we read all the file using .ReadAt()
  - io.MultiReader is a concatenation of all input readers. After which it returns EOF.
- .newSegment(uint64) error, calls newSegment(), appends to the list, and makes it the active one
- ~internal/log/log_test.go~
  - uses t.Run(), ran under a loop of map[string]fn(*testing.T,*Log)
** Chapter 4: Serve Requests with gRPC
"A high performance, open source universal RPC framework"
https://www.grpc.io/
https://github.com/grpc-ecosystem
https://github.com/grpc-ecosystem/go-grpc-middleware
- "The best tool for serving request across distributed services."
  - Maintains these for both client and servers, for free
    - Compatibility
    - Performance
- Requests/Responses/Models/Serialization is type checked
- ~internal/~ packages are magical packages in Go that can only be imported by nearby code.
   code in /a/b/c/internal/d/e/f can be imported from /a/b/c, but not from /a/b/g
*** Goals when building a service
  - Simplicity: Abstract no-business logic away, while still having control. Express>gRPC>Rails
  - Maintainability: for backwards compatibility, the easiest is to *version* and *run* multiple instances of your API.
  - Security
  - Ease of use: type system will tell users when they do something wrong.
  - Performance
  - Scalability: Load balancing is possible.
    - thich client-side lb
    - proxy lb
    - look-aside lb
    - service mesh
*** Defining a gRPC service: is essentially a group of related RPC *endpoints*
  - Adding this on the previous ~.proto~ file
    #+begin_src
  service Log {
    rpc Consume(ConsumeRequest)              returns (ConsumeResponse) {}
    rpc Produce(ProduceRequest)              returns (ProduceResponse) {}
    rpc ConsumeStream(ConsumeRequest)        returns (stream ConsumeResponse) {}
    rpc ProduceStream(stream ProduceRequest) returns (stream ProduceResponse) {}
  }
  message ProduceRequest {
    Record record = 1;
  }
  message ProduceResponse {
    uint64 offset = 1;
  }
  message ConsumeRequest {
    uint64 offset = 1;
  }
  message ConsumeResponse {
    Record record = 2;
  }
  #+end_src
  - Compile
    $ go get google.golang.org/grpc@v1.32.0
    $ go get google.golang.org/grpc/cmd/protoc-gen-go-grpc@v1.0.0
    $ protoc api/v1/*.proto --go_out=. --go-grpc_out=. --go_opt=paths=source_relative --go-grpc_opt=paths=source_relative --proto_path=.
*** internal/server/server.go
- We need a struct whose methods match the service definition in your .proto
#+begin_src go
package server
import (
    "context"
    api "github.com/travisjeffery/proglog/api/v1"
    "google.golang.org/grpc"
)
type Config struct {
    CommitLog CommitLog
}
var _ api.LogServer = (*grpcServer)(nil)
type grpcServer struct {
    api.UnimplementedLogServer
    *Configp
}
func newgrpcServer(config *Config) (srv *grpcServer, err error) {
    srv = &grpcServer{
        Config: config,
    }
    return srv, nil
}
#+end_src
#+begin_src go
func (s *grpcServer) Produce(ctx context.Context, req *api.ProduceRequest) (*api.ProduceResponse, error) {
    offset, err := s.CommitLog.Append(req.Record)
    if err != nil {
        return nl, err
    }
    return &api.ProduceResponse{Offset: offset}, nil
}
func (s *grpcServer) Consume(ctx context.Context, req *api.ConsumeRequest) (*api.ConsumeResponse, error) {
    record, err := s.CommitLog.Read(req.Offset)
    if err != nil {
        return nil, err
    }
    return &api.ConsumeResponse{Response: record}, nil
}
#+end_src
#+begin_src go
func (s *grpcServer) ProduceStream(stream api.Log_ProduceStreamServer) error {
    for {
        req, err := stream.Recv()
        if err != nil {
            return err
        }
        res, err := s.Produce(stream.Context(), req)
        if err != nil {
            return err
        }
        if err = stream.Send(res); err != nil {
            return err
        }
    }
}
func (s *grpcServer) ConsumeStream(req *api.ConsumeRequest, stream api.Log_ConsumeStreamServer) error {
    for {
        select {
           case <-stream.Context().Done():
               return nil
           default:
               res, err := s.Consume(stream.Context(), req)
               switch err.(type) {
                   case nil:
                   case api.ErrOfsetOutOfRange:
                        continue
                   default:
                        return err
               }
        }
    }
}
#+end_src
* Book: Go Programming Blueprints
** 6 - Exposing data and functionality through a RESTful data web service API
*** Context
   - *context* To share data between different handlers/middleware in a request
   - every http.Request comes with a context.Context, accesible through .Context()
   - Simple usage
   #+begin_src go
   ctx := context.WithValue(r.Context(), "key", "value")
   Handler.ServeHTTP(w, r.WithContext(ctx))
   #+end_src
   - Using private types for the key
     #+begin_src go
     type contextKey struct {
       name string
     }
     var contextKeyAPIKey = &contextKey{"api-key"}
     func APIKey(ctx context.Context) (string, bool) {
       key, ok := ctx.Value(contextKeyAPIKey).(string)
       return key, ok
     }
     #+end_src
*** Tags
    - Since we can put multiple structure tags, we can have different *views* over the same *model* (the struct)
      Example: json and bson (for mongo)
** 8 - Filesystem Backup
- With interfaces, we can export an *instance* of the type, without exporting the *type* itself
   #+begin_src go
package backup

type Archiver interface {
  Archive(src, dest string) error
}
type zipper struct{}
var ZIP Archiver = (*zipper)(nil)// We export ZIP, which satisfies Archiver
 #+end_src
- Writing a string into a Writer:
  - io.WriteString()
  - fmt.Fprintf()
- Passing around errors, can help on *error recovery* OR passing the problem to something else.
- To associate *data* to each interface (ex: extension name string) we can add a func to the interface,
  that returns said data, and each implementation will have to define it.
- log.Fatal(), same as print to sterr and os.exit(1)
- we can use a *defer* on main, to return an error if the program failed
  #+begin_src go
func main() {
  var fatalErr error
  defer func() {
    if fatalErr != nil {
      flag.PrintDefaults()
      log.Fatalln(fatalErr)
    }
  }()
  // ...
}
  #+end_src
* DONE Article: I want off Mr. Golang's Wild Ride
Source: https://fasterthanli.me/articles/i-want-off-mr-golangs-wild-ride
- Lack of generics, makes problems impossible to model accurately,
  falling back into ~reflection~
- Default error handling is *wonky* (even with 3rd party that adds context or stacktraces)
- DWARF: debugging information on shared libraries
- "When you make something simple, you move complexity elsewhere"
- GO and NodeJS handling of cross platform permissions is made up (on windows)
  https://nodejs.org/api/fs.html#fs_class_fs_stats
  - A call to Chmod() on windows just flips the windows readonly flag
  - "A language with a more involved type system, and better designed libraries
     could avoid that pitfall"
- In Rust we get a ~Result<>~, so we don't get some invalid/unitialized/null
  In Go is up to us to test the value of *err* returned by the function
- In Rust we have a type Path, that can have non utf-8 contents
  In Go we have strings, which are byte slices
  - We might silenty fail to read some files, since some characters might be non-printable
- In Rust having ~Option<>~ allow us to differentiate
  Path separator on Go, can't distinguish between not having a path separator and having it
- "We can look at *what* we're manipulating just by looking at its type"
- Types don't cost anything at runtime, everything ends up inlined anyway.
- In rust permissions are not unix based, so they are more crossplatform (1 bit readonly)
  - Unix type permissions are available on PermissionsExt
- In go there are build constraints in comments
  // +build: !windows
- "The Go way is to half-ass things"
- "The Go way is to patch things up until they sorta kinda work, in the name of simplicity."
** Lots of little things
- net/http, timeouts:
  - request timeout VS whole connection timeouts
  - Both don't account if the request has been accepted but no data has been send.
    Might be important on POST request.
  - https://github.com/getlantern/idletiming solves above
  - left-pad incident https://qz.com/646467/how-one-programmer-broke-the-internet-by-deleting-a-tiny-piece-of-code/
  - golang monotonic clock breaking change, time.Now returns 2 different values if called twice?
    https://github.com/golang/go/issues/12914
** Parting words
"It constantly takes *power* away from its users, reserving it for itself."
"It constantly lies about how complicated real-world systems are, and optimize for the *90%* case, ignoring correctness."
"Everything looks simple on the surface, but nothing is."
* DONE Article: Shrink your Go binaries with this one weird trick
https://blog.filippo.io/shrink-your-go-binaries-with-this-one-weird-trick/
- binwalk: can plot the entropy of a file to know how well it can compress
  -E https://github.com/ReFirmLabs/binwalk/wiki/Usage#-e---entropy
- executable packer
  https://upx.github.io/
  $ upx --brute FILENAME
- removes the DWARF tables, nothe the annotations for stacktraces
  $ GOOS=linux go build -ldflags="-s -w"
* DONE Article: Go is not an easy language
https://www.arp242.net/go-easy.html
Simple syntax.
Simple semantics.
Doint useful stull is not always easy.
Arg1: Some basic slice operations are complex. And some might be unintuite more costly.
      Slice Tricks: https://github.com/golang/go/wiki/SliceTricks
Arg2: While primitives are there, the patterns that put them together are up to us.
* DONE Article: Channel Axioms (Dave Cheney)
- A send      to a nil channel blocks forever
- A receive from a nil channel blocks forever
- A send      to a closed channel panics
- A receive from a closed channel returns the zero value immediatly
* DONE Article: Why Discord is switching from Go to Rust (Jesse Howarth?)
- Uses: client video encoding, Elixir NIFs
- Go Service to be rewritten:
  - Every few minutes large latency/cpu spikes, due
    1) it's memory model: memory is not freed immediatly
    2) garbage collector: needs to scan the whole memory
  - Go will force a garbage collection run every 2 minutes at minimum
    https://github.com/golang/go/blob/895b7c85addfffe19b66d8ca71c31799d6e55990/src/runtime/proc.go#L4481-L4486
  - Service did not borrow or free big ammounts of memory
  - Data Structure: one instance per channel, per user
    - LRU cache, millons of users in each cache
      - Cassandra cluster backed
- Memory managment in Rust: no gc, ownership means it will free it when no needed
- Async Rust: at the time (<2020) async was only available on nightly
- Implementation: it was a deep dive write performant (to their scale) code in Go
  - Changing ot a BTreeMap instead of a HashMap
  - Swapping to a metrics library that used concurrency
* DONE Article: Go is Google's language, not ours (2019)
- Claim: A community made package manager was dropped in favor of one made by the core team.
  - https://peter.bourgon.org/blog/2018/07/27/a-response-about-dep-and-vgo.html
    https://research.swtch.com/vgo
* DONE Article: Ten Reasons Why I Don't Like Golang
1) Using letter capitalization for private and public visibility.
   Problem: Compiler can't identify class from variable name.
            Constants are lowercase.
   #+begin_src go
   type user struct {
   }
   func main(){
     var user *user
     user = &user{} // panic!
   }
   #+end_src
2) Structs implicity implement interfaces.
   Problem: No guarantee that the "contract" (detailed on the comments of the interface)
            is fullfilled.
3) Uses multiple values to return errors.
   Problem: easy to forget, nothing on the idiom enforces that the returned values are valid.
4) Convention over configuration
   Examples: somefile_linux.go, init()
5) Easy to end up with several identically-named identifiers.
6) Is difficult to autogenerate code (?)
7) No Ternary Operator.
8) Clumsy sort.Interface
   Problem: boilerplate code increase with each new types you want to compare with little to no re-usability.
            Casting also looks like a function call.
9) No version or vendoring support (circa 2016)
10) No generics.
    Problem: 3rd party libraries (ab)use of interface{}
11) append() "might" do an implace replacement, or not
    Problem: compiler used to not warn for not assigning the append()
* DONE Article: Down the Golang nil Rabbit Hole (2021)
Scenario: doing integration test with https://github.com/houseabsolute/detest
- Go has multiple "types" of nil. Both typed and untyped nil variables.
- reflect.ValueOf(nil) returns an invalid nil (untyped nil?)
         .IsValid()
         .IsNil()
         .Type()
- Sometimes, Go types the untyped nil, if it goes through a function argument typed.
- Sometimes, it won't type the untyped nil. If it goes through a function argument interface.
- Other Languages
  + *strict* in Perl
  + *Option<T>* in Rust
* DONE Article: Golang: Don't be afraid of Makefiles (2017)
https://sohlich.github.io/post/go_makefile/
- Go commands: build, clean, test, get
- Makefile commands:
  - deps, to go get the deps (or use the -u flag???)
  - clean, to go clean and rm -f the build
  - crossbuild with flags: CGO_ENABLED=0 GOOS=linux GOARCH=amd64
  - dockerbuild: when C libraries interaction is needed for building or a particular go version, "docker run", with volume and worker dir setup accordingly
- From the HN comments
  - use ~:=~ to immediatly expand the variable
  - use ~;~ to avoid tabs and oneline the command
* DONE Article: How to Write Go Code
https://golang.org/doc/code
>=1.13
- Package = Directory
  Module  = Collection of related Packages
  Repository = 1 Module (usually)
- Creating a new program
  #+begin_src shell
  $ mkdir hello
  $ cd hello
    $ go mod init example.com/user/hello
  $ cat go.mod
  module example.com/user/hello
  go 1.16
    $ go install example.com/user/hello
      go install .
      go install
    $ go init
  #+end_src
- Adding a new package within the module/repo, does NOT involve *go mod* or *go.mod*
- For new external packages required by your code
  $ go mod tidy # adds missing module requirements (require statements with his version)
- Clean all downloades modules
  $ go clean -modcache

