- Hickey Talks
  https://www.youtube.com/playlist?list=PLZdCLR02grLrEwKaZv-5QbUzK0zGKOOcr
  https://github.com/tallesl/Rich-Hickey-fanclub
- Podcast - https://clojuredesign.club/
- Podcast - Clojurescript - https://open.spotify.com/show/3lnWCN0PAAywiN7gaxNzKZ
- Clojure Study Group - https://www.youtube.com/playlist?list=PLpr9V-R8ZxiDjyU7cQYWOEFBDR1t7t0wv
- ClojuRU 2019 - https://www.youtube.com/playlist?list=PLvf-wiCQYkAVvrZr53Upxti9Hr3t7V4bW
- Fulcro â€“ Part 1: Getting Started https://www.youtube.com/watch?v=wEjNWUMCX78

* Channels
|-------------------+----------------------------------------------------------------|
| andrey fadeev     | https://www.youtube.com/@andrey.fadeev                         |
| on the code again | https://www.youtube.com/channel/UCKlYSDBb1KBcZyCRbniW1ig       |
| calva tv          | https://www.youtube.com/@CalvaTV/videos                        |
| juxt              | https://www.youtube.com/@juxt4112/videos                       |
| re:clojure        | https://www.youtube.com/c/reclojure/videos                     |
| Sci Cloj          | https://www.youtube.com/c/SciCloj/videos                       |
| London Clojurians | https://www.youtube.com/channel/UC-pYfofTyvVDMwM4ttfFGqw       |
| Clojure/north     | https://www.youtube.com/@clojurenorth4011                      |
| ClojureTV         | https://www.youtube.com/@ClojureTV                             |
| practically       | https://www.youtube.com/@Practicalli                           |
| clojure days      | https://www.youtube.com/@clojuredays                           |
| LA Clojure Users  | https://www.youtube.com/@losangelesclojureusersgrou5432/videos |
|-------------------+----------------------------------------------------------------|
* TODO 12 | Rich Hickey | Clojure for Lisp Programmers
** 1
https://www.youtube.com/watch?v=cPNkH-7PRTk
- JVM
  - Typesystems in the VMS are very dynamic, enforced or created.
    Though the languages are usually not.
  - GC is platform, not language facility.
- Functional
  - Most "real programs" that people would pay for.
    Are NOT functions.
  - A compiler is a big function.
    Theorem provers are a function.
- OO
  - Common Lisp proved that methods outside a class are more flexible
  - Polymorphism shouldn't be (only) based on types (me: interfaces?)
- Clojure
  - dynamically compiled to JVM bytecode
  - case sensitive
  - symbols they are NOT places with values in them
  - #"a*b" <-- regex literal
  - in CL vectors and hashtables are "destructive", you change something and you trash it, you cant go back, unlike alists
  - in Clojure vectors and hashtable are NOT "destructive"
- Standard Lisps define too many fundamental things in terms of concrete types
  - Limits generability
  - Limits extensibility
  - Generic functions are the abstraction in CL, but weren't used a lot in the STDLIB
* 13 | Rich Hickey | clojure.async

- Problems to solve
  1) Function chains (are units of logics that) make poor machines.
     - Objects are little machines not very good to making logic
  2) Real-world concurrency is exposed via api's

- Premise
  - "Good programs should be made of *processes* and *queues*."
  - There comes a time in all good programs when components or subsystems MUST STOP COMMUNICATING DIRECTLY with one another.

- Why?
  - java.util.concurrent.queue
    - The only way to coordinate is via thread control, _aka blocking_
    - A problem is the thread overhead of the stack size
  - Javascript
    - No threads (and no queues) in JS
  - Observables/Rx only mitigate certain cases

- Currently solved with *Events/Callbacks*
  - callback handlers
  - async apis
  - rpc
  - Problem: fragmented logic (callback hell)

** Copying C# Async

#+begin_src clojure
  (let [fut (future ...)]
    (do-something...)
    (let [result (deref fut)] ; blocks
      (do-something result))
#+end_src

#+begin_src clojure
  (let [fut (future ...)]
    (do-something....)
    (on-complete ; callback handler
     fut
     (fn [result] (do-something result))))
#+end_src

#+CAPTION: converts the code into state machine with a callback
#+begin_src clojure
  (async ; special construct
   (let [fut (future ...)]
     (do-something...)
     (let [result (await fut)] ; relinquishes thread
       (do-something result)))
#+end_src

** History: CSP

- Communicating Sequential Process
- Hoare 1978
- First class channels
  - only way to interact between processes
  - no shared stated
  - blocking semantics by default
- Current (2013) implementations were tied to real threads

** core.async

- a library
- coordinating between processes between channels
  - process = independent threads of activity (not necesarilly real threads)

- (thread body..) - real thread, real blocking
- (go body...) - IOC thread, state-machine, 'parking'

** Channel

- a queue-like
- multi-write, multi-reader
- blocking
- unbuffered, fixed buffers, sliding, dropping
- goal: do not put logic in handlers
  - keep logic together

#+begin_src clojure
  (timeout ms)  ; autoclosing channel
  (chan)        ; unbuffered
  (chan n)      ; buffered n
  (chan buffer)
  (>! ch val)   ; put/parking
  (>!! ch val)  ; put/parking blocking (not in JS)
  (<!  ch)      ; take
  (<!! ch)      ; take blocking
  (close ch)
  (alts! ops)   ; "choice", wait on multiple things
  (alt!         ; alts! + cond
    [c t]       ([val ch] (foo ch val))
    x           ([v] v)
    [[out val]] :wrote
    :default    42)
  (put! ch val) ; async - need NOT to be in (go)
  (take! ch cb) ; async - need NOT to be in (go)
#+end_src
