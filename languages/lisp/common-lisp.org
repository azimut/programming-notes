- https://www.csee.umbc.edu/courses/331/resources/lisp/LISP-tutorial.html
- Article: Conditions and Restarts in Common Lisp https://z0ltan.wordpress.com/2016/08/06/conditions-and-restarts-in-common-lisp/
- Article: https://vindarel.github.io/cl-torrents/tutorial.html
- https://lisp-journey.gitlab.io/gray-streams/
- http://www.softwarepreservation.org/projects/LISP/common_lisp_family
- Quicklisp Snapshot http://blog.quicklisp.org/2011/08/going-back-in-dist-time.html
- https://unthought.net/2016/12/22-lisp-memory-woes-but-not/
- Firefox Add-on PCL https://github.com/vale981/practical-cl-beautified
- Package-local nicknames in Common Lisp
  https://gist.github.com/phoe/2b63f33a2a4727a437403eceb7a6b4a3
- History http://www.nhplace.com/kent/Papers/cl-untold-story.html
- Some abbreviature macros https://github.com/cl21/cl21/blob/c36644f3b6ea4975174c8ce72de43a4524dd0696/src/stdlib/abbr.lisp
- Blog: http://funcall.blogspot.com/
- Video: 2008 Raytracer in lisp
  https://www.youtube.com/watch?v=N1oMRw04W3E
  https://github.com/afwlehmann/clrt-tutorial
  https://web.archive.org/web/20130107155225/http://rudairandamacha.blogspot.de/2012/09/writing-simple-raytracer-in-common-lisp.html
- http://www.paulgraham.com/rootsoflisp.html
  http://www.paulgraham.com/diff.html
  http://paulgraham.com/avg.html
- https://github.com/hyotang666/common-lisp-pitfalls
- ASDF
  per file/package/system
   https://gitlab.common-lisp.net/asdf/asdf/blob/master/doc/best_practices.md#package_inferred
  https://common-lisp.net/project/asdf/asdf/The-package_002dinferred_002dsystem-extension.html#The-package_002dinferred_002dsystem-extension
- sectorLISP https://www.youtube.com/watch?v=xD14SLU2u2k
- https://mumble.net/~campbell/scheme/style.txt
- https://github.com/hanshuebner/bknr-datastore
- music composition
  https://quod.lib.umich.edu/s/spobooks/bbv9810.0001.001?rgn=main;view=fulltext
- https://bernsteinbear.com/blog/compiling-a-lisp-0/
- CLI arguments
  https://stackoverflow.com/questions/1021778/getting-command-line-arguments-in-common-lisp
- Video: Escape from the Heap Low Level Programming
  https://www.youtube.com/watch?v=njfyWgqZmkI
- Android APK Compiler? https://github.com/3b/3b-dex
- https://www.ic.unicamp.br/~meidanis/courses/mc336/problemas-lisp/L-99_Ninety-Nine_Lisp_Problems.html
- https://franz.com/support/documentation/current/doc/mop/concepts.html
- https://mov.im/?blog/phoe%40movim.eu&page=2
- https://mov.im/?blog/phoe%40movim.eu/a9391f4b-485e-4f3a-ae02-051a5fc65ed1
- https://stevelosh.com/blog/2016/08/lisp-jam-postmortem/
- http://wcp.sdf-eu.org/software/index.html
- ALL SYMBOLS http://clhs.lisp.se/Front/X_AllSym.htm
- zap https://malisper.me/zap/
- https://funcall.blogspot.com/
- https://google.github.io/styleguide/lispguide.xml?showone=Pathnames#Macros
  - Allocation: "If you make an array with a *fill pointer*, fill it and then set it back to zero, those objects are still accesible"
  - "Use *check-type* in functions exported from a package"
  - "You must not *intern* at runtime. It cons. Creates permanent symbols that won't be GC."
  - "You must not use *unintern* at runtime"
  - "You may of course use *intern* at compile-time"
    - alexandria:symbolicate
    - alexandria:format-symbol
- Diferentiation in lisp (resume at 11:00)
  https://www.youtube.com/watch?v=EyhL1DNrSME
- Reader Macros in Common Lisp
  https://gist.github.com/chaitanyagupta/9324402
- nes https://ahefner.livejournal.com/20528.html
- https://z0ltan.wordpress.com/2016/09/02/basic-concurrency-and-parallelism-in-common-lisp-part-3-concurrency-using-bordeaux-and-sbcl-threads/
- https://github.com/emacs-helm/helm-sly
- https://ambrevar.xyz/modern-common-lisp/index.html
- https://lainchan.org/~lisp/textdumps-and-videos.txt
- (princ-to-string :this)
- defgeneric, you can put the default method in it under (:method (arg arg) nil)
- readonly is a slot defstruct arg
- One can use reinitialize-instance to avoid allocating a new instance of
  a thing and instead reset the values to the default initargs
  http://www.method-combination.net/blog/archives/2009/12/16/using-reinitialize-instance.html
* Elf Binary Release
|-----------------+-------------+-------+-----+-----|
|                 | compression | extra | .so | X11 |
|-----------------+-------------+-------+-----+-----|
| deploy+appimage | Y           | Y     | Y   | Y   |
| deploy          | Y           |       | Y   | Y   |
| sb-ext          | Y           |       |     | Y   |
| static          | Y           |       | Y   |     |
| groveler        |             |       | Y   | ?   |
|-----------------+-------------+-------+-----+-----|
  "sbcl --disable-debugger --no-sysinit --no-userinit"
            Use an existing SBCL binary as a cross-compilation
            host even though you have stuff in your
            initialization files which makes it behave in such a
            non-standard way that it keeps the build from
            working. Also disable the debugger instead of
            waiting endlessly for a programmer to help it out
            with input on *DEBUG-IO*. (This is the default.)
- https://www.timmons.dev/posts/static-executables-with-sbcl.html
- https://nyxt.atlas.engineer/article/continuous-testing-and-packaging.org
- https://github.com/Shinmera/deploy
** sbcl build
- sh make.sh --fancy --with-sb-linkable-runtime --with-sb-dynamic-core
  --fancy is
    - sb-core-compression
    - sb-xref-for-internals
    - sb-after-xc-core
** linux-packaging
- ASDF .config/common-lisp/.../asdf.conf
- https://gitlab.com/ralt/linux-packaging
  https://gitlab.com/ralt/linux-packaging/-/blob/master/.ci/build.sh
- Deps, asdf latest, cffi, wild
  https://github.com/privet-kitty/wild-package-inferred-system
  https://github.com/cffi/cffi
  https://gitlab.common-lisp.net/asdf/asdf
*** sbcl sb-linkable-runtime
    https://sourceforge.net/p/sbcl/sbcl/ci/402a8fab
#+begin_src markdown
  Add the new feature sb-linkable-runtime, that depends on **sb-dynamic-core**,
the sbcl build will create a file sbcl.o or libsbcl.a that you can link
with additional other object files and libraries to deliver your applications
as a single executable (after combining with a core file) that contains
whatever statically linked C libraries you need as extensions.
CFFI-toolchain and Bazel will be know how to use this features.

Support this feature on Linux, macOS and Windows, on x86 and x86-64.

  Dump the parameters to compile C code and link it into a file sbcl.mk.
This new file will be included even if sb-linkable-runtime isn't present,
so CFFI and other software will not have to guess with what compiler and
what options to build dynamically linkable extensions.

  Note that without a sb-linkable-runtime, SBCL can still dlopen the C code, but
then you need at least two files to deliver an application with non-Lisp code,
and that doesn't work if the code is provided as a *.a or *.o file
(not a *.so) compiled without -fPIC.
#+end_src
** templates
- https://github.com/fiddlerwoaroof/daydreamer
- https://github.com/zodmaner/cl-makefile-template
- https://github.com/phoe-trash/furcadia-post-splitter/
** Static Linking
*** Static Linking
  - collect2 is also another level of indirection between gcc and ld.
  - ld https://ftp.gnu.org/old-gnu/Manuals/ld-2.9.1/html_node/ld_3.html
     #+begin_src
  -E
  --export-dynamic
    When creating a dynamically linked executable, add all symbols to
    the dynamic symbol table. The dynamic symbol table is the set of
    symbols which are visible from dynamic objects at run time. If you
    do not use this option, the dynamic symbol table will normally
    contain only those symbols which are referenced by some dynamic
    object mentioned in the link. If you use dlopen to load a dynamic
    object which needs to refer back to the symbols defined by the
    program, rather than some other dynamic object, then you will
    probably need to use this option when linking the program itself.
#+end_src
*** Static Linking - Compilation
  Minimal example https://gitlab.com/ralt/static-program-op
  Florian https://www.mail-archive.com/cffi-devel@common-lisp.net/msg02990.html
  https://github.com/cffi/cffi/blob/677cabae64b181330a3bbbda9c11891a2a8edcdc/toolchain/c-toolchain.lisp
| SBCL                     | Compilation                       | Linking (sbcl.o)       |
|--------------------------+-----------------------------------+------------------------|
| sb-prelink-linkage-table | -Wno-buildin-declaration-mismatch | -no-pie -static        |
| sb-linkable-runtime      |                                   | -Wl,--export-dynamic   |
|                          |                                   | -ldl -lpthread -lz -lm |
|--------------------------+-----------------------------------+------------------------|
| sb-linkable-runtime      |                                   |                        |
| sb-dynamic-core          |                                   |                        |
*** Static Linking
*** GROVEL
- Grovel SDL2 bindings https://github.com/leosongwei/handy-sdl
- bare bones example of using grovel https://gist.github.com/FilWisher/d2d17d984f69950bf27e1f86483dcffc
- cl-mpi (using grovel)
  https://github.com/marcoheisig/cl-mpi/issues/17
  https://github.com/marcoheisig/cl-mpi/commit/4600e66e3da1d438a39d688d5550fd3b17df2223 (incomplete)
*** ASDF: Video: ELS - Delivering Common Lisp Applications with ASDF 3.3
    https://www.youtube.com/watch?v=W4YcsP2FZh4
    https://www.european-lisp-symposium.org/static/2017/rideau.pdf
    - Repo https://github.com/fare/workout-timer/
    - Uses Mixalot (cffi wrapped) https://github.com/ahefner/mixalot/
*** CFFI :static-program-op
   https://common-lisp.net/project/cffi/manual/cffi-manual.html#Static-Linking
   - https://common-lisp.net/project/cffi/manual/cffi-manual.html#The-Groveller
     If you use ASDF, CFFI-Grovel is integrated
   - Needs SBCL --with-sb-linkable-runtime --with-sb-dynamic-core
*** Florian (linux-packaging)
  - https://gitlab.com/ralt/linux-packaging/
     #+begin_src
  * Statically link the C libraries that it can into the image of your Lisp application
  * Detect the C shared libraries, and which linux package is providing them
  * Build an installable package on any linux distribution
     #+end_src
   - https://github.com/sbcl/sbcl/commit/402a8fab62db036b2dd79ad4e91c41304d4c825d
     Introduced on SBCL sb-linkable-runtime feature (not enabled by default?)
   - https://stackoverflow.com/questions/55183247/how-to-dump-an-executable-sbcl-image-that-uses-osicat
     #+begin_src
     It takes the approach of fixing static-program-op by extending
     it, but requires you to build a custom SBCL.
     #+end_src
*** Daewok
   https://www.timmons.dev/posts/static-executables-with-sbcl.html
   https://www.timmons.dev/posts/static-executables-with-sbcl-v2.html
* Binary/stream
** Other
- Common Lisp: The Language
  17.4. Functions on =Arrays of Bits=
  https://www.cs.cmu.edu/Groups/AI/html/cltl/clm/node161.html
- http://lisp-univ-etc.blogspot.com/2020/02/programming-algorithms-compression.html
- http://cl-cookbook.sourceforge.net/io.html
  If you need to copy a lot of data and the source and destination are both streams (of the same element type), it's very fast to use READ-SEQUENCE and WRITE-SEQUENCE:
 #+begin_src lisp
(let ((buf (make-array 4096 :element-type (stream-element-type input-stream)))
 (loop for pos = (read-sequence input-stream)
       while (plusp pos)
       do (write-sequence buf output-stream :end pos))))
 #+end_src
** Book: Practical Common Lisp
- 14 https://gigamonkeys.com/book/files-and-file-io.html
- (open), (close), (with-open-file)
- (read)
- (read-byte)
  (read-sequence)
  (read-char)
- 24 https://gigamonkeys.com/book/practical-parsing-binary-files.html
- If you wanted to read 2 bytes, into 1 number, you will need to:
  #+begin_src lisp
  (defun read-u2 (in)
    (+ (* (read-byte in) 256) (read-byte in)))
  #+end_src
- instead (ldb) can be used to *extract* and *set* BITs from an integer
  (ldb BYTESPEC INTEGER)
  (byte N-BITS POS-RIGHTMOST-BIT) creates the BYTESPEC
- Rewritting read-u2
  #+begin_src lisp
  (defun read-u2 (in)
    (let ((u2 0))
      (setf (ldb (byte 8 8) u2) (read-byte in))
      (setf (ldb (byte 8 0) u2) (read-byte in))
      u2))
  (defun write-u2 (out value)
    (write-byte (ldb (byte 8 8) value) out)
    (write-byte (ldb (byte 8 8) value) out))
  #+end_src
** Franz
- bits of integer:
  > #b10
- print in base 2 (let ((*print-base* 2)) (print #b10))
  (logior #b100 #b110) ; OR
  (logand #b100 #b110) ; AND
- logxor, logeqv, lognand, lognor, logandc1, logandc2, logorc1, logorc2
- Bit Testing
  #+begin_src lisp
  (logtest FLAGS MASK) ; T if bits in mask are 1
  (logbitp 1 FLAGS)    ; T if second bit is 1
  (logcount FLAGS)     ; count 1 bits
  #+end_src
- Vector bit, aref-able
  (make-array 32 :element-type 'bit :initial-element 0)
- Note: Bit Shifting to infity (to bignum)
  #+begin_src lisp
  (ash #b10 +1) -> #b100
  (ash #b10 -1) -> #b1
  #+end_src
- Subseq-like thing for bits, setf-able, returns the same
  #+begin_src lisp
  (ldb (byte Sz Pos) #b111000111)
  (ldb (byte  4   0) #b0111)     ->      #b111 ; rightmost 4 bits
  (ldb (byte  4   4) #b1100)     ->     #b1100 ; next 4 bits
  (ldb (byte  8   0) #b11000111) -> #b11000111 ; lowest  bits
  #+end_src
** Libraries
|----------------+----------------------------------------------------------------+----------------------------------------------------------------------|
| babel          | charset enc/dec, strings and (unsigned-byte 8)                 | https://github.com/cl-babel/babel                                    |
| bitio          | read multiples of 8 bits                                       | https://github.com/psilord/bitio                                     |
| bit-smasher    | utilities for =bit vectors=                                    | https://github.com/thephoeron/bit-smasher                            |
| conspack       | MessagePack like, encode and decode data types                 | https://github.com/conspack/cl-conspack                              |
| fast-io        | read arbitray sizes from streams                               | https://github.com/rpav/fast-io/                                     |
| flexi-streams  | read/write streams, dynamic encoding, in-memory binary streams | https://github.com/edicl/flexi-streams/                              |
| ieee-floats    | read float values from strings                                 | https://github.com/marijnh/ieee-floats                               |
| mmap           | read file into memory (mmap, munmap, msync,mprotect)           | https://github.com/Shinmera/mmap                                     |
| nibbles        | read/write 16/32/64 bits from octet vectors                    | https://github.com/froydnj/nibbles                                   |
| static-vectors | vectors from lisp to C                                         | https://github.com/sionescu/static-vectors                           |
| swap-bytes     | changing endianness of unsigned integers                       | https://github.com/sionescu/swap-bytes                               |
| simple-streams | bivalent, varying-width elements support                       | http://www.sbcl.org/manual/#Simple-Streams                           |
|                |                                                                | https://franz.com/support/documentation/current/doc/streams.htm      |
| gray-streams   |                                                                | https://lisp-journey.gitlab.io/gray-streams/                         |
|                |                                                                | https://franz.com/support/documentation/current/doc/gray-streams.htm |
|----------------+----------------------------------------------------------------+----------------------------------------------------------------------|
* books
- https://leanpub.com/lovinglisp/read
- https://leanpub.com/readevalprintlove001/read
- https://github.com/mark-watson/loving-common-lisp
* cffi
- function argument is a pointer to something
  #+begin_src c
  iplCreateContext(IPLLogFunction     logCallback,
                  IPLAllocateFunction allocateCallback,
                  IPLFreeFunction     freeCallback,
                  IPLhandle*          context)
  #+end_src
  #+begin_src lisp
  (let ((context (cffi:foreign-alloc :pointer)))
    (format t "raw: ~a pointer: ~a~%" context (cffi:mem-ref context :pointer))
    (ipl-create-context (cffi:null-pointer)
                        (cffi:null-pointer)
                        (cffi:null-pointer)
                        context)
    (format t "daw: ~a pointer: ~a~%" context (cffi:mem-ref context :pointer))
    context)
  #+end_src
- function that returns a pointer to a pointer
  https://stackoverflow.com/questions/35841771/common-lisp-cffi-pointer-to-the-pointer
- cffi: array of c struct accessing
  #+begin_src lisp
  (defcstruct tryout
    (low  :float)
    (high :int))
  (with-foreign-object (thing '(:struct tryout) 2)
    (with-foreign-slots ((low high) (mem-aptr thing '(:struct tryout) 0) (:struct tryout))
      (setf low 1s0)
      (setf high 10))
    (with-foreign-slots ((low high) (mem-aptr thing '(:struct tryout) 1) (:struct tryout))
      (setf low 2s0)
      (setf high 20))
    (print (mem-aref thing '(:struct tryout) 1))
    (print (mem-aref thing '(:struct tryout) 0)))
  #+end_src
* CLOS
** Common Lisp Recipies
 - &key arguments on (initialize-instance :after) are valid on (make-instance)
 - 13.4 - Providing Constructors for your classes
   All generic with &allow-other-key
   - (make-instance) - where :default-initargs are combined with :initform and :initarg
   - (allocate-instance) - new empty object
   - (initialize-instance) - does nothing but call...
   - (shared-initialize) -
 - Change class, from classa to classb:
   See: https://www.snellman.net/blog/archive/2015-07-27-use-cases-for-change-class-in-common-lisp/
   specialize main method below, to doset new values, common/new are already merged
   #+begin_src lisp
   (defmethod update-instance-for-different-class ((old classa) (new classb) &key)
     (setf (slot-value new 'name)
           (format nil "~A ~A"
                   (slot-value old 'fname)
                   (slot-value old 'lname))))
   #+end_src
 - Change definition of class (of the same class)
   #+begin_src lisp
   (defmethod update-instance-for-redefined-class ((old classa) added deleted plist &key
     (declare (ignore added deleted))
     (setf (slot-value obj 'name)
           (format nil "~A ~A"
                   (getf plist 'fname)
                   (getf plist 'lname))))
   #+end_src
 - 13.7 Whenever you’re attempting to read the value of an unbound slot of a CLOS object,
   the function SLOT-UNBOUND is called, which by default signals an error.
   #+begin_src lisp
   (defmethod slot-unbound (class (object classa) (slot-name (eql 'first-access)))
     (setf (slot-value object 'first-access)
           (get-universal-time))))
   #+end_src
** https://franz.com/lab/intermediate/
 - https://www.youtube.com/watch?v=aCNhmcXF8nw
 - (princ-to-string :this)
 - (defgeneric amethod (a1 a2)
 :argument-precedence-order a2 a1)
 - All *before-methods* in most-specific-*first* order.
 The most specific *primary* method.
 All *after-methods* in most-specific-*last* order.
 - Each class in the list of superclasses can contribute a component of the
 effective method
 - Primary method performs the bulk of the work and returns values
 – Before methods do error checking and preparation
 – After methods perform side-effects and cleanup
 - Most specific :around first
 - on primary method, using (call-next-method) is all the :before :after :around methods
** Libraries
- Efficiently represent several finite sets or small integers as a single non-negative integer.
  https://github.com/marcoheisig/bitfield
- Naive generators for Common Lisp
  https://github.com/cbeo/gtwiwtg
- https://github.com/EuAndreh/defclass-std
  shorthand
- https://github.com/pcostanza/filtered-functions
  "wrapper around eql for defmethod arguments, adding a filter function before method call"
- https://github.com/fisxoj/sanity-clause
  "validates proper initialization data types"
- https://github.com/kennytilton/cells
  https://github.com/kennytilton/cells/wiki
  "reactive, creates virtual slots that are really a call to slot or global"
- https://github.com/sellout/quid-pro-quo
  "contract programming, "requirements" before execute and "guarantees" after,
   as well as "invariants" for the whole class.
   Beyond type checking is a check of state local or global"
* Design Patterns
** Peter Norvig - in Dynamic Programming
   First-class types     : Abstract-Factory, Flyweight, Factory-Method, State, Proxy, Chain-Of-Responsibility
   First-class functions : Command, Strategy, Template-Method, Visitor
   Macros                : Interpreter, Iterator
   Method Combination    : Mediator, Observer
   Multimethods          : Builder
   Modules               : Facade
** https://wiki.c2.com/?AreDesignPatternsMissingLanguageFeatures
  Visitor.................. GenericFunctions (MultipleDispatch)
  Factory.................. MetaClasses, closures
  Singleton................ MetaClasses
  Iterator................. AnonymousFunctions, (used with HigherOrderFunctions, MapFunction, FilterFunction, etc.)
  Interpreter.............. Macros (extending the language) EvalFunction, MetaCircularInterpreter Support for parser generation (for differing syntax)
  Command.................. Closures, LexicalScope, AnonymousFunctions, FirstClassFunctions
  HandleBody............... Delegation, Macros, MetaClasses
  RunAndReturnSuccessor.... TailCallOptimization
  Abstract-Factory
  Flyweight
  Factory-Method
  State
  Proxy
  Chain-of-Responsibility.. FirstClass types (Norvig)
  Mediator, Observer....... Method combination (Norvig)
  Builder.................. Multi Methods (Norvig)
  Facade................... Modules (Norvig)
  Strategy................. higher order functions (Gene Michael Stover?), ControlTable
  AssociationList.......... Dictionaries, maps, HashTables (these go by numerous names in different languages)
* event
- GOTO 2017 • The Many Meanings of Event-Driven Architecture • Martin Fowler
  https://www.youtube.com/watch?v=STKCRSUsyP0
- Usages:
  - event-driven: cascade update of things based on a single change (reverse dependencies)
  - event vs command
  - observers/emitters architecture
  - async tasks
- Programming a MessageBus in Common Lisp https://www.youtube.com/watch?v=CNFr7zIfyeM
** lparallel - https://github.com/lmj/lparallel
- doc https://lparallel.org/kernel/
- kind of like go channels (might be can be called jobs)
  #+begin_src lisp
  (let ((channel (make-channel)))
    (submit-task channel '+ 3 4)
    (submit-task channel (lambda () (+ 5 6)))
    (list (receive-result channel)
          (receive-result channel)))
  ; => (7 11) or (11 7)
  #+end_src
- blocking queue
  #+begin_src lisp
  (defpackage :queue-example (:use :cl :lparallel :lparallel.queue))
  (in-package :queue-example)

  (let ((queue   (make-queue))
        (channel (make-channel)))
    (submit-task channel (lambda () (list (pop-queue queue)
                                     (pop-queue queue))))
    (push-queue "hello" queue)
    (push-queue "world" queue)
    (receive-result channel))
  ;; => ("hello" "world")
  #+end_src
- example using channels and queue
  https://github.com/mfiano/pyx/blob/6c77101741b006db343391a4ec8cafb34ed7728f/src/base/thread-pool.lisp
**  eventbus - https://github.com/noloop/eventbus
- eventbus
  - make-eventbus
  - get-all-events-name
  - get-all-listeners-of-event
  - get-listener-count-of-event
  - remove-all-listeners-of-event
  - off
  - on
  - once
  - emit
- example
  #+begin_src lisp
  EVENTBUS> (let ((e (make-eventbus)))
              (once e :my-event-name
                    (lambda ()
                      (print "ONCE")))
              (on e :my-event-name
                  (lambda ()
                    (print "ON")))
              (once e :my-event-name
                    (lambda ()
                      (print "ONCE?")))
              (emit e :my-event-name)
              t)
  "ONCE?"
  "ON"
  "ONCE"
  T
  #+end_src
**     deeds - https://github.com/Shinmera/deeds
- doc https://shinmera.github.io/deeds/
- example https://github.com/40ants/lisp-project-of-the-day/blob/master/content/2020/08/0151-deeds.org
* Gamedev
** CEPL
  https://github.com/cbaggers/spring-lisp-gamejam
** Trial
  - Lib https://github.com/Shinmera/sdf/
  - Game https://github.com/Shinmera/beamer/
  - Game https://github.com/Shirakumo/ld39
  - Game https://github.com/Shirakumo/ld45
  - Game https://github.com/shinmera/shootman
* Implementations
|------+---------+----------------------------------------+-------|
|      | active? |                                        | free? |
|------+---------+----------------------------------------+-------|
| MOCL | no      |                                        | no    |
| CCL  | yes     | https://ccl.clozure.com/               | yes   |
| ECL  | yes     | https://gitlab.common-lisp.net/ecl/ecl | yes   |
| SICL | yes     | https://github.com/robert-strandh/SICL | yes   |
| SBCL | yes     | http://www.sbcl.org/                   | yes   |
|------+---------+----------------------------------------+-------|
** SBCL
- https://pvk.ca/Blog/2013/11/22/the-weaknesses-of-sbcls-type-propagation/
- https://pvk.ca/Blog/2014/08/16/how-to-define-new-intrinsics-in-sbcl/
- https://pvk.ca/Blog/2014/03/15/sbcl-the-ultimate-assembly-code-breadboard/
** ECL
   android https://gitlab.common-lisp.net/ecl/ecl-android
** CCL
- Clozure, random errors on arm
  https://trac.clozure.com/ccl/ticket/1257
- Distributed programming for Clozure
  https://github.com/eugeneia/erlangen
  https://mr.gy/blog/erlangen-els-2017-lightning-talk.html
* Logic Programming (Non-Deterministic Programming)
 - https://github.com/phoe/amb
   https://github.com/phoe/amb/blob/main/doc/MANUAL.md
   https://mitpress.mit.edu/sites/default/files/sicp/full-text/book/book-Z-H-28.html
 - https://neil-lindquist.github.io/linear-programming/
 - https://github.com/sjl/temperance
   docs https://docs.stevelosh.com/temperance/usage/
 - https://github.com/nikodemus/screamer - logic programming
   - https://engineering.purdue.edu/~qobi/papers/aaai93.pdf
   - Example https://nikodemus.github.io/screamer/sudoku.lisp.html
   - https://i-need-closures.blogspot.com/2006/03/
   - https://unwindprotect.com/constraint-programming
   - https://www.youtube.com/watch?v=z7V5BL6W3CA
 - Behind the Scenes with Auto Layout - iOS Conf SG 2019 https://www.youtube.com/watch?v=gxfyb3ipUFg
 - https://github.com/Shinmera/classowary
   https://shinmera.github.io/classowary/
** Video: Intro to SCREAMER
   https://www.youtube.com/watch?v=z7V5BL6W3CA&t=6582s
- "You have functions that are allowed to multiple valid results"
- Internally does some =backtracking= if a restriction is found
- Example
  #+begin_src lisp
(one-value (an-integer-between 5 200))
(one-value (let ((x (an-integer-between 5 200)))
              (assert! (not (= x 5)))
              x))
  #+end_src
- (one-value) (all-values) (ith-value)
  are wrappers/barries between the non-deterministic part (screamer) and our code
- Avoid using SIDE-EFFECTS in your non-deterministic context
  - There are ways to control it and backtrack SETFs, by caching the current value and reassign on backtrack
  - (local) undone
    (global) not undone
- (an-integer-between)
  (an-integer-above
  (a-member-of) (either)
- DO NOT USE (all-values) ON A UNBOUND NON-DETERMINISTIC VALUE
  - You can grab them with (ith-value)
  - (for-effect)
- (trail FUNCTION), calls FUNCTIOn on each backtracking, when present on a nondt env
- Screamer, never modifies a user passed object
- =logic variables=
  - (make-variable :v)
  - (an-integet-betweenv 2 1 :v)
  - are variables that are still to be computed (one-value, et all)
  - but can be constraint with, assert! or (=v) or (memberv) or (<v)
  - to name it, give an extra argument to most non-det created functions
  - there is no way to reverse contrainsts once added
* Looping
- https://github.com/Shinmera/trivial-extensible-sequences
  https://shinmera.github.io/trivial-extensible-sequences/
- 'User-extensible sequences in Common Lisp' by Christophe Rhodes[1]
  https://web.archive.org/web/20150918224411/http://www.doc.gold.ac.uk/\~mas01cr/papers/ilc2007/sequences-20070301.pdf
- https://github.com/ruricolist/serapeum/blob/master/REFERENCE.md#iter
  - do-hash-table
  - do-each, iterates over a sequence
  - collecting, collect
    with-collector
    with-collectors
  - summing, sum
  - nlet, goto wrapper for tail recursion
- https://github.com/yitzchak/trivial-do/
  do like iterators for different structs
  - doalist
  - dohash
  - dolist*, with index tracking variable
  - doplist
  - doseq
  - doseq*, with index tracking variable
- https://github.com/alessiostalla/doplus
  like iterate
** loop
  https://web.archive.org/web/20171127083905/http://www.method-combination.net/blog/archives/2010/04/06/looping-issues.html
  https://lispcookbook.github.io/cl-cookbook/iteration.html
  https://gigamonkeys.com/book/loop-for-black-belts.html
** iterate
- Source https://github.com/lisp-mirror/iterate
- examples https://github.com/earl-ducaine/loop-facility-clhs-examples
- addons https://github.com/ruricolist/cloture/blob/623c15c8d2e5e91eb87f46e3ecb3975880109948/iterate-drivers.lisp
- addons https://github.com/sjl/cl-losh/blob/master/src/iterate.lisp
- https://common-lisp.net/project/iterate/doc/index.html#Top
- https://common-lisp.net/project/iterate/
- https://common-lisp-libraries.readthedocs.io/iterate/
- https://web.archive.org/web/20170713105315/https://items.sjbach.com/280/extending-the-iterate-macro
- https://sites.google.com/site/sabraonthehill/loop-v-iter
- https://etc.ruricolist.com/2019/12/16/the-iterate-clause-trick/
*** Article: Comparing LOOP and ITERATE
    https://web.archive.org/web/20170713081006/https://items.sjbach.com/211/comparing-loop-and-iterate
- Accumulation:
  |-------------+----------------+-----------------------------|
  | collect     |                |                             |
  | appending   |                |                             |
  | nconcing    |                |                             |
  | *adjoining  | collect+unique |                             |
  | *unioning   | append +unique |                             |
  | *nunioning  |                |                             |
  | *accumulate | *generic*      | (accumulate lst by #'union) |
  |-------------+----------------+-----------------------------|
- Reduction:
  |-----------+-----------+-------------------------------------|
  | sum       | #'+       |                                     |
  | *multiply | #'*       |                                     |
  | counting  | #'count   |                                     |
  | maximize  | #'max     |                                     |
  | minimize  | #'min     |                                     |
  | *reducing | *generic* | (reducing d by #'/ initial-value 0) |
  |-----------+-----------+-------------------------------------|
  - reducing: a reduccion builder, ex:
     #+begin_src lisp
  (defmacro dividing (num &keys (initial-value 0))
    `(reducing , num by #'/ initial-value ,initial-value))
  (iterate (for i in '(10 5 2))
    (dividing i :initial-value 100)
     #+end_src
- Boolean aggregation: (same in loop and interation)
  |--------+----------|
  | always | #'every  |
  | never  | #'notany |
  | theris | #'some   |
  |--------+----------|
- Finding
  #+begin_src lisp
  (iterate (for lst in '((a) (b c d) (e f)))
    (finding lst maximizing (length lst)))
  #+end_src
- Control Flow:
  - (next-iteration) like continue or next on other languages
  - (if-first-time then else)
  - (first-iteration-p)
- Destructuring:
  - Can destructure values easily
** gtwiwtg "naive generators"
   https://github.com/cbeo/gtwiwtg
** SERIES
#+CAPTION: All methods exported
#+NAME:   fig:SED-HR4049
  [[./series.png]]

  https://cliki.net/SERIES
  http://series.sourceforge.net/
  https://github.com/tokenrove/series
  Ref https://quickref.common-lisp.net/series.html
  Manual https://www.cs.cmu.edu/Groups/AI/html/cltl/clm/node347.html
  Example https://github.com/tokenrove/series/blob/master/s-test.lisp
  Example https://github.com/BusFactor1/mcl/blob/master/examples/series/stest.lisp
  Example https://github.com/rabuf/advent-of-code
  Extension https://github.com/mikelevins/taps
  Video: Intro to SERIES   https://www.youtube.com/watch?v=uRLgZCV4bOM
  Video: SERIES vs gtwiwtg https://www.youtube.com/watch?v=5ClUB2kLaZ0
  Article https://fourier.github.io/lisp/2017/12/17/series.html
  http://www.dtic.mil/dtic/tr/fulltext/u2/a219961.pdf
  http://www.dtic.mil/dtic/tr/fulltext/u2/a218220.pdf
*** Part 1
**** Intro
    #+begin_src lisp
(collect-sum (choose-if #'plusp (scan '(1 -2 3 -4))))
;; => 4
(let ((x (subseries (scan-range :from 0 :by 2) 0 5)))
  (values (collect x) (collect-sum x)))
;; => (0 2 4 6 8), 20

;; Scanners
(series 'a)
(scan '(a b c))
(scan 'vector #(a b c))
(scan-range :from 1 :upto 3)
(scan-plist '(a 1 b 2))

;; Transducers
(positions #Z(a nil b c nil nil));; =>#Z(0 2 3)
(choose #Z(nil t t nil) #Z(1 2 3 4));; => #Z(2 3))

;; Collectors
#+end_src
**** Generators and Gatherers
***** Generators
- by using (next-in) we get the next element on the series
  with side-effect (like streams, unlike series)
- Any Series can be converted in a Generator
- (next-in GENERATOR &body ACTION-LIST)
  (next-in x (return T))
  (next-in x (return nil))
  executes action-list when it runs out of elements
  or errors
- (generator SERIES)
***** Gatherers
- inverse of a generator, like and output stream
- one at the time
- Any one-input/one-output collector can be converted into a gatherer
- (next-out GATHERER ITEM), writes ITEM into gatherer
- (result-of GATHERER), gets the net result of a gatherer
- (gatherer COLLECTOR)
  arg must be a one input collector function
  #+begin_src lisp
(let ((x (gatherer #'collect))
     ((y (gatherer #'(lambda (x) (collect-sum
                             (choose-if #'oddp x))))))
  (dotimes (i 4)
    (next-out x i)
    (next-out y i)
    (if (evenp i) (next-out x (* i 10))))
  (values (result-of x) (result-of y))))
;; => (0 0 1 2 20 3), 4
  #+end_src
- (gathering VAR-COLLECTOR-PAIR-LIST &body body)
  Returns N values, each value is the (result-of) each gatherer.
  #+begin_src lisp
(gathering ((x collect)
            (y collect-sum))
  (dotimes (i 3)
    (next-out y i)
    (if (evenp i) (next-out x (* i 10)))))
;; => (0 20), 3
  #+end_src
- Optimization:
  - "1st eversion", vars on stack if closure are near
  - know at compile time *what* closure is involved and *which* scope
**** TODO Defining New Off-line Series Functions
- (producing OUTPUT-LIST INPUT-LIST &body BODY)
* LIBRARIES
- http://edicl.github.io/cl-fad/        - directory file, clossplatform
- readtable for string interpolation https://github.com/edicl/cl-interpol
- https://github.com/spwhitton/anaphora
- https://github.com/hipeta/arrow-macros
- https://github.com/dlowe-net/local-time
- Portable CL:*FEATURES* - https://github.com/trivial-features/trivial-features
- https://common-lisp-libraries.readthedocs.io/
- https://gitlab.com/mbabich/cl-chess   - (chess GUI)
- https://github.com/html/clache        - can be used for file score saving on game
- https://github.com/Shinmera/flow      - graph
- https://github.com/Shinmera/flare - value transition
- https://github.com/lmj/global-vars/
** Arrays/Matrix
- Build-in: Row slice, non-copy, :displaced-to & :displaced-index-offset
  https://stackoverflow.com/questions/12327237/common-lisp-how-to-access-a-row-of-a-certain-multi-dimension-array/12327524
  #+begin_src lisp
  > (let ((arr (make-array '(8 8) :initial-contents (partition-n 8 8 (range 64)))))
           (values
            (setf (aref (make-array
                    8
                    :displaced-to arr
                    :displaced-index-offset (* 8 2))
                        0) 999)
            arr))
999 (10 bits, #x3E7)
#2A((0 1 2 3 4 5 6 7)
    (8 9 10 11 12 13 14 15)
    (999 17 18 19 20 21 22 23)
    (24 25 26 27 28 29 30 31)
    (32 33 34 35 36 37 38 39)
    (40 41 42 43 44 45 46 47)
    (48 49 50 51 52 53 54 55)
    (56 57 58 59 60 61 62 63))
  >
  #+end_src
- AOP: https://github.com/bendudson/array-operations
- NUMCL: https://github.com/numcl/numcl
- SELECT: slices for arrays/matrix
  https://github.com/Lisp-Stat/select
  https://lisp-stat.github.io/select/
** Data Structures
- bounded, lossy, unbounded queue https://cliki.net/jpl-queues
- https://github.com/cbaggers/draw-cons-tree
- Pileup provides a portable, performant, and thread-safe binary heap
  https://github.com/nikodemus/pileup
  https://nikodemus.github.io/pileup/
- fset
  https://www.youtube.com/watch?v=wx9BN2ppESY
  https://www.youtube.com/watch?v=AfcjnBkWbfw
** Documentation
- https://github.com/Shinmera/staple
** GUI
- ALL https://lispcookbook.github.io/cl-cookbook/gui.html
- MCCLIM+classowary
  https://github.com/djeis97/dumb-mcclim-statusbar/
  http://turtleware.eu/posts/McCLIM-backends---Part-I-Medium-Output-Protocol.html
  Maze: https://www.youtube.com/watch?v=_PYGSfiX6tw[1] 1h30
  (https://gist.github.com/epanji/5901227977fd64689f01d3fb7eaa351b[2])
  decision tree: https://www.youtube.com/watch?v=8KHEwySzi9o[3] 5m
  (https://github.com/epanji/decision-tree/[4])
  building: https://www.youtube.com/watch?v=0uKptCcTqCc&t=19s[5] 2m
- LTK https://lisp-journey.gitlab.io/blog/gui-programming-in-common-lisp-part-1-of-5-tk/
      https://github.com/VitoVan/cl-pkr (image picker mutiple platform build)
      https://github.com/mijohnson99/ltk-small-games example
      http://www.peter-herth.de/ltk/ltkdoc/ doc
      https://peterlane.netlify.app/ltk-examples/#_more_widgets doc examples
- GTK https://dev.to/goober99/learn-common-lisp-by-example-gtk-gui-with-sbcl-5e5c
      http://www.crategus.com/books/cl-gtk/gtk-tutorial.html
      https://lazka.github.io/pgi-docs/Gtk-3.0/classes/Widget.html#properties
- QT  https://github.com/commonqt/commonqt5/
      https://github.com/kierangrant/cl-qt-example/
      https://github.com/Shinmera/qtools/tree/master/examples
- CLOG https://lisp-journey.gitlab.io/blog/clog-contest/
** Image
- https://github.com/tokenrove/imago
- https://github.com/sjl/cl-netpbm/
- https://github.com/slyrus/opticl
- https://github.com/slyrus/ch-image/
- https://github.com/epsilon-phase/img-genner
** Logging
- https://github.com/Shinmera/verbose
** Memoization
- https://github.com/orivej/defmemo     - cache function call
- https://github.com/eschulte/memoize
  Thread safe memoized defuns, using a synchronized type of hash table
  See: https://groups.google.com/forum/#!topic/sbcl-help-archive/NtG3r0oGaC0
** Pattern Matching/Destructuring
|-----------------+------------------------+---------------------+------------------------------------------------|
| optima          | pattern matching (old) |                     | https://github.com/m2ym/optima                 |
| trivia          | pattern matching       | defun-match*, ppcre | https://github.com/guicho271828/trivia         |
| fare-quasiquote | extensions for trivia  |                     | https://github.com/fare/fare-quasiquote        |
| let-plus        | destructuring          | defun+              | https://github.com/tpapp/let-plus              |
| metabang-bind   | destructuring          |                     | https://common-lisp.net/project/metabang-bind/ |
| serapeum        |                        | mvlet               |                                                |
|-----------------+------------------------+---------------------+------------------------------------------------|
- https://common-lisp.net/project/metabang-bind/user-guide.html
** String Manipulation/Parsing
- https://github.com/mrossini-ethz/parseq
  https://www.cliki.net/parseq
  https://40ants.com/lisp-project-of-the-day/2020/10/0207-parseq.html
- https://github.com/stylewarning/cl-permutation
- https://github.com/rudolfochrist/cl-change-case
** Testing
https://github.com/lmj/1am
https://lisp-lang.org/learn/writing-libraries
https://lisp-lang.org/learn/continuous-integration
*** parachute - https://github.com/Shinmera/parachute
:perform (asdf:test-op (op c) (uiop:symbol-call :parachute :test :test-package))
*** fiveam    - https://github.com/sionescu/fiveam
:perform (asdf:test-op (o s) (uiop:symbol-call :fiveam :run! 'quasirpg-tests:all-tests))
- Game of Life TDD in Common Lisp
  https://www.youtube.com/watch?v=-7QRrUpWR34
- https://github.com/Ferada/cl-mock/
  - count the nr of e
  http://turtleware.eu/posts/Tutorial-Working-with-FiveAM.html
  #+begin_src common-lisp
  (test test-+
    "Test the + function"     ;optional description
    (is (= 0 (+ 0 0)))
    (is (= 4 (+ 2 2)))
    (is (= 1/2 (+ 1/4 1/4))))
  #+end_src
*** quickproject
- fiveam, travis, gitignore, coc
  https://github.com/fisxoj/fishproject/tree/master/template
- fiasco or cacau with assert-p
  https://github.com/maruks/quickproject-templates
  https://github.com/noloop/cacau http://quickdocs.org/assert-p/
  https://github.com/joaotavora/fiasco
** Typing
  https://github.com/stylewarning/cl-algebraic-data-type
  https://renato.athaydes.com/posts/revenge_of_lisp-part-2.html
  https://medium.com/@MartinCracauer/static-type-checking-in-the-programmable-programming-language-lisp-79bb79eb068a
  https://alhassy.github.io/TypedLisp
  https://ambrevar.xyz/modern-common-lisp/
  ftype https://write.as/loke/common-lisp-code-optimisation
** Web
- Static site https://paste.stevelosh.com/3ffff3a56c98d98de38c793945b54f3c1b545667
|---------+----------------------+-----------------------------------------------------------------|
| plump   | html,xml parser      | https://github.com/Shinmera/plump                               |
| clss    | css selectors        | https://github.com/Shinmera/CLSS                                |
| cl-who  | lisp to html         | https://github.com/edicl/cl-who https://edicl.github.io/cl-who/ |
| slugify | text to slugged-text | https://github.com/EuAndreh/cl-slug/                            |
|---------+----------------------+-----------------------------------------------------------------|
* incandescent
- actor container: idea being position depend on the container not actors,
  like and object and a particle system. Or an object and his hitbox (this one
  is inherence)
* Utils
- bundle :use of alexandria+serapeum+closer-mop+iterate+fset+split-sequence+cl-ppcre+named-readtables
  https://github.com/GrammaTech/cl-utils
- RUTILS docs https://github.com/vseloved/rutils/blob/master/docs/tutorial.md
- Alexandria docs https://common-lisp.net/project/alexandria/draft/alexandria.html
- Serapeum docs https://github.com/ruricolist/serapeum/blob/master/REFERENCE.md
  |----------------+-----------------------------------+-----------------------------|
  | (eqs)          | creates a single arg function     |                             |
  | (eqls)         |                                   |                             |
  | (equals)       |                                   |                             |
  | (trampoline)   | ??????                            |                             |
  | (define-train) | defun + define-compiler-macro     |                             |
  | (flip)         | flips function arguments          |                             |
  | (nth-arg)      | returns NTH argument              |                             |
  | (juxt)         |                                   | (juxt #'filter #'remove-if) |
  | (fork)         | ..(f g h) y <->   (f y) g   (h y) | (fork #'/ #'sum #'length)   |
  | (fork2)        | x (f g h) y <-> (x f y) g (x h y) | (fork #'list #'+ #'-)       |
  | (hook)         | f(y,g(y))                         | (hook #'= #'floor)          |
  |----------------+-----------------------------------+-----------------------------|
- CL-LOSH docs https://github.com/sjl/cl-losh/blob/master/DOCUMENTATION.markdown
  https://lisp-journey.gitlab.io/blog/snippets-functional-style-more/
  (nullary)
  (gathering)
- fare-utils https://github.com/fare/fare-utils
  (defun-inline)
- haskell
  https://github.com/Dimercel/listopia  Data.List functions
- clojure
  https://github.com/ruricolist/cloture complete reimplementation
  https://github.com/joinr/clclojure    complete reimplementation
  https://github.com/eigenhombre/cl-oju just some functions
  +---------------+-------------+
  | take          | drop        |
  | spit          | slurp       |
  | neg?          | pos?        |
  | partition-all | partition-n |
  | interleave    | interpose*  |
  | rand-int      | rand-nth    |
  | frequencies   | group-by    |
  | juxt          | partial     |
  | range         |             |
  | repeatedly    |             |
  | sort-by       |             |
  +---------------+-------------+
  * interperse
* Tutorial: koans
- Things that are T (everything that is NOT NIL)
  1. empty list
  2. a list containing NIL
  3. an array with no elements
  4. number 0
- (and) can take N number of arguments
  returns the *last value*
- (or) can take N number or argumets
  returns the *first non-nil* value it founds
- (/=) is a function for not equal
- STRINGS are array and atoms
  - a string is NOT a list
- NIL is both a list and an atom
- (let) binds to NIL by default
  (let*) binds are sequentially
- (block TAG) and (return-from TAG RETURN-VALUE) exists..
  https://www.cs.cmu.edu/Groups/AI/html/cltl/clm/node85.html
- Mentions this for "enclosed variables", variables that can't be override
  (declare (special (x))), makes them overridable
  https://gigamonkeys.com/book/variables.html
- CLOSURE takes precedence over local vars
- dynamic vars exists...can be (declare (special VAR)), changes binding (outer takes precedence)
  http://clhs.lisp.se/Body/d_specia.htm
- (case)
  - to match a T or NIL, put them between parentheses
  - uses EQL
- eql: numbers, characters and objects (if they are the exact same instance)
- equal: strings...
- (cons) can be used to preppend something to a list
  (cdr) on a (cons) returns the second elements (not nested into a list)
- (push) sets place to a new cons with a new *car*
  (pop)  sets place to his *cdr*, returning car
- (append) concats 2 lists into 1, creates new list
  (nconc)  concats 2 lists into 1, inplace
- (last) returns the last =CONS= cell
- =proper lists= end with NIL on the last CDR
  =improper list= has a non-nil on the last CDR, or not has a last CDR (circular list)
- (list*) builds a improper list
- =cycle list= build, setting the cdr last to self
  (setf (cdr (last cyclic-list)) cyclic-list)
- (list-length)
  exists and works on cyclic lists by returning nil
- many lisp functions operate ONLY on =proper lists=
- (subseq)
  with both indexes equal (=) returns nil
- (aref) stands for "array reference"
  (array-rank)       N dimensions
  (array-dimensions) list of dimensions
  (array-total-size) N total elements
- (adjust-array) changes dimensions of a adjustable array
- (row-major-aref) like aref but with 1(one) argument
- (make-array 4 :element-type 'bit :initial-contents '(0 0 1 1)) , the =bit vector= type
  #*0101
  bit-and bit-ior bit-xor
- (values) is also setfable
- Equality
  |         | objects | numbers | char | lists | string | bit-array | pathnames | array | struct | hash-table |
  |---------+---------+---------+------+-------+--------+-----------+-----------+-------+--------+------------|
  | EQ      | x       |         |      |       |        |           |           |       |        |            |
  | EQL     | x       | x       | x    |       |        |           |           |       |        |            |
  | EQUAL   | x       | x       | x    | x     | x      | x         | x         |       |        |            |
  | EQUALP* | x       | x       | x    | x     | x      | x         | x         | x     | x      | x          |
  * chars of the same letter
    strings case insensitive
    numbers same with different type
- (char) can get a character from a string
- (hash-table-count) N elements on the hashtable
  - EQ, ~EQL~, EQUAL, EQUALP are the available hashtable tests
- &rest, if passed no arguments returns NIL (not '(nil))
- &key, if passes twice a keyword, it uses the first one
- &rest must come before &key
  - if no keyword passed NIL
  - if a keyword is passed it will get the keyword and the value
- (function) will return the function named the argument (macro, not need to quote a symbol)
  #' is the syntax sugar
- (apply FUNCTION LIST) applies the FUNCTION to the LIST of arguments
  (apply FUNCTION ARG? ARG? LIST)
- strings are vector/arrays/vectors of characters
- (search) to find a string (sequence) into another
- (defstruct (NAME (:conc-name ALIAS)) is used to define the acessor with a different prefix
- (defstruct (NAME (:include   OTHERS)) is used to define the a struct to compose with
  both accessor can be used
  on copy, setting the slots will keep them different, but shared structures are different (the content of the slots)
- (dolist)      returns a value
  (dotimes) can return a value, named on the third argument
  (do)      is kind-sort-of a for loop, 1) bindings 2) termination test 3) epilogue 4) code to run
  1) test being "UNTIL" not "WHILE" test passes
  2) epilogue might return a value, right after the test, enclosed on the same same s-expression
- (loop), by defaults loops forever, can break from it with (return)
  you might make it look lispy
  #+begin_src lisp
(let ((counter 0))
  (loop (incf counter)
      (when (>= counter 100)
         (return counter)))
    #+end_src
- Not all vectors that contain characters are strings
- to TRANSPOSE a list of lists, you can use
  (apply #'mapcar #'list lists)
- (numbers '(1 2 3 4 5))
  (assert-equal '((((1 . 2) . 3) . 4) . 5) (reduce #'cons numbers))
  (assert-equal '(1 2 3 4 . 5) (reduce #'cons numbers :from-end t)))
- (loop)
  :in iterates over each element on the list
  (assert-equal '(:a :b :c) result-in)
  :on iterates over each (cons) cell on the list
  (assert-equal '((:a :b :c) (:b :c) (:c)) result-on)
- (loop)
  :for KEY :being :the :hash-keys :of HASHTABLE
  :using (hash-value VALUE)
- (loop)
  :count VARIABLE :into VARIABLE
  :sum   VARIABLE :into VARIABLE
  :maximize
  :minimize
- (loop) destructuring
  :for (a b) :in '((1 2) (3 4))
- (format)
  ~A for "aesthetic", :keyword into KEYWORD, char #\C into C
  ~S for "standsard", prints them with escaped characters, KEYWORD into :KEYWORD
  ~B, ~O, ~D, ~X and ~R (for customem radix) are radix for numbers, works with lists of numbers or operations
- (format)
  "~{~}" to iterate over a list
  (assert-equal "[1][2][3][4][5][6]" (format nil "~{[~A]~}" '(1 2 3 4 5 6)))
  (assert-equal "[1 2][3 4][5 6]" (format nil "~{[~A ~A]~}" '(1 2 3 4 5 6)))
  ~^, abords iteration when no more available
  (assert-equal "[1], [2], [3], [4], [5], [6]" (format nil "~{[~A]~^, ~}" '(1 2 3 4 5 6)))
  "~(~)", lowercases what is inside
  "~:(~)", uppercase first letter of each word
  "~@(~)", uppercase only the first letter of the sentence
  "~:@(~)", uppercase all
- Every object is of type T, no object is of type NIL
- 'nil is nil
- type of nil is 'NULL
- '() is list, atom, null, t
- Integers are either FIXNUM or BIGNUM
- (subtypep)
- ATOM are anything are are not cons
- (functionp)
* Youtube
- Common LISP Object Standard
  https://www.youtube.com/watch?v=IrmHp1rRQ68
- Lisp NYC
  https://vimeo.com/lispnyc
  https://www.youtube.com/channel/UCv33UlfX5S4PKxozGwUY_pA
- Patrik Stein -  https://vimeo.com/nklein
- ELS https://www.youtube.com/channel/UC55S8D_44ge2cV10aQmxNVQ/
- MIT 6.001 Structure and Interpretation, 1986
  https://www.youtube.com/playlist?list=PLE18841CABEA24090
- kraklisp https://www.youtube.com/channel/UCymtXMj1M7cKiV9TKLoTtEg
- INF4820 https://www.youtube.com/c/INF4820/
- Baggers https://www.youtube.com/user/CBaggers
- Neil Munro https://www.youtube.com/user/njalmunro
- Allegro CL https://www.youtube.com/c/FranzAllegroCL/
- Fare https://www.youtube.com/c/Fran%C3%A7oisRen%C3%A9Rideau/
- "afp" https://www.youtube.com/channel/UCYg6qFXDE5SGT_YXhuJPU0A/
** AFP Concurrency on Lisp - https://www.youtube.com/watch?v=3c7LwUjb-DU
- Bourdeux Threads
  - Initial bindings, to control the local environment.
  - Locks: (with-lock-held ())
  - Recursive locks: multiple operations on the same thread, take/release/take/release..
  - Semaphores: "a thread safe counter", signal and wait
  - Condition Locks: A lock + A conditional variable (not thread safe)
- Atomics
  - incf: use a cons and FIXNUM
  - cas: COMPARE-AND-SWAP on sbcl works on (slot-value)
- Memory order, "it prevents re-ordering across the fence"
  - (sb-thread:barrier)
- lparallel: channels/workers support, priority, queue, pmap, promises
* Book: https://leanpub.com/readevalprintlove001/read
- Tour of Lisp(s)
** Article: 2006 The Nature of Lisp
   https://www.defmacro.org/ramblings/lisp.html
- Put off by syntax at first
- Attempt to explain lisp with familiar concepts
- Comparison with XML
  - XML can be represented as a tree
  - So can be any programming language be represented as XML
- ANT(Another Near Tool) was build as a Make replacement for Java, to avoid spaces issues
  - Started using Java Property files and then moved to XML
  - XML to interpret and execute java code
* Book: https://leanpub.com/readevalprintlove002/read
* Book: https://leanpub.com/readevalprintlove003/read
* Book: https://leanpub.com/readevalprintlove004/read
* Article: https://etc.ruricolist.com/2020/01/02/the-multiple-value-call-trick/
  (multiple-value-bind) is a macro using (multiple-value-call)
  #+begin_src lisp
  (multiple-value-bind (x y z)
    (+ x y z))
  ;; Is the same as doing...
  (multiple-value-call (lambda (&optional x y z)
                         (+ x y z))
    (values 1 2 3))
  ;; But m-v-c can capture values from all the forms
  (m-v-c (lambda (&optional x y z)
           (+ x y z))
    ;; (values 1 2) 3
    ;; 1 2 3
    (values 1) (values 2 3))
  #+end_src
  - m-v-c works directly on the stack, with NO allocations
  - (values-list), takes a list and returns it as multiple values  
