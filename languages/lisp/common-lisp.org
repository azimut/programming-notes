- Some abbreviature macros https://github.com/cl21/cl21/blob/c36644f3b6ea4975174c8ce72de43a4524dd0696/src/stdlib/abbr.lisp
- Blog: http://funcall.blogspot.com/
- https://etc.ruricolist.com/2020/01/02/the-multiple-value-call-trick/
  (multiple-value-bind) is a macro using (multiple-value-call)
  #+begin_src lisp
  (multiple-value-bind (x y z)
    (+ x y z))
  ;; Is the same as doing...
  (multiple-value-call (lambda (&optional x y z)
                         (+ x y z))
    (values 1 2 3))
  ;; But m-v-c can capture values from all the forms
  (m-v-c (lambda (&optional x y z)
           (+ x y z))
    ;; (values 1 2) 3
    ;; 1 2 3
    (values 1) (values 2 3))
  #+end_src
  - m-v-c works directly on the stack, with NO allocations
  - (values-list), takes a list and returns it as multiple values
- Video: 2008 Raytracer in lisp
  https://www.youtube.com/watch?v=N1oMRw04W3E
  https://github.com/afwlehmann/clrt-tutorial
  https://web.archive.org/web/20130107155225/http://rudairandamacha.blogspot.de/2012/09/writing-simple-raytracer-in-common-lisp.html
- http://www.paulgraham.com/rootsoflisp.html
  http://www.paulgraham.com/diff.html
  http://paulgraham.com/avg.html
- Reader macros https://gist.github.com/chaitanyagupta/9324402
- https://github.com/hyotang666/common-lisp-pitfalls
- ASDF
  per file/package/system
   https://gitlab.common-lisp.net/asdf/asdf/blob/master/doc/best_practices.md#package_inferred
  https://common-lisp.net/project/asdf/asdf/The-package_002dinferred_002dsystem-extension.html#The-package_002dinferred_002dsystem-extension
- sectorLISP https://www.youtube.com/watch?v=xD14SLU2u2k
- https://mumble.net/~campbell/scheme/style.txt
- https://github.com/hanshuebner/bknr-datastore
- music composition
  https://quod.lib.umich.edu/s/spobooks/bbv9810.0001.001?rgn=main;view=fulltext
- fset
  https://www.youtube.com/watch?v=wx9BN2ppESY
  https://www.youtube.com/watch?v=AfcjnBkWbfw
- https://bernsteinbear.com/blog/compiling-a-lisp-0/
- CLI arguments
  https://stackoverflow.com/questions/1021778/getting-command-line-arguments-in-common-lisp
- Video: Escape from the Heap Low Level Programming
  https://www.youtube.com/watch?v=njfyWgqZmkI
- Android APK Compiler? https://github.com/3b/3b-dex
- https://www.ic.unicamp.br/~meidanis/courses/mc336/problemas-lisp/L-99_Ninety-Nine_Lisp_Problems.html
- https://franz.com/support/documentation/current/doc/mop/concepts.html
- https://mov.im/?blog/phoe%40movim.eu&page=2
- https://mov.im/?blog/phoe%40movim.eu/a9391f4b-485e-4f3a-ae02-051a5fc65ed1
- https://pvk.ca/Blog/2014/08/16/how-to-define-new-intrinsics-in-sbcl/
- https://pvk.ca/Blog/2014/03/15/sbcl-the-ultimate-assembly-code-breadboard/
- https://stevelosh.com/blog/2016/08/lisp-jam-postmortem/
- http://wcp.sdf-eu.org/software/index.html
- ALL SYMBOLS http://clhs.lisp.se/Front/X_AllSym.htm
- zap https://malisper.me/zap/
- Static site https://paste.stevelosh.com/3ffff3a56c98d98de38c793945b54f3c1b545667
- https://funcall.blogspot.com/
- https://google.github.io/styleguide/lispguide.xml?showone=Pathnames#Macros
  - Allocation: "If you make an array with a *fill pointer*, fill it and then set it back to zero, those objects are still accesible"
  - "Use *check-type* in functions exported from a package"
  - "You must not *intern* at runtime. It cons. Creates permanent symbols that won't be GC."
  - "You must not use *unintern* at runtime"
  - "You may of course use *intern* at compile-time"
    - alexandria:symbolicate
    - alexandria:format-symbol
- Diferentiation in lisp (resume at 11:00)
  https://www.youtube.com/watch?v=EyhL1DNrSME
- Reader Macros in Common Lisp
  https://gist.github.com/chaitanyagupta/9324402
- nes https://ahefner.livejournal.com/20528.html
- https://z0ltan.wordpress.com/2016/09/02/basic-concurrency-and-parallelism-in-common-lisp-part-3-concurrency-using-bordeaux-and-sbcl-threads/
- https://github.com/emacs-helm/helm-sly
- https://ambrevar.xyz/modern-common-lisp/index.html
- https://lainchan.org/~lisp/textdumps-and-videos.txt
- (princ-to-string :this)
- defgeneric, you can put the default method in it under (:method (arg arg) nil)
- readonly is a slot defstruct arg
- One can use reinitialize-instance to avoid allocating a new instance of
  a thing and instead reset the values to the default initargs
  http://www.method-combination.net/blog/archives/2009/12/16/using-reinitialize-instance.html
- haskell
  https://github.com/Dimercel/listopia  Data.List functions
- clojure
  https://github.com/ruricolist/cloture complete reimplementation
  https://github.com/joinr/clclojure    complete reimplementation
  https://github.com/eigenhombre/cl-oju just some functions
  +---------------+-------------+
  | take          | drop        |
  | spit          | slurp       |
  | neg?          | pos?        |
  | partition-all | partition-n |
  | interleave    | interpose*  |
  | rand-int      | rand-nth    |
  | frequencies   | group-by    |
  | juxt          | partial     |
  | range         |             |
  | repeatedly    |             |
  | sort-by       |             |
  +---------------+-------------+
  * interperse
* Arrays/Matrix
- Build-in: Row slice, non-copy, :displaced-to & :displaced-index-offset
  https://stackoverflow.com/questions/12327237/common-lisp-how-to-access-a-row-of-a-certain-multi-dimension-array/12327524
  #+begin_src lisp
AOC2021> (let ((arr (make-array '(8 8) :initial-contents (partition-n 8 8 (range 64)))))
           (values
            (setf (aref (make-array
                    8
                    :displaced-to arr
                    :displaced-index-offset (* 8 2))
                        0) 999)
            arr))
999 (10 bits, #x3E7)
#2A((0 1 2 3 4 5 6 7)
    (8 9 10 11 12 13 14 15)
    (999 17 18 19 20 21 22 23)
    (24 25 26 27 28 29 30 31)
    (32 33 34 35 36 37 38 39)
    (40 41 42 43 44 45 46 47)
    (48 49 50 51 52 53 54 55)
    (56 57 58 59 60 61 62 63))
AOC2021>
  #+end_src
- AOP: https://github.com/bendudson/array-operations
- NUMCL: https://github.com/numcl/numcl
- SELECT: slices for arrays/matrix
  https://github.com/Lisp-Stat/select
  https://lisp-stat.github.io/select/
* Binary Release
 "sbcl --disable-debugger --no-sysinit --no-userinit"
            Use an existing SBCL binary as a cross-compilation
            host even though you have stuff in your
            initialization files which makes it behave in such a
            non-standard way that it keeps the build from
            working. Also disable the debugger instead of
            waiting endlessly for a programmer to help it out
            with input on *DEBUG-IO*. (This is the default.)
- https://www.timmons.dev/posts/static-executables-with-sbcl.html
- https://nyxt.atlas.engineer/article/continuous-testing-and-packaging.org
- https://github.com/Shinmera/deploy
** sbcl build
- sh make.sh --fancy --with-sb-linkable-runtime --with-sb-dynamic-core
  --fancy is
    - sb-core-compression
    - sb-xref-for-internals
    - sb-after-xc-core
** linux-packaging
- ASDF .config/common-lisp/.../asdf.conf
- https://gitlab.com/ralt/linux-packaging
  https://gitlab.com/ralt/linux-packaging/-/blob/master/.ci/build.sh
- Deps, asdf latest, cffi, wild
  https://github.com/privet-kitty/wild-package-inferred-system
  https://github.com/cffi/cffi
  https://gitlab.common-lisp.net/asdf/asdf
*** sbcl sb-linkable-runtime
    https://sourceforge.net/p/sbcl/sbcl/ci/402a8fab
#+begin_src markdown
  Add the new feature sb-linkable-runtime, that depends on **sb-dynamic-core**,
the sbcl build will create a file sbcl.o or libsbcl.a that you can link
with additional other object files and libraries to deliver your applications
as a single executable (after combining with a core file) that contains
whatever statically linked C libraries you need as extensions.
CFFI-toolchain and Bazel will be know how to use this features.

Support this feature on Linux, macOS and Windows, on x86 and x86-64.

  Dump the parameters to compile C code and link it into a file sbcl.mk.
This new file will be included even if sb-linkable-runtime isn't present,
so CFFI and other software will not have to guess with what compiler and
what options to build dynamically linkable extensions.

  Note that without a sb-linkable-runtime, SBCL can still dlopen the C code, but
then you need at least two files to deliver an application with non-Lisp code,
and that doesn't work if the code is provided as a *.a or *.o file
(not a *.so) compiled without -fPIC.
#+end_src
** templates
- https://github.com/fiddlerwoaroof/daydreamer
- https://github.com/zodmaner/cl-makefile-template
- https://github.com/phoe-trash/furcadia-post-splitter/
** Static Linking
*** Static Linking
  - collect2 is also another level of indirection between gcc and ld.
  - ld https://ftp.gnu.org/old-gnu/Manuals/ld-2.9.1/html_node/ld_3.html
     #+begin_src
  -E
  --export-dynamic
    When creating a dynamically linked executable, add all symbols to
    the dynamic symbol table. The dynamic symbol table is the set of
    symbols which are visible from dynamic objects at run time. If you
    do not use this option, the dynamic symbol table will normally
    contain only those symbols which are referenced by some dynamic
    object mentioned in the link. If you use dlopen to load a dynamic
    object which needs to refer back to the symbols defined by the
    program, rather than some other dynamic object, then you will
    probably need to use this option when linking the program itself.
#+end_src
*** Static Linking - Compilation
  Minimal example https://gitlab.com/ralt/static-program-op
  Florian https://www.mail-archive.com/cffi-devel@common-lisp.net/msg02990.html
  https://github.com/cffi/cffi/blob/677cabae64b181330a3bbbda9c11891a2a8edcdc/toolchain/c-toolchain.lisp
| SBCL                     | Compilation                       | Linking (sbcl.o)       |
|--------------------------+-----------------------------------+------------------------|
| sb-prelink-linkage-table | -Wno-buildin-declaration-mismatch | -no-pie -static        |
| sb-linkable-runtime      |                                   | -Wl,--export-dynamic   |
|                          |                                   | -ldl -lpthread -lz -lm |
|--------------------------+-----------------------------------+------------------------|
| sb-linkable-runtime      |                                   |                        |
| sb-dynamic-core          |                                   |                        |
*** Static Linking
*** GROVEL
- Grovel SDL2 bindings https://github.com/leosongwei/handy-sdl
- bare bones example of using grovel https://gist.github.com/FilWisher/d2d17d984f69950bf27e1f86483dcffc
- cl-mpi (using grovel)
  https://github.com/marcoheisig/cl-mpi/issues/17
  https://github.com/marcoheisig/cl-mpi/commit/4600e66e3da1d438a39d688d5550fd3b17df2223 (incomplete)
*** ASDF: Video: ELS - Delivering Common Lisp Applications with ASDF 3.3
    https://www.youtube.com/watch?v=W4YcsP2FZh4
    https://www.european-lisp-symposium.org/static/2017/rideau.pdf
    - Repo https://github.com/fare/workout-timer/
    - Uses Mixalot (cffi wrapped) https://github.com/ahefner/mixalot/
*** CFFI :static-program-op
   https://common-lisp.net/project/cffi/manual/cffi-manual.html#Static-Linking
   - https://common-lisp.net/project/cffi/manual/cffi-manual.html#The-Groveller
     If you use ASDF, CFFI-Grovel is integrated
   - Needs SBCL --with-sb-linkable-runtime --with-sb-dynamic-core
*** Florian (linux-packaging)
  - https://gitlab.com/ralt/linux-packaging/
     #+begin_src
  * Statically link the C libraries that it can into the image of your Lisp application
  * Detect the C shared libraries, and which linux package is providing them
  * Build an installable package on any linux distribution
     #+end_src
   - https://github.com/sbcl/sbcl/commit/402a8fab62db036b2dd79ad4e91c41304d4c825d
     Introduced on SBCL sb-linkable-runtime feature (not enabled by default?)
   - https://stackoverflow.com/questions/55183247/how-to-dump-an-executable-sbcl-image-that-uses-osicat
     #+begin_src
     It takes the approach of fixing static-program-op by extending
     it, but requires you to build a custom SBCL.
     #+end_src
*** Daewok
   https://www.timmons.dev/posts/static-executables-with-sbcl.html
   https://www.timmons.dev/posts/static-executables-with-sbcl-v2.html
* Binary/stream
** Other
- Common Lisp: The Language
  17.4. Functions on =Arrays of Bits=
  https://www.cs.cmu.edu/Groups/AI/html/cltl/clm/node161.html
- http://lisp-univ-etc.blogspot.com/2020/02/programming-algorithms-compression.html
- http://cl-cookbook.sourceforge.net/io.html
  If you need to copy a lot of data and the source and destination are both streams (of the same element type), it's very fast to use READ-SEQUENCE and WRITE-SEQUENCE:
 #+begin_src lisp
(let ((buf (make-array 4096 :element-type (stream-element-type input-stream)))
 (loop for pos = (read-sequence input-stream)
       while (plusp pos)
       do (write-sequence buf output-stream :end pos))))
 #+end_src
** Book: Practical Common Lisp
- 14 https://gigamonkeys.com/book/files-and-file-io.html
- (open), (close), (with-open-file)
- (read)
- (read-byte)
  (read-sequence)
  (read-char)
- 24 https://gigamonkeys.com/book/practical-parsing-binary-files.html
- If you wanted to read 2 bytes, into 1 number, you will need to:
  #+begin_src lisp
  (defun read-u2 (in)
    (+ (* (read-byte in) 256) (read-byte in)))
  #+end_src
- instead (ldb) can be used to *extract* and *set* BITs from an integer
  (ldb BYTESPEC INTEGER)
  (byte N-BITS POS-RIGHTMOST-BIT) creates the BYTESPEC
- Rewritting read-u2
  #+begin_src lisp
  (defun read-u2 (in)
    (let ((u2 0))
      (setf (ldb (byte 8 8) u2) (read-byte in))
      (setf (ldb (byte 8 0) u2) (read-byte in))
      u2))
  (defun write-u2 (out value)
    (write-byte (ldb (byte 8 8) value) out)
    (write-byte (ldb (byte 8 8) value) out))
  #+end_src
** Franz
- bits of integer:
  > #b10
- print in base 2 (let ((*print-base* 2)) (print #b10))
  (logior #b100 #b110) ; OR
  (logand #b100 #b110) ; AND
- logxor, logeqv, lognand, lognor, logandc1, logandc2, logorc1, logorc2
- Bit Testing
  #+begin_src lisp
  (logtest FLAGS MASK) ; T if bits in mask are 1
  (logbitp 1 FLAGS)    ; T if second bit is 1
  (logcount FLAGS)     ; count 1 bits
  #+end_src
- Vector bit, aref-able
  (make-array 32 :element-type 'bit :initial-element 0)
- Note: Bit Shifting to infity (to bignum)
  #+begin_src lisp
  (ash #b10 +1) -> #b100
  (ash #b10 -1) -> #b1
  #+end_src
- Subseq-like thing for bits, setf-able, returns the same
  #+begin_src lisp
  (ldb (byte Sz Pos) #b111000111)
  (ldb (byte  4   0) #b0111)     ->      #b111 ; rightmost 4 bits
  (ldb (byte  4   4) #b1100)     ->     #b1100 ; next 4 bits
  (ldb (byte  8   0) #b11000111) -> #b11000111 ; lowest  bits
  #+end_src
** Libraries
|----------------+------------------------------------------------------+--------------------------------------------|
| babel          | charset enc/dec, strings and (unsigned-byte 8)       | https://github.com/cl-babel/babel          |
| bitio          | read multiples of 8 bits                             | https://github.com/psilord/bitio           |
| bit-smasher    | utilities for =bit vectors=                          | https://github.com/thephoeron/bit-smasher  |
| conspack       | MessagePack like, encode and decode data types       | https://github.com/conspack/cl-conspack    |
| fast-io        |                                                      | https://github.com/rpav/fast-io/           |
| flexi-streams  | read/write, octects                                  | https://github.com/edicl/flexi-streams/    |
| ieee-floats    | read float values from strings                       | https://github.com/marijnh/ieee-floats     |
| mmap           | read file into memory (mmap, munmap, msync,mprotect) | https://github.com/Shinmera/mmap           |
| nibbles        | read/write 16/32/64 bits from octet vectors          | https://github.com/froydnj/nibbles         |
| static-vectors | vectors from lisp to C                               | https://github.com/sionescu/static-vectors |
| swap-bytes     | changing endianness of unsigned integers             | https://github.com/sionescu/swap-bytes     |
|----------------+------------------------------------------------------+--------------------------------------------|
* books
- https://leanpub.com/lovinglisp/read
- https://leanpub.com/readevalprintlove001/read
- https://github.com/mark-watson/loving-common-lisp
* cffi
- function argument is a pointer to something
#+begin_src
iplCreateContext(IPLLogFunction     logCallback,
                IPLAllocateFunction allocateCallback,
                IPLFreeFunction     freeCallback,
                IPLhandle*          context)
#+end_src
#+begin_src
(let ((context (cffi:foreign-alloc :pointer)))
  (format t "raw: ~a pointer: ~a~%" context (cffi:mem-ref context :pointer))
  (ipl-create-context (cffi:null-pointer)
                      (cffi:null-pointer)
                      (cffi:null-pointer)
                      context)
  (format t "daw: ~a pointer: ~a~%" context (cffi:mem-ref context :pointer))
  context)
#+end_src
- function that returns a pointer to a pointer
  https://stackoverflow.com/questions/35841771/common-lisp-cffi-pointer-to-the-pointer
- cffi: array of c struct accessing
#+begin_src
(cffi:defcstruct tryout
  (low  :float)
  (high :int))
(cffi:with-foreign-object (thing '(:struct tryout) 2)
  (cffi:with-foreign-slots ((low high) (cffi:mem-aptr thing '(:struct tryout) 0) (:struct tryout))
    (setf low 1s0)
    (setf high 10))
  (cffi:with-foreign-slots ((low high) (cffi:mem-aptr thing '(:struct tryout) 1) (:struct tryout))
    (setf low 2s0)
    (setf high 20))
  (print (cffi:mem-aref thing '(:struct tryout) 1))
  (print (cffi:mem-aref thing '(:struct tryout) 0)))
#+end_src
* CLOS
** Common Lisp Recipies
 - &key arguments on (initialize-instance :after) are valid on (make-instance)
 - 13.4 - Providing Constructors for your classes
   All generic with &allow-other-key
   - (make-instance) - where :default-initargs are combined with :initform and :initarg
   - (allocate-instance) - new empty object
   - (initialize-instance) - does nothing but call...
   - (shared-initialize) -
 - Change class, from classa to classb:
   See: https://www.snellman.net/blog/archive/2015-07-27-use-cases-for-change-class-in-common-lisp/
   specialize main method below, to doset new values, common/new are already merged
   #+begin_src lisp
   (defmethod update-instance-for-different-class ((old classa) (new classb) &key)
     (setf (slot-value new 'name)
           (format nil "~A ~A"
                   (slot-value old 'fname)
                   (slot-value old 'lname))))
   #+end_src
 - Change definition of class (of the same class)
   #+begin_src lisp
   (defmethod update-instance-for-redefined-class ((old classa) added deleted plist &key
     (declare (ignore added deleted))
     (setf (slot-value obj 'name)
           (format nil "~A ~A"
                   (getf plist 'fname)
                   (getf plist 'lname))))
   #+end_src
 - 13.7 Whenever you’re attempting to read the value of an unbound slot of a CLOS object,
   the function SLOT-UNBOUND is called, which by default signals an error.
   #+begin_src lisp
   (defmethod slot-unbound (class (object classa) (slot-name (eql 'first-access)))
     (setf (slot-value object 'first-access)
           (get-universal-time))))
   #+end_src
** https://franz.com/lab/intermediate/
 - https://www.youtube.com/watch?v=aCNhmcXF8nw
 - (princ-to-string :this)
 - (defgeneric amethod (a1 a2)
 :argument-precedence-order a2 a1)
 - All *before-methods* in most-specific-*first* order.
 The most specific *primary* method.
 All *after-methods* in most-specific-*last* order.
 - Each class in the list of superclasses can contribute a component of the
 effective method
 - Primary method performs the bulk of the work and returns values
 – Before methods do error checking and preparation
 – After methods perform side-effects and cleanup
 - Most specific :around first
 - on primary method, using (call-next-method) is all the :before :after :around methods
** Libraries
- Efficiently represent several finite sets or small integers as a single non-negative integer.
  https://github.com/marcoheisig/bitfield
- Naive generators for Common Lisp
  https://github.com/cbeo/gtwiwtg
- https://github.com/EuAndreh/defclass-std
  shorthand
- https://github.com/pcostanza/filtered-functions
  "wrapper around eql for defmethod arguments, adding a filter function before method call"
- https://github.com/fisxoj/sanity-clause
  "validates proper initialization data types"
- https://github.com/kennytilton/cells
  https://github.com/kennytilton/cells/wiki
  "reactive, creates virtual slots that are really a call to slot or global"
- https://github.com/sellout/quid-pro-quo
  "contract programming, "requirements" before execute and "guarantees" after,
   as well as "invariants" for the whole class.
   Beyond type checking is a check of state local or global"
* Design Patterns
** Peter Norvig - in Dynamic Programming
   First-class types     : Abstract-Factory, Flyweight, Factory-Method, State, Proxy, Chain-Of-Responsibility
   First-class functions : Command, Strategy, Template-Method, Visitor
   Macros                : Interpreter, Iterator
   Method Combination    : Mediator, Observer
   Multimethods          : Builder
   Modules               : Facade
** https://wiki.c2.com/?AreDesignPatternsMissingLanguageFeatures
  Visitor.................. GenericFunctions (MultipleDispatch)
  Factory.................. MetaClasses, closures
  Singleton................ MetaClasses
  Iterator................. AnonymousFunctions, (used with HigherOrderFunctions, MapFunction, FilterFunction, etc.)
  Interpreter.............. Macros (extending the language) EvalFunction, MetaCircularInterpreter Support for parser generation (for differing syntax)
  Command.................. Closures, LexicalScope, AnonymousFunctions, FirstClassFunctions
  HandleBody............... Delegation, Macros, MetaClasses
  RunAndReturnSuccessor.... TailCallOptimization
  Abstract-Factory
  Flyweight
  Factory-Method
  State
  Proxy
  Chain-of-Responsibility.. FirstClass types (Norvig)
  Mediator, Observer....... Method combination (Norvig)
  Builder.................. Multi Methods (Norvig)
  Facade................... Modules (Norvig)
  Strategy................. higher order functions (Gene Michael Stover?), ControlTable
  AssociationList.......... Dictionaries, maps, HashTables (these go by numerous names in different languages)
* Documentation
- https://github.com/Shinmera/staple
- git config for ./doc ?
* event
- GOTO 2017 • The Many Meanings of Event-Driven Architecture • Martin Fowler
  https://www.youtube.com/watch?v=STKCRSUsyP0
- Usages:
  - event-driven: cascade update of things based on a single change (reverse dependencies)
  - event vs command
  - observers/emitters architecture
  - async tasks
- Programming a MessageBus in Common Lisp https://www.youtube.com/watch?v=CNFr7zIfyeM
** lparallel - https://github.com/lmj/lparallel
- doc https://lparallel.org/kernel/
- kind of like go channels (might be can be called jobs)
  #+begin_src lisp
  (let ((channel (make-channel)))
    (submit-task channel '+ 3 4)
    (submit-task channel (lambda () (+ 5 6)))
    (list (receive-result channel)
          (receive-result channel)))
  ; => (7 11) or (11 7)
  #+end_src
- blocking queue
  #+begin_src lisp
  (defpackage :queue-example (:use :cl :lparallel :lparallel.queue))
  (in-package :queue-example)

  (let ((queue   (make-queue))
        (channel (make-channel)))
    (submit-task channel (lambda () (list (pop-queue queue)
                                     (pop-queue queue))))
    (push-queue "hello" queue)
    (push-queue "world" queue)
    (receive-result channel))
  ;; => ("hello" "world")
  #+end_src
- example using channels and queue
  https://github.com/mfiano/pyx/blob/6c77101741b006db343391a4ec8cafb34ed7728f/src/base/thread-pool.lisp
**  eventbus - https://github.com/noloop/eventbus
- eventbus
  - make-eventbus
  - get-all-events-name
  - get-all-listeners-of-event
  - get-listener-count-of-event
  - remove-all-listeners-of-event
  - off
  - on
  - once
  - emit
- example
  #+begin_src lisp
  EVENTBUS> (let ((e (make-eventbus)))
              (once e :my-event-name
                    (lambda ()
                      (print "ONCE")))
              (on e :my-event-name
                  (lambda ()
                    (print "ON")))
              (once e :my-event-name
                    (lambda ()
                      (print "ONCE?")))
              (emit e :my-event-name)
              t)
  "ONCE?"
  "ON"
  "ONCE"
  T
  #+end_src
**     deeds - https://github.com/Shinmera/deeds
- doc https://shinmera.github.io/deeds/
- example https://github.com/40ants/lisp-project-of-the-day/blob/master/content/2020/08/0151-deeds.org
* Gamedev
** CEPL
  https://github.com/cbaggers/spring-lisp-gamejam
** Trial
  - Lib https://github.com/Shinmera/sdf/
  - Game https://github.com/Shinmera/beamer/
  - Game https://github.com/Shirakumo/ld39
  - Game https://github.com/Shirakumo/ld45
  - Game https://github.com/shinmera/shootman
* GUI
  LTK https://lisp-journey.gitlab.io/blog/gui-programming-in-common-lisp-part-1-of-5-tk/
  GTK https://dev.to/goober99/learn-common-lisp-by-example-gtk-gui-with-sbcl-5e5c
* Logging
- https://github.com/Shinmera/verbose
* Logic Programming (Non-Deterministic Programming)
 - https://github.com/phoe/amb
   https://github.com/phoe/amb/blob/main/doc/MANUAL.md
   https://mitpress.mit.edu/sites/default/files/sicp/full-text/book/book-Z-H-28.html
 - https://neil-lindquist.github.io/linear-programming/
 - https://github.com/sjl/temperance
   docs https://docs.stevelosh.com/temperance/usage/
 - https://github.com/nikodemus/screamer - logic programming
   - https://engineering.purdue.edu/~qobi/papers/aaai93.pdf
   - Example https://nikodemus.github.io/screamer/sudoku.lisp.html
   - https://i-need-closures.blogspot.com/2006/03/
   - https://unwindprotect.com/constraint-programming
   - https://www.youtube.com/watch?v=z7V5BL6W3CA
 - Behind the Scenes with Auto Layout - iOS Conf SG 2019 https://www.youtube.com/watch?v=gxfyb3ipUFg
 - https://github.com/Shinmera/classowary
   https://shinmera.github.io/classowary/
** Video: Intro to SCREAMER
   https://www.youtube.com/watch?v=z7V5BL6W3CA&t=6582s
- "You have functions that are allowed to multiple valid results"
- Internally does some =backtracking= if a restriction is found
- Example
  #+begin_src lisp
(one-value (an-integer-between 5 200))
(one-value (let ((x (an-integer-between 5 200)))
              (assert! (not (= x 5)))
              x))
  #+end_src
- (one-value) (all-values) (ith-value)
  are wrappers/barries between the non-deterministic part (screamer) and our code
- Avoid using SIDE-EFFECTS in your non-deterministic context
  - There are ways to control it and backtrack SETFs, by caching the current value and reassign on backtrack
  - (local) undone
    (global) not undone
- (an-integer-between)
  (an-integer-above
  (a-member-of) (either)
- DO NOT USE (all-values) ON A UNBOUND NON-DETERMINISTIC VALUE
  - You can grab them with (ith-value)
  - (for-effect)
- (trail FUNCTION), calls FUNCTIOn on each backtracking, when present on a nondt env
- Screamer, never modifies a user passed object
- =logic variables=
  - (make-variable :v)
  - (an-integet-betweenv 2 1 :v)
  - are variables that are still to be computed (one-value, et all)
  - but can be constraint with, assert! or (=v) or (memberv) or (<v)
  - to name it, give an extra argument to most non-det created functions
  - there is no way to reverse contrainsts once added
* Looping
- https://github.com/ruricolist/serapeum/blob/master/REFERENCE.md#iter
  - do-hash-table
  - do-each, iterates over a sequence
  - collecting, collect
    with-collector
    with-collectors
  - summing, sum
  - nlet, goto wrapper for tail recursion
- https://github.com/yitzchak/trivial-do/
  do like iterators for different structs
  - doalist
  - dohash
  - dolist*, with index tracking variable
  - doplist
  - doseq
  - doseq*, with index tracking variable
- https://github.com/alessiostalla/doplus
  like iterate
** loop
  https://web.archive.org/web/20171127083905/http://www.method-combination.net/blog/archives/2010/04/06/looping-issues.html
  https://lispcookbook.github.io/cl-cookbook/iteration.html
  https://gigamonkeys.com/book/loop-for-black-belts.html
** iterate
- Source https://github.com/lisp-mirror/iterate
- examples https://github.com/earl-ducaine/loop-facility-clhs-examples
- addons https://github.com/ruricolist/cloture/blob/623c15c8d2e5e91eb87f46e3ecb3975880109948/iterate-drivers.lisp
- addons https://github.com/sjl/cl-losh/blob/master/src/iterate.lisp
- https://common-lisp.net/project/iterate/doc/index.html#Top
- https://common-lisp.net/project/iterate/
- https://common-lisp-libraries.readthedocs.io/iterate/
- https://web.archive.org/web/20170713105315/https://items.sjbach.com/280/extending-the-iterate-macro
- https://sites.google.com/site/sabraonthehill/loop-v-iter
- https://etc.ruricolist.com/2019/12/16/the-iterate-clause-trick/
*** Article: Comparing LOOP and ITERATE
    https://web.archive.org/web/20170713081006/https://items.sjbach.com/211/comparing-loop-and-iterate
- Accumulation:
  |-------------+----------------+-----------------------------|
  | collect     |                |                             |
  | appending   |                |                             |
  | nconcing    |                |                             |
  | *adjoining  | collect+unique |                             |
  | *unioning   | append +unique |                             |
  | *nunioning  |                |                             |
  | *accumulate | *generic*      | (accumulate lst by #'union) |
  |-------------+----------------+-----------------------------|
- Reduction:
  |-----------+-----------+-------------------------------------|
  | sum       | #'+       |                                     |
  | *multiply | #'*       |                                     |
  | counting  | #'count   |                                     |
  | maximize  | #'max     |                                     |
  | minimize  | #'min     |                                     |
  | *reducing | *generic* | (reducing d by #'/ initial-value 0) |
  |-----------+-----------+-------------------------------------|
  - reducing: a reduccion builder, ex:
     #+begin_src lisp
  (defmacro dividing (num &keys (initial-value 0))
    `(reducing , num by #'/ initial-value ,initial-value))
  (iterate (for i in '(10 5 2))
    (dividing i :initial-value 100)
     #+end_src
- Boolean aggregation: (same in loop and interation)
  |--------+----------|
  | always | #'every  |
  | never  | #'notany |
  | theris | #'some   |
  |--------+----------|
- Finding
  #+begin_src lisp
  (iterate (for lst in '((a) (b c d) (e f)))
    (finding lst maximizing (length lst)))
  #+end_src
- Control Flow:
  - (next-iteration) like continue or next on other languages
  - (if-first-time then else)
  - (first-iteration-p)
- Destructuring:
  - Can destructure values easily
** gtwiwtg "naive generators"
   https://github.com/cbeo/gtwiwtg
** SERIES
#+CAPTION: All methods exported
#+NAME:   fig:SED-HR4049
  [[./series.png]]

  https://cliki.net/SERIES
  https://quickref.common-lisp.net/series.html
  http://series.sourceforge.net/
  https://www.cs.cmu.edu/Groups/AI/html/cltl/clm/node347.html
  Example https://github.com/tokenrove/series/blob/master/s-test.lisp
  Example https://github.com/BusFactor1/mcl/blob/master/examples/series/stest.lisp
  Example https://github.com/rabuf/advent-of-code
  Extension https://github.com/mikelevins/taps
  Intro to SERIES https://www.youtube.com/watch?v=uRLgZCV4bOM
  SERIES vs gtwiwtg https://www.youtube.com/watch?v=5ClUB2kLaZ0
  Mirror https://github.com/tokenrove/series
  Article https://fourier.github.io/lisp/2017/12/17/series.html
  http://www.dtic.mil/dtic/tr/fulltext/u2/a219961.pdf
  http://www.dtic.mil/dtic/tr/fulltext/u2/a218220.pdf
*** Part 1
**** Intro
    #+begin_src lisp
(collect-sum (choose-if #'plusp (scan '(1 -2 3 -4))))
;; => 4
(let ((x (subseries (scan-range :from 0 :by 2) 0 5)))
  (values (collect x) (collect-sum x)))
;; => (0 2 4 6 8), 20

;; Scanners
(series 'a)
(scan '(a b c))
(scan 'vector #(a b c))
(scan-range :from 1 :upto 3)
(scan-plist '(a 1 b 2))

;; Transducers
(positions #Z(a nil b c nil nil));; =>#Z(0 2 3)
(choose #Z(nil t t nil) #Z(1 2 3 4));; => #Z(2 3))

;; Collectors
#+end_src
**** Generators and Gatherers
***** Generators
- by using (next-in) we get the next element on the series
  with side-effect (like streams, unlike series)
- Any Series can be converted in a Generator
- (next-in GENERATOR &body ACTION-LIST)
  (next-in x (return T))
  (next-in x (return nil))
  executes action-list when it runs out of elements
  or errors
- (generator SERIES)
***** Gatherers
- inverse of a generator, like and output stream
- one at the time
- Any one-input/one-output collector can be converted into a gatherer
- (next-out GATHERER ITEM), writes ITEM into gatherer
- (result-of GATHERER), gets the net result of a gatherer
- (gatherer COLLECTOR)
  arg must be a one input collector function
  #+begin_src lisp
(let ((x (gatherer #'collect))
     ((y (gatherer #'(lambda (x) (collect-sum
                             (choose-if #'oddp x))))))
  (dotimes (i 4)
    (next-out x i)
    (next-out y i)
    (if (evenp i) (next-out x (* i 10))))
  (values (result-of x) (result-of y))))
;; => (0 0 1 2 20 3), 4
  #+end_src
- (gathering VAR-COLLECTOR-PAIR-LIST &body body)
  Returns N values, each value is the (result-of) each gatherer.
  #+begin_src lisp
(gathering ((x collect)
            (y collect-sum))
  (dotimes (i 3)
    (next-out y i)
    (if (evenp i) (next-out x (* i 10)))))
;; => (0 20), 3
  #+end_src
- Optimization:
  - "1st eversion", vars on stack if closure are near
  - know at compile time *what* closure is involved and *which* scope
**** TODO Defining New Off-line Series Functions
- (producing OUTPUT-LIST INPUT-LIST &body BODY)
* MISCELLANEOUS
- https://github.com/sjl/cl-netpbm/     - image
- https://github.com/slyrus/opticl      - image
- https://github.com/slyrus/ch-image/   - image
- readtable for string interpolation https://github.com/edicl/cl-interpol
- thread-safe binary heap https://github.com/nikodemus/pileup
- bounded, lossy, unbounded queue https://cliki.net/jpl-queues
- https://github.com/mrossini-ethz/parseq
  https://www.cliki.net/parseq
  https://40ants.com/lisp-project-of-the-day/2020/10/0207-parseq.html
- https://github.com/cbaggers/draw-cons-tree
- https://github.com/tokenrove/imago
- https://github.com/stylewarning/cl-permutation
- https://github.com/sharplispers/let-plus
- https://github.com/rudolfochrist/cl-change-case
- https://github.com/spwhitton/anaphora
- https://github.com/hipeta/arrow-macros
- https://github.com/dlowe-net/local-time
- Portable CL:*FEATURES* - https://github.com/trivial-features/trivial-features
- https://common-lisp-libraries.readthedocs.io/
- https://github.com/eschulte/memoize
  Thread safe memoized defuns, using a synchronized type of hash table
  See: https://groups.google.com/forum/#!topic/sbcl-help-archive/NtG3r0oGaC0
- https://pvk.ca/Blog/2013/11/22/the-weaknesses-of-sbcls-type-propagation/
- https://common-lisp.net/project/metabang-bind/user-guide.html
- https://gitlab.com/mbabich/cl-chess   - (chess GUI)
- https://github.com/html/clache        - can be used for file score saving on game
- https://github.com/orivej/defmemo     - cache function call
- https://github.com/Shinmera/flow      - graph
- https://github.com/Shinmera/flare - value transition
- https://github.com/lmj/global-vars/
- Pileup provides a portable, performant, and thread-safe binary heap
  https://github.com/nikodemus/pileup
  https://nikodemus.github.io/pileup/
** incandescent
- actor container: idea being position depend on the container not actors,
  like and object and a particle system. Or an object and his hitbox (this one
  is inherence)
* Pattern Matching
  https://github.com/m2ym/optima
  https://github.com/guicho271828/trivia
  https://github.com/fare/fare-quasiquote
* Testing
https://github.com/lmj/1am
https://lisp-lang.org/learn/writing-libraries
https://lisp-lang.org/learn/continuous-integration
** parachute - https://github.com/Shinmera/parachute
:perform (asdf:test-op (op c) (uiop:symbol-call :parachute :test :test-package))
** fiveam    - https://github.com/sionescu/fiveam
:perform (asdf:test-op (o s) (uiop:symbol-call :fiveam :run! 'quasirpg-tests:all-tests))
- Game of Life TDD in Common Lisp
  https://www.youtube.com/watch?v=-7QRrUpWR34
- https://github.com/Ferada/cl-mock/
  - count the nr of e
  http://turtleware.eu/posts/Tutorial-Working-with-FiveAM.html
  #+begin_src common-lisp
  (test test-+
    "Test the + function"     ;optional description
    (is (= 0 (+ 0 0)))
    (is (= 4 (+ 2 2)))
    (is (= 1/2 (+ 1/4 1/4))))
  #+end_src
** quickproject
- fiveam, travis, gitignore, coc
  https://github.com/fisxoj/fishproject/tree/master/template
- fiasco or cacau with assert-p
  https://github.com/maruks/quickproject-templates
  https://github.com/noloop/cacau http://quickdocs.org/assert-p/
  https://github.com/joaotavora/fiasco
* Typing
  https://github.com/stylewarning/cl-algebraic-data-type
  https://renato.athaydes.com/posts/revenge_of_lisp-part-2.html
  https://medium.com/@MartinCracauer/static-type-checking-in-the-programmable-programming-language-lisp-79bb79eb068a
  https://alhassy.github.io/TypedLisp
  https://ambrevar.xyz/modern-common-lisp/
  ftype https://write.as/loke/common-lisp-code-optimisation
* Utils
- bundle :use of alexandria+serapeum+closer-mop+iterate+fset+split-sequence+cl-ppcre+named-readtables
  https://github.com/GrammaTech/cl-utils
- RUTILS docs https://github.com/vseloved/rutils/blob/master/docs/tutorial.md
- Alexandria docs https://common-lisp.net/project/alexandria/draft/alexandria.html
- Serapeum docs https://github.com/ruricolist/serapeum/blob/master/REFERENCE.md
  |----------------+-----------------------------------+-----------------------------|
  | (eqs)          | creates a single arg function     |                             |
  | (eqls)         |                                   |                             |
  | (equals)       |                                   |                             |
  | (trampoline)   | ??????                            |                             |
  | (define-train) | defun + define-compiler-macro     |                             |
  | (flip)         | flips function arguments          |                             |
  | (nth-arg)      | returns NTH argument              |                             |
  | (juxt)         |                                   | (juxt #'filter #'remove-if) |
  | (fork)         | ..(f g h) y <->   (f y) g   (h y) | (fork #'/ #'sum #'length)   |
  | (fork2)        | x (f g h) y <-> (x f y) g (x h y) | (fork #'list #'+ #'-)       |
  | (hook)         | f(y,g(y))                         | (hook #'= #'floor)          |
  |----------------+-----------------------------------+-----------------------------|
- CL-LOSH docs https://github.com/sjl/cl-losh/blob/master/DOCUMENTATION.markdown
  https://lisp-journey.gitlab.io/blog/snippets-functional-style-more/
  (nullary)
  (gathering)
- fare-utils https://github.com/fare/fare-utils
  (defun-inline)
* Web
|---------+----------------------+-----------------------------------------------------------------|
| plump   | html,xml parser      | https://github.com/Shinmera/plump                               |
| clss    | css selectors        | https://github.com/Shinmera/CLSS                                |
| cl-who  | lisp to html         | https://github.com/edicl/cl-who https://edicl.github.io/cl-who/ |
| slugify | text to slugged-text | https://github.com/EuAndreh/cl-slug/                            |
|---------+----------------------+-----------------------------------------------------------------|
* Book: Programming Algorithms in Lisp (2021) / Vsevolod Domkin
Source: https://github.com/vseloved/progalgs-code
** Chapter 1: Introduction
- Disconnect between algorithmic question in job interviews and everyday essence of the same job.
- Top 10% programmers?
- Two main reasons, due the lack of knowledge of:
  1. The underlying platforms
  2. Algorithms and algorithmic development technics
- Recommended: "The Algorithm Design Manual" by Steven Skiena
- Won't cover:
  * Persistent or probabilistic data structures
  * Advanced Tree
  * Graph
  * Optimization Algorithms
- Lisp has a ~numeric tower~, which means no overflow errors.
  https://en.wikipedia.org/wiki/Numerical_tower
- Python and JS, are in many ways *anti-algorithmic*.
  Trying to be simple and accessible, they hide too much from the programmer and don't give enough control of the concrete data.
** Chapter 2: Algorithmic Complexity
- Algorithm Qualities:
  - Complexity: Measured on the number of operations performed on provided input.
  - Correctness:
- Complexity Theory: as a branch of CS
  https://en.wikipedia.org/wiki/Computational_complexity_theory
- To *measure* complexity we count these Nr of operations in the ~upper limit~
  - Each loops adds multiplication to the formula
  - Each sequential block adds a plus sign
  - The Constant is the number of operations (for example, on the inner loop) for the worst case
- Big-O notation (depends of the *n* we are considering)
  - Constants become 1 (one)
  - We don't care about individual array dimensions differences (instead of n*m it becomes n*n)
  - ~O(n^2)~ has *quadratic complexity* aka *polynomial complexity* (a broader class)
    - In array dimensions
  - However if instead of caring about the dimensions of the array we do care about the number elements we have:
    - ~n^2~ as the number of elements, which can be written as ~n~, IF we mean by n the number elements.
    - ~O(n)~ Complexit is linear
- Complexity classes
  1. O(1) Constant Time
  2. O(log n) Sublinear
  3. O(n) Linear and O(n * log n) Superlinear
  4. O(n^c) Higher-Order Polynomial, where c is a constant >1
  5. O(c^n) Exponential, where c is usually 2 but at least >1
  6. O(n!) Lunatic Complex O(mg)
- Sometimes worst-case is significantly different than average-case, example on quicksort algorithm
- In practice the constant factors might be important. Or sometimes theorical-complexity may be worse in many practical applications.
- Besides *Execution time complexity* thereis also *Space complexity*, which measures the storage space used in relation to the input.
** Chapter 3: A Crash Course in Lisp
- Code Quality (simplicity, clarity, and beauty)
- Lisp programs consist of *forms* that are *evaluated* by the compiler.
  * Self-evaluation
  * Symbol evaluation
  * Expression evaluation:
    - 25 Special Operators (block, if, go)
    - ordinary function evaluation
    - Macro evaluation
- Book: On Lisp
- Book: Let Over Lambda
- Lisp, there is no distinction between statements and expressions.
- A do until loop:
  #+begin_src lisp
  (do () ((= beg end))
    (progn))
  #+end_src
- Modifying the REPL
  R: read, with *reader macros*
  E: eval, ordinary *macros* are a way to customize this stage
  P: print, *print-object* changes how objexts are printed
  L: can be replaced by any program logic
- Structural Programming Paradigm, can be expressed by:
  * Sequential execution:
    - (block), We can put things into one of this
    - (block test (return-from test 0)), We can return early from a named block with return-from
    - (block nil (return 0)), We can return from a nil named block (which are implicit in most of the looping constructs) with return
    - (progn) if we do not plan to return early from a block
  * Branching: (when) (unless) (cond)
  * Looping: We have many, unlike mainstream languages that provide a few and a way to extend them with polymorphism
* Tutorial: koans
- Things that are T (everything that is NOT NIL)
  1. empty list
  2. a list containing NIL
  3. an array with no elements
  4. number 0
- (and) can take N number of arguments
  returns the *last value*
- (or) can take N number or argumets
  returns the *first non-nil* value it founds
- (/=) is a function for not equal
- STRINGS are array and atoms
  - a string is NOT a list
- NIL is both a list and an atom
- (let) binds to NIL by default
  (let*) binds are sequentially
- (block TAG) and (return-from TAG RETURN-VALUE) exists..
  https://www.cs.cmu.edu/Groups/AI/html/cltl/clm/node85.html
- Mentions this for "enclosed variables", variables that can't be override
  (declare (special (x))), makes them overridable
  https://gigamonkeys.com/book/variables.html
- CLOSURE takes precedence over local vars
- dynamic vars exists...can be (declare (special VAR)), changes binding (outer takes precedence)
  http://clhs.lisp.se/Body/d_specia.htm
- (case)
  - to match a T or NIL, put them between parentheses
  - uses EQL
- eql: numbers, characters and objects (if they are the exact same instance)
- equal: strings...
- (cons) can be used to preppend something to a list
  (cdr) on a (cons) returns the second elements (not nested into a list)
- (push) sets place to a new cons with a new *car*
  (pop)  sets place to his *cdr*, returning car
- (append) concats 2 lists into 1, creates new list
  (nconc)  concats 2 lists into 1, inplace
- (last) returns the last =CONS= cell
- =proper lists= end with NIL on the last CDR
  =improper list= has a non-nil on the last CDR, or not has a last CDR (circular list)
- (list*) builds a improper list
- =cycle list= build, setting the cdr last to self
  (setf (cdr (last cyclic-list)) cyclic-list)
- (list-length)
  exists and works on cyclic lists by returning nil
- many lisp functions operate ONLY on =proper lists=
- (subseq)
  with both indexes equal (=) returns nil
- (aref) stands for "array reference"
  (array-rank)       N dimensions
  (array-dimensions) list of dimensions
  (array-total-size) N total elements
- (adjust-array) changes dimensions of a adjustable array
- (row-major-aref) like aref but with 1(one) argument
- (make-array 4 :element-type 'bit :initial-contents '(0 0 1 1)) , the =bit vector= type
  #*0101
  bit-and bit-ior bit-xor
- (values) is also setfable
- Equality
  |         | objects | numbers | char | lists | string | bit-array | pathnames | array | struct | hash-table |
  |---------+---------+---------+------+-------+--------+-----------+-----------+-------+--------+------------|
  | EQ      | x       |         |      |       |        |           |           |       |        |            |
  | EQL     | x       | x       | x    |       |        |           |           |       |        |            |
  | EQUAL   | x       | x       | x    | x     | x      | x         | x         |       |        |            |
  | EQUALP* | x       | x       | x    | x     | x      | x         | x         | x     | x      | x          |
  * chars of the same letter
    strings case insensitive
    numbers same with different type
- (char) can get a character from a string
- (hash-table-count) N elements on the hashtable
  - EQ, ~EQL~, EQUAL, EQUALP are the available hashtable tests
- &rest, if passed no arguments returns NIL (not '(nil))
- &key, if passes twice a keyword, it uses the first one
- &rest must come before &key
  - if no keyword passed NIL
  - if a keyword is passed it will get the keyword and the value
- (function) will return the function named the argument (macro, not need to quote a symbol)
  #' is the syntax sugar
- (apply FUNCTION LIST) applies the FUNCTION to the LIST of arguments
  (apply FUNCTION ARG? ARG? LIST)
- strings are vector/arrays/vectors of characters
- (search) to find a string (sequence) into another
- (defstruct (NAME (:conc-name ALIAS)) is used to define the acessor with a different prefix
- (defstruct (NAME (:include   OTHERS)) is used to define the a struct to compose with
  both accessor can be used
  on copy, setting the slots will keep them different, but shared structures are different (the content of the slots)
- (dolist)      returns a value
  (dotimes) can return a value, named on the third argument
  (do)      is kind-sort-of a for loop, 1) bindings 2) termination test 3) epilogue 4) code to run
  1) test being "UNTIL" not "WHILE" test passes
  2) epilogue might return a value, right after the test, enclosed on the same same s-expression
- (loop), by defaults loops forever, can break from it with (return)
  you might make it look lispy
  #+begin_src lisp
(let ((counter 0))
  (loop (incf counter)
      (when (>= counter 100)
         (return counter)))
    #+end_src
- Not all vectors that contain characters are strings
- to TRANSPOSE a list of lists, you can use
  (apply #'mapcar #'list lists)
- (numbers '(1 2 3 4 5))
  (assert-equal '((((1 . 2) . 3) . 4) . 5) (reduce #'cons numbers))
  (assert-equal '(1 2 3 4 . 5) (reduce #'cons numbers :from-end t)))
- (loop)
  :in iterates over each element on the list
  (assert-equal '(:a :b :c) result-in)
  :on iterates over each (cons) cell on the list
  (assert-equal '((:a :b :c) (:b :c) (:c)) result-on)
- (loop)
  :for KEY :being :the :hash-keys :of HASHTABLE
  :using (hash-value VALUE)
- (loop)
  :count VARIABLE :into VARIABLE
  :sum   VARIABLE :into VARIABLE
  :maximize
  :minimize
- (loop) destructuring
  :for (a b) :in '((1 2) (3 4))
- (format)
  ~A for "aesthetic", :keyword into KEYWORD, char #\C into C
  ~S for "standsard", prints them with escaped characters, KEYWORD into :KEYWORD
  ~B, ~O, ~D, ~X and ~R (for customem radix) are radix for numbers, works with lists of numbers or operations
- (format)
  "~{~}" to iterate over a list
  (assert-equal "[1][2][3][4][5][6]" (format nil "~{[~A]~}" '(1 2 3 4 5 6)))
  (assert-equal "[1 2][3 4][5 6]" (format nil "~{[~A ~A]~}" '(1 2 3 4 5 6)))
  ~^, abords iteration when no more available
  (assert-equal "[1], [2], [3], [4], [5], [6]" (format nil "~{[~A]~^, ~}" '(1 2 3 4 5 6)))
  "~(~)", lowercases what is inside
  "~:(~)", uppercase first letter of each word
  "~@(~)", uppercase only the first letter of the sentence
  "~:@(~)", uppercase all
- Every object is of type T, no object is of type NIL
- 'nil is nil
- type of nil is 'NULL
- '() is list, atom, null, t
- Integers are either FIXNUM or BIGNUM
- (subtypep)
- ATOM are anything are are not cons
- (functionp)
* Youtube
- Common LISP Object Standard
  https://www.youtube.com/watch?v=IrmHp1rRQ68
- Lisp NYC
  https://vimeo.com/lispnyc
  https://www.youtube.com/channel/UCv33UlfX5S4PKxozGwUY_pA
- Patrik Stein -  https://vimeo.com/nklein
- ELS https://www.youtube.com/channel/UC55S8D_44ge2cV10aQmxNVQ/
- MIT 6.001 Structure and Interpretation, 1986
  https://www.youtube.com/playlist?list=PLE18841CABEA24090
- kraklisp https://www.youtube.com/channel/UCymtXMj1M7cKiV9TKLoTtEg
- INF4820 https://www.youtube.com/c/INF4820/
- Baggers https://www.youtube.com/user/CBaggers
- Neil Munro https://www.youtube.com/user/njalmunro
- Allegro CL https://www.youtube.com/c/FranzAllegroCL/
- Fare https://www.youtube.com/c/Fran%C3%A7oisRen%C3%A9Rideau/
- "afp" https://www.youtube.com/channel/UCYg6qFXDE5SGT_YXhuJPU0A/
** AFP Concurrency on Lisp - https://www.youtube.com/watch?v=3c7LwUjb-DU
- Bourdeux Threads
  - Initial bindings, to control the local environment.
  - Locks: (with-lock-held ())
  - Recursive locks: multiple operations on the same thread, take/release/take/release..
  - Semaphores: "a thread safe counter", signal and wait
  - Condition Locks: A lock + A conditional variable (not thread safe)
- Atomics
  - incf: use a cons and FIXNUM
  - cas: COMPARE-AND-SWAP on sbcl works on (slot-value)
- Memory order, "it prevents re-ordering across the fence"
  - (sb-thread:barrier)
- lparallel: channels/workers support, priority, queue, pmap, promises
