- http://sordina.github.io/blog/2021/01/03/1609638326-advent19b.html
- Usage Examples of Haskell https://homepages.inf.ed.ac.uk/wadler/realworld/
- https://hackage.haskell.org/package/rio
  https://www.fpcomplete.com/haskell/library/rio/
- CIS194 https://www.cis.upenn.edu/~cis194/fall16/lectures/01-intro.html
  CS240 2016 http://www.scs.stanford.edu/16wi-cs240h/
  CS240 2014 http://www.scs.stanford.edu/14sp-cs240h/
  CS240 code https://github.com/Chouffe/cs240
- Streamers https://github.com/chiroptical/declarative-programming-streams
- Streamer https://www.youtube.com/c/cvladfp/videos
- Memory Usage https://stackoverflow.com/questions/459725/how-to-reduce-memory-usage-in-a-haskell-app
- FPGA Clash Talks https://unsafeperform.io/talks/
- Book: Retrocomputing with Clash: Haskell for FPGA Hardware Design
  https://unsafeperform.io/retroclash/
- https://github.com/reanimate/reanimate
- Haskell via Sokoban - Tutorial - https://haskell-via-sokoban.nomeata.de/
- Learn Haskell making a static blog generator - https://soupi.github.io/learn-haskell-blog-generator/
- https://crypto.stanford.edu/~blynn/haskell/
- https://leanpub.com/haskell-cookbook/read
- https://www.youtube.com/channel/UCNp-DVb8cQRIOo32sZhWgNg
- cabal v2-repl exe:CABALPKGNAME -- give a ghci shell with all deps loaded
- https://hackage.haskell.org/package/base-4.14.0.0/docs/Prelude.html#g:5
- http://www.cis.syr.edu/~sueo/cis252/emacs.html
- https://hoogle.haskell.org/
- euterpea example http://donyaquick.com/interesting-music-in-four-lines-of-code/
- quickstart euterpea https://github.com/madjestic/nu/blob/02eb3957f9ba5d0f0fbac7cd260f7142227a7008/Projects/blogs/turtlesturtlesturtles/posts/2018-11-29-a-quick-start-with-Euterpea.md
- Euterpea Interactive-Haskell with Literate-Haskell https://github.com/lfborjas/distractions/blob/a6b6bcd09270fa73233b05f3afb1800b977da9c3/haskell_school_of_music/README.md
- https://github.com/graninas/software-design-in-haskell
- https://kowainik.github.io/posts/haskell-mini-patterns
- https://github.com/kowainik/learn4haskell
- https://en.wikipedia.org/wiki/Dependent_type
- https://en.wikipedia.org/wiki/Generalized_algebraic_data_type
- https://github.com/omelkonian/AlgoRhythm (music)
- Making Algorithmic Music
  Compose NYC 2019
  Speaker: Donya Quick
  https://www.youtube.com/watch?v=9Fg54XAr044
- Haskell MOOC University of Helsinki
  https://haskell.mooc.fi/material/
  https://github.com/moocfi/haskell-mooc
- 2011
  Stanford CS240h, Functional Systems in Haskell
  https://github.com/bos/stanford-cs240h
  http://www.scs.stanford.edu/11au-cs240h/notes/
- https://github.com/hzlmn/haskell-must-watch
* Personalities
** Simon Peyton-Jones
- haskell comitee on design
** Philip Wadler
- haskell comitee on design
* Backend Web Programming in Haskell - Tsoding
https://www.twitch.tv/videos/743607386
https://github.com/tsoding/tsoken/blob/master/src/Main.hs
* Setup
  - https://github.com/haskell/haskell-ide-engine
  - https://github.com/soupi/minimal-haskell-emacs (setup)
  - https://github.com/ndmitchell/ghcid "flymake"
  - https://github.com/ndmitchell/hlint "flycheck"
  - https://github.com/chrisdone/hindent "gofmt"
* Libraries
- A fast, light-weight web server for WAI applications.
  https://hackage.haskell.org/package/warp
  https://hackage.haskell.org/package/wai
- REST - A family of combinators for defining webservices APIs and serving them
  https://hackage.haskell.org/package/servant
- https://hackage.haskell.org/package/turtle-1.5.21/docs/Turtle-Tutorial.html
- Conduit is a framework for dealing with streaming data, such as reading raw bytes from a file, parsing a CSV response body from an HTTP request, or performing an action on all files in a directory tree. 
  https://github.com/snoyberg/conduit
- It is defined as a monad transformer that can be stacked on arbitrary monads, and it is also parametric in the input stream type.
  https://hackage.haskell.org/package/parsec
- State of the Haskell ecosystem
  https://github.com/Gabriel439/post-rfc/blob/master/sotu.md
* Learn
  - https://github.com/bitemyapp/fp-course
  - https://github.com/hmemcpy/milewski-ctfp-pdf
  - CIS 194: Introduction to Haskell (Spring 2013)
    https://www.seas.upenn.edu/~cis194/spring13/lectures.html
  - https://threadreaderapp.com/thread/1277615394560360449.html
  - https://github.com/Kuratoro/haskell.zettel.page/blob/master/2012502.md
  - Applied Haskell is a commercial training program focusing on teaching intermediate Haskell.
    https://www.fpcomplete.com/haskell/syllabus/
  - http://learnyouahaskell.com/chapters
  - https://www.reddit.com/r/haskell/comments/d5og5n/which_book/
  - https://github.com/i-am-tom/haskell-exercises (extensions)
  - https://github.com/caiorss/Functional-Programming
  - What I Wish I Knew When Learning Haskell
    http://dev.stephendiehl.com/hask/
  - https://kowainik.github.io/posts/haskell-mini-patterns
  - https://github.com/soupi/haskell-study-plan
  - https://github.com/alpacaaa/zero-bullshit-haskell
  - https://github.com/tssm/up-to-date-real-world-haskell
  - https://github.com/graninas/software-design-in-haskell
  - https://github.com/bitemyapp/learnhaskell
* Videos
** Tsoding
- Haskell AMA https://www.twitch.tv/videos/736842835
- Haskell > JavaScript https://www.twitch.tv/videos/750508584
- Functional Programming in Production https://www.twitch.tv/videos/757306194
- [Discord + Twitch] Double Platform ... https://www.twitch.tv/videos/764093623
- Backend Web Programming in Haskell https://www.twitch.tv/videos/743607386
** Courses
   - https://github.com/hzlmn/haskell-must-watch
   - Functional Programming in Haskell: Professor Graham Hutton from the University of Nottingham.
     https://www.youtube.com/playlist?list=PLF1Z-APd9zK7usPMx3LGMZEHrECUGodd3
   - Haskell for imperative programmers
     https://www.youtube.com/channel/UC3xdLFFsqG701QAyGJIPT1g/videos
   - Haskell Summer Course
     https://www.youtube.com/playlist?list=PLaAHmR4OoQXcrQl7kgkraWQAgQ-8FpEmS
   - 2018 Haskell School in the Networked Imagination Laboratory
     https://www.youtube.com/playlist?list=PLyEzdf4cdMMHGqVnAzLV8eDXn6Ajj46JA
   - Haskell : Learn You a Haskell for Great Good
     https://www.youtube.com/playlist?list=PLS6urCrsYES24Fwzg5-Uga1QEbNm9kiU_
   - Haskell for Imperative Programmers
     https://www.youtube.com/playlist?list=PLe7Ei6viL6jGp1Rfu0dil1JH1SHk9bgDV
   - Haskell - Functional Programming Fundamentals (Dr. Erik Meijer)
     https://www.youtube.com/playlist?list=PLoJC20gNfC2gpI7Dl6fg8uj1a-wfnWTH8
   - Programming with Categories
     http://brendanfong.com/programmingcats.html
     https://www.youtube.com/playlist?list=PLhgq-BqyZ7i7MTGhUROZy3BOICnVixETS (category theory)
** Livecoding
   - Barry (haskell book) https://www.youtube.com/channel/UCndlCtPeYygdGZ9UUKdehbw

** other
  - Zürich Friends of Haskell
    https://www.youtube.com/channel/UC2zfPMH_srjxUN5EYrfIhCw
  - Jappie Klooster
    https://www.youtube.com/channel/UCQxmXSQEYyCeBC6urMWRPVw/videos
  - HaskellRank (tsoding)
    https://www.youtube.com/playlist?list=PLguYJK7ydFE4aS8fq4D6DqjF6qsysxTnx
  - lenses
    https://www.youtube.com/watch?v=cefnmjtAolY
    https://docs.google.com/file/d/0ByK3AAy5ubqady1YczU2UEYzODQ/edit
  - Jeremy Gibbons: Algorithm Design with Haskell
    https://www.youtube.com/watch?v=JJv74IJUp4E
  - NYC Haskell User's Group
    https://www.youtube.com/channel/UCzNYHE7Kj6pBqq5h8LG9Zcg
* DONE Book: Seven Languages in 7 weeks
** Haskell
- "In Haskell, indentation is significant." (?
- on Haskell, IF is a function, not a control structure, it returns a value.
- "." for function composition
  second = head . tail
- On ghci console
  > :set +t
- A partial applied function is called ~section~
- ~where~ on function definition can define local functions too
- every function does have 1(one) parameter
  - the process of reducing a function of N parameters to N of 1 param is ~currying~
#+NAME: single-line vs multi-line pattern-matching vs guards
#+begin_src haskell
fact x = if x == 0 then 1 else fact (x - 1) * x

factorial :: Integer -> Integer
factorial 0 = 1
factorial x = x * factorial (x - 1)

factorio :: Integer -> Integer
factorio x
  | x > 1     = x * factorio (x - 1)
  | otherwise = 1
#+end_src
* TODO Book: Haskell School of Music
** 1 Computer Music, Euterpea, and Haskell
*** 1.1 The Note versus Signal Dichotomy
- High/Low    level music concepts a.k.a.
  Note/Signal level music concepts
- Note: pitch and volume
- Bit depth: storage size of a single sample.
  Typically 16bits (2bytes) or 32bits (4bytes)
*** 1.2 Basic Principles of Programming
- Measures of success: correctness, efficiency, clarity
- Code often represents the author's thought process...A conventional
  musical score does not.
*** 1.3 Computation by Calculation
- In general, it is best to search first for an elegant (and correct!) solution to a problem, and later refine it for better performance.
  “Get it right first!”
- ~unfolding~ a function, is when we replace the arguments in the definition
  simple x y z = x * (y + z)
  simple 3 9 5
  > 3 * (9 + 5)
  > 42
- "simple 3 9 5 ~evaluates~ to 42"
*** 1.4 Expressions and Values
- note names are called pitch classes
- ~expressions~ entities that can be evaluated
- ~value~ are expressions that cannot be further evaluated.
  ex: 1,[1,2],(3,3),'C',"hello"
- ~diverging~ expressions are those that do not have an end
  ex: f x = f (x - 1)
  evaluate to "Bottom" value _|_
*** 1.5 Types
- Atomic or Structured
- Type Signature
  'D' :: Char
      :: reads as "has type"
   D  :: PitchClass
- Elements on a List are the same Type
- Elements on a Tuple could be different Types
*** 1.6 Function Types and Type Signatures
#+begin_src haskell
simple :: Int -> Int -> Int -> Int
simple x y z = x * (y + z)
#+end_src
- "it is a good habit to first write down the type of each function you
   are planning to define, as a first approximation to its full specification"
- f :: T1 -> T2 -- In mathematics T1 is the ~domain~ and T2 is the ~range~
- ~function application~ aka calling the funtion, has always higher precedence on application
- symbol based functions are usually called ~operators~ and are ~infix~
  - Are defined between parentheses
  - (+) :: Integer -> Integer -> Integer
- ' is a valid alphanumeric value, so f' and f'' are valid function names
*** 1.7 Abstraction, Abstraction, Abstraction
- “What are the three most important ideas in programming?" (see title)
**** 1.7.1 Naming
#+begin_src haskell
pi :: Double
pi = 3.1415
-- two definitions in one
concertA,a440 :: (PitchClass, Octave)
concertA = (A,4)
a440     = (A,4)
-- Vars
c = 42 -- is called a ~binding~
x    = let area = pi * r ** 2
       in f area + g area
#+end_src
- A4 is usually called "concert A" (because it is often used as a the note to which an orchestra
  tunes its intruments or "A440")
- {- MULTILINE COMMENT IN HASKELL -}
**** 1.7.2 Functional Abstraction
#+begin_src haskell
x = let areaF r = pi * r ** 2
    in f (areaF r1) + g (areaF r2)
note :: Dur -> Pitch -> Music Pitch
rest :: Dur -> Music Pitch
(:+:) Music Pitch -> Music Pitch -> Music Pitch -- Sequentially
(:=:) Music Pitch -> Music Pitch -> Music Pitch -- Simultanious
trans :: Int -> Pitch -> Pitch
-- Harmonizing each pN note with a third
qn = 1/4
mel = (note qn p1 :=: note qn (trans (-3) p1)) :+:
      (note qn p2 :=: note qn (trans (-3) p2)) :+:
      (note qn p3 :=: note qn (trans (-3) p3))
-- In a function
hNote :: Dur -> Pitch -> Music Pitch
hNote d p = note d p :=: note d (trans (-3) p)
-- applied
mel :: Music Pitch
mel = hNote qn p1 :+: hNote qn p2 :+: hNote qn p3
#+end_src
**** 1.7.3 Data Abstraction
- The order of ~associativity~ can be defined, either left, right or none.
- (:) operator has right associativity
#+begin_src haskell
hList          :: Dur -> [Pitch] -> Music Pitch
hList d []     = rest 0
hList d (p:ps) = hNote d p :+: hList d ps
--
mel = hList qn [p1,p2,p3]
#+end_src
*** 1.8 Haskell Equality versus Musical Equality
- 2 different melodies can be musically equivalent while being not equal by the language
- A melody can be interpreted either by his
  ~polyphonic~: grouping notes playing at the same time
  ~contrapuntal~: grouping by each voice
*** 1.9 Code Reuse and Modularity
- being able to re-use code is called ~modularity~
*** 1.10 [Advanced] Programming with Numbers 1
- Int data type is of size word (architecture dependent, 32 or 64 bits) (use Integer instead)
- In mathemathics, ~numerical analisys~ is concerned with numerical incongrueties
- If real-number acuraccy is important, be wary of floats
#+begin_src haskell
5 ∗ (−0.123456 + 0.123457)       :: Float ⇒ 4.991889e−6
5 ∗ (−0.123456) + 5 ∗ (0.123457) :: Float ⇒ 5.00679e−6
#+end_src
** 2 Simple Music
*** 2.1 Preliminaries
#+begin_src haskell
-- Type Synonyms
type Octave = Int
type Pitch  = (PitchClass, Octave)
type Dur    = Rational
-- Algebraic data type
data PitchClass = Cff | Cf | C | Dff | Cs | Df | Css | D | Eff | Ds
                | Ef | Fff | Dss | E | Ff | Es | F | Gff | Ess | Fs
                | Gf | Fss | G | Aff | Gs | Af | Gss | A | Bff | As
                | Bf | Ass | B | Bs | Bss
qn :: Dur
qn = 1/4
#+end_src
- data NAME = CONSTRUCTORS
  data Bool = False | True
*** 2.2 Notes, Music, and Polymorphism
#+begin_src haskell
-- (Value) Constructor
data Primitive = Note Dur Pitch |
                 Rest Dur
-- Type Constructor: more generic, polymorphic
data Primitive a = Note Dur a |
                   Rest Dur
-- Note :: Dur -> a -> Primitive a
-- Rest :: Dur ->      Primitive a
--
-- Another ~type constructor~, this time also recursive (aka inductive data type)
data Music a =
    Prim (Primitive a)
  | Music a :+: Music a
  | Music a :=: Music a
  | Modify Control (Music a)
-- Prim   :: Primitive a        -> Music a
-- (:+:)  :: Music a -> Music a -> Music a
-- (:=:)  :: Music a -> Music a -> Music a
-- Modify :: Control -> Music a -> Music a
#+end_src
- ~fixity declaration~
  infixr 5 :+:,:=:
- Data constructors
  - are still functions and have a type
  - are an example of polymorphic functions ~type abstraction~
#+begin_src haskell
data Control =
    Tempo      Rational          -- scale the tempo
  | Transpose  AbsPitch          -- transposition
  | Instrument InstrumentName    -- instrument label
  | Phrase     [PhraseAttribute] -- phrase attributes
  | KeySig     PitchClass Mode   -- key signature and mode
  | Custom     String            -- custom label
data Mode = Major | Minor | Ionian | Dorian | Phrygian | Lydian
             | Mixolydian | Aeolian | Locrian
             | CustomMode String
data InstrumentName = AcousticGrandPiano | BrightAcousticPiano ...
#+end_src
*** 2.3 Convenient Auxiliary Functions

*** 2.4 Absolute Pitches
- LIST !! N
  [C,D,E] !! 1 => D
** 3 Polymorphic and high order functions
- head, tail, length (examples of simple polymorphic types)
- map
- append (++)
- fold
  foldr, foldl: only difference is from which side is applied the operator, sometimes might be more performant from one side over the other
  foldr1, foldl1: versions that error on empty lists, so no init value needed
- `` functions into operator with backquotes
- () operator into a function with parentheses
- reverse, (algorithm with foldl)
- ~currying~
- currying simplification
  f x = g x
  f   = g
** 4
*** 4.2 Modules
- Module names are capitalized
  Can be hierachical
  import LIBRARY.FOLDER.MODULE
- module MODULE where
  module MODULE (EXPORT,EXPORT) where
*** 4.3 Transcribing a More Complex Score
**** 4.3.1 Auxiliary Functions
- Haskell does not permit pattern-matching against function applications.
  myFunction (Prim (Note d p)) = -- OK
  myFunction (note d p)        = -- FAIL
- times :: Int -> Music a -> Music a -- repeats
  addDur
  graceNote
- The only special cases that will not be handled using auxiliary functions are:
  1) the single staccato on note four of bar fifteen
  2) the single portamento on note three of bar sixteen.
  These situations will be addressed differently in a later chapter.
*** 4.4 Simple Algorithmic Composition

* TODO Book: Real World Haskell
- Updated code version https://github.com/tssm/up-to-date-real-world-haskell/
- Real World Haskell outdated parts https://stackoverflow.com/questions/23727768/which-parts-of-real-world-haskell-are-now-obsolete-or-considered-bad-practice
** 6 Using Typeclasses
*** Defining
- Different implementation depending on the type of data given.
- Defining a new ~Typeclass~ named "BasicEq3".
  We can provide *default implementations* for Typeclasses, and make one depend on the other.
#+begin_src haskell
class BasicEq3 a where
  isEqual3 :: a -> a -> Bool
  isEqual3 x y = not (isNotEqual3 x y)

  isNotEqual3 :: a -> a -> Bool
  isNotEqual3 x y = not (isEqual3 x y)
#+end_src
- An ~Instance Type~ of this typeclass, is any type that implements the functions defined in it.
- isEqual :: BasicEq a => a -> a -> Bool
  Reads:
  "For all types of *a*,
   so long as *a* is an instance of BasicEq,
   isEqual takes two parameters of type *a* and returns Bool""
*** Type Instancing
#+begin_src haskell
instance BasicEq3 Color where
  isEqual3 Red   Red   = True
  isEqual3 Green Green = True
  isEqual3 Blue  Blue  = True
  isEqual3 _     _     = False
#+end_src
*** Build-in
- Show, and the function show which returns a string from something showable
  show :: (Show a) => a -> String
  (you can derive it or explicitly Type Instance it)
  - To define your own show redefine ~show~
- Read, and the function read which takes a string and returns something readable
  read :: (Read a) => String -> a
  e.g. (read readVar)::Double
  - To define your own parser redefine ~readsPrec~
** 7
- ~Type classes~ provide ad-hoc polymorphism
  - Can define default "implementations" for the class
- ~Types~ are made instances of a particular type class
- Typeclasses
  - Show: Used to display your custom types. ghci repl uses it.
    #+begin_src haskell
data Color = Red | Green | Blue

instance Show Color where
  show Red = "rojo"
  show Green = "verde"
  show Blue = "azul"
    #+end_src

* TODO Book: The Haskell School of Expressive Language
** 3 Simple Graphics
*** 3.1 Basic Input/Output
- ~Standard Prelude~ and ~Standard Libraries~
- () is called ~unit type~, ans has only () as value
- IO
  There is a special kind of ~value~ called ~action~.
  It won't try to display it but it will take action.
  Ex: writing to a file or reading from keyboard.
  ~expressions~ or functions that evaluate to an action are called ~commands~
- IO () is often called a ~noop~, it is an action that returns ()
- putStr, putChar, writeFile, readFile, do, getLine
- ??? you can put actions on a list, but won't "do" anything unless on a do or a main ???
- sequence applied to IO has this signature
  sequence :: [IO a] -> IO ()

*** 3.2 Graphics Windows
- sierpinsky
#+begin_src haskell
fillTri :: Window -> Int -> Int -> Int -> IO ()
fillTri w x y size =
  drawInWindow w
  $ withColor Green
  $ polygon [(x,y), (x + size, y), (x, y - size), (x,y)]

minSize :: Int
minSize = 8

sierpinskiTri :: Window -> Int -> Int -> Int -> IO ()
sierpinskiTri w x y size
  | size <= minSize = fillTri w x y size
  | otherwise       = let size2 = size `div` 2
                      in do sierpinskiTri w x y size2
                            sierpinskiTri w x (y - size2) size2
                            sierpinskiTri w (x + size2) y size2
#+end_src
- david star:
  1) draw a equilateral triangle
  2) draw a new one rotated 180
  3) do 1 and 2 for each corner, but with 1/3 of a triangle size
** 4 Shapes II: Drawing shapes
- Many indirect graphics functions, to:
  1) being able to work with each shape properties
** 5 Polymorphic and High-order Funtions
* Book: Haskell Tutorial and Cookbook
** 1
#+begin_src haskell
module Main where
module Main (main) where
#+end_src
- : concatenates Char to [Char]
- !! for list index access
- ++ concatenate lists
- length of tuples will always be one (1)
|       |       |           | destructuring     |   |
|-------+-------+-----------+-------------------+---|
| tuple | (A,B) | fst/snd   | let (a,b)=('a',1) |   |
| list  | [T]   | head/tail |                   |   |

* TODO Interview: Michael Snoyman: From Haskell to Rust?
  #+DATE: Sep 13, 2020
  #+URL: https://www.youtube.com/watch?v=HKXmEFvsi6M
- Creator of Yesod/Stack
- VP at "FP Complete"
- Moved away from GHCjs
  - Purescript/Halogen
- Rust, has recently has async/await (it was "callback hell")
- Monads reinventions??: promises (js), scala (futures)
- "GO says, we don't trust the developers. Or I don't wanna bother the programmers with stuff"
  - Like overload of operators
- TALK ABOUT MONADS????
- RESUME 20:00

* TODO Videos: HaskellRank by tsoding
  playlist: https://www.youtube.com/playlist?list=PLguYJK7ydFE4aS8fq4D6DqjF6qsysxTnx
** DONE HackerRank in Haskell
- interact :: (String -> String) -> IO ()
- We go from an expression that we can use on the repl to a function. By replacing ($) with (.)
- Functions: ($) (.) interact words read map sum show tail
#+begin_src haskell
main = interact $ show . sum . map read . words
main = interact $ show . sum . map read . tail . words
#+end_src
** DONE Grading Students
- (``) , guards, where, unlines
#+begin_src haskell
round5 :: Int -> Int
round5 x
    | x >= 38 && (m5 - x) < 3 = m5
    | otherwise               = x
    where m5 = x + (5 - x `mod` 5)

solve :: [Int] -> [Int]
solve xs = map round5 xs

main = interact $ unlines . map show . solve . map read . tail . words
#+end_src
** DONE Apples and Oranges
- take, drop, filter
#+begin_src haskell
let (x1:x2:xs) = [1,2,3,4,5,6,7] -- Pattern Matching
-- lambdas
map (\x -> x + 3) [0,1,2] -- => [3,4,5]
map (+ 3)         [0,1,2] -- => [3,4,5]
#+end_src
** DONE Code Warrior
- undefined :: t -- can be assigned to any type, useful to know if code just compiles
- !!
- div  :: Integral a => a -> a -> a
- even :: Integral a => a -> Bool
- odd  :: Integral a => a -> Bool
** DONE Between Two Sets
- foldl1, gcd, lcm, takeWhile
- [1 .. 4]
  [1 ..]
- Imperatively writing in Haskell
#+begin_src haskell
solve :: [Int] -> [Int] -> Int
solve = undefined

readIntList :: IO [Int]
readIntList = do line <- getLine
                 return $ map read $ words line
main = do [n, m] <- readIntList
          as     <- readIntList
          bs     <- readIntList
          putStrLn $ show $ solve as bs
#+end_src

** DONE Fold
- "Neutral element" on fold
#+begin_src haskell
Import Prelude hiding (foldl) -- Hide!!!

foldl :: (a -> b -> a) -> a -> [b] -> a
foldl f base []     = base
foldl f base (x:xs) = foldl f (f base x) xs

foldl1 :: (a -> a -> a) -> [a] -> a
foldl1 f []     = error "basaodka"
foldl1 f (x:xs) = foldl f x xs
#+end_src
** DONE Playing Basketball with Kangaroo
- maximum, minimum, inits, group
#+begin_src haskell
import Data.List
inits :: [a] -> [[a]]

λ> inits [1 .. 5]
[[],[1],[1,2],[1,2,3],[1,2,3,4],[1,2,3,4,5]]

λ> map maximum $ tail $ inits [10,5, 20, 4 ,5,2,25,1]
[10,10,20,20,20,20,25,25]

λ> group $ map maximum $ tail $ inits [10,5, 20, 4 ,5,2,25,1]
[[10,10],[20,20,20,20],[25,25]]
#+end_src
** DONE Purely Functional Solutions to Imperative Problems
*** 1
- zip
- List comprehension
#+begin_src haskell
[i     | i <- [1 .. 10]] -- [1,2,3,4,5,6,7,8,9,10]
[(i,j) | i <- [1 .. 10], j <- [1 .. 10]] -- cartesian product [(1,1),(1,2),(1,3)...]
[(i,j) | i <- [1 .. 10], j <- [1 .. 10], i /= 1] -- filter
---
-- Uses undefined as elements of an array, can also use ()
solve :: [Int] -> Int
solve (k:xs) =
  length [ undefined | (i, xi) <- zip [0 ..] xs,
                       (j, xj) <- zip [0 ..] xs,
                       i < j,
                       (xi + xj) `mod` k == 0]
#+end_src
*** 2
- group, sort, sortBy, on, compare, reverse, flip
- Ordening is the type that has 3 constructors: LT, EQ, GT
- You can compare numbers, or lists. But for special orders.
  compare :: Ord a => a -> a -> Ordering
  map compare [1,3,4]
- on basically adapts the first func with the second
  on :: (b -> b -> c) -> (a -> b) -> a -> a -> c
#+begin_src haskell
-- :m + Data.List
import Data.List     -- For sort
import Data.Function -- For on
sortBy (\x y -> compare (length x) (length y)) [[1,2,3,4],[2,2],[0,0,0,0,0,0,0]]
sortBy (compare `on` length)                   [[1,2,3,4],[2,2],[0,0,0,0,0,0,0]]
-- => [[2,2],[1,2,3,4],[0,0,0,0,0,0,0]]
sortBy (compare `on` length) $ group $ sort [1,4,4,4,5,5,5,3]
reverse $ sortBy (compare `on` length) $ group $ sort [1,4,4,4,5,5,5,3]
sortBy (flip compare `on` length) $ group $ sort [1,4,4,4,5,5,5,3]
-- => [[1],[3],[4,4,4],[5,5,5]]
#+end_src
** DONE Solving Russian Calendar Problems in Haskell
- sum, printf (alternative to ++)
- ~eta conversion~ of \x -> abs being equal to abs
#+begin_src haskell
import Text.Printf

leapDay :: Int -> String
leapDay = printf "12.09.%d"

normDay :: Int -> String
normDay = printf "13.09.%d"
#+end_src
** DONE The Usefulness of Maybe monad
- splitAt, maybe, replicateM, read
- a type called ~Maybe~ (Just, Nothing)
  a function ~maybe~ to unwrap it
- replicateM to perform a task Nth times and return in an array
#+begin_src haskell
import Control.Monad -- for replicateM

excludeNth :: Int -> [a] -> [a]
excludeNth n xs = left ++ tail right
    where (left, right) = splitAt n xs
-- excludeNth 5 [1..10]
-- => [1,2,3,4,5,7,8,9,10]

getList :: Read a -> IO [a] -- read any type of input
getList = do
  line <- getLine
  return $ map read $ words line
-- getList :: IO [Int]
-- 1 2 3 4
-- => [1,2,3,4]

solve :: Int -> [Int] -> Int -> Maybe Int
solve k bill b
    | b > actualPrice = Just (b - actualPrice)
    | otherwise = Nothing
    where actualPrice = (sum $ excludeNth k bill) `div` 2

main :: IO ()
main = do
  [[_, k], bill, [b]] <- replicateM 3 getList
  putStrLn $ maybe "Bon appetit" show $ solve k bill b
#+end_src
** DONE Tracking Hikes with Haskell
*** Hiking
- scanl, groupBy (Data.List), filter, all
- scanl (+) 0 [1 .. 4]
  => [0,1,3,6,10,15]
- groupBy (\x y -> x /= 0 && y /= 0) [0,1,2,3,4]
  groupBy, will iterate over the list by 2 elements at the time
           when the function returns false, it separates that group
- filter (all (< 0))
*** Drawing Book
- interact $ show . resolve . map read . words
** DONE Treating Lists as Monads
- fromMaybe, sortBy, listToMaybe, liftM2
- fromMaybe - Takes a default and a maybe
  fromMaybe 5 Nothing  => 5
  fromMaybe 5 $ Just 6 => 6
- sortBy (Data.List)
- listToMaybe (Data.Maybe) -- returns Nothing or Just of the head
- liftM2 (Control.Monad)
  let keyboards = [3,1]
  let drives = [5,2,8]
  liftM2 (,) keyboards drives
- ^ generates the same than list comprehension
  AKA the ~cartesian product~
- Changing to (+) instead adds then directly
  liftM2 (+) keyboards drives
- map read . words <$> getLine -- Threat the result of getLine as a functor
** Solving Magic Square using Functional Programming
#+begin_src haskell
type Square = [[Int]]
magic :: Square
magic = [[8,1,6],
         [3,5,7],
         [4,9,2]]

rot90 :: Square -> Square
rot90 = map reverse

pp :: Square -> IO ()
pp = putStrLn . unlines . map (unwords . map show)

#+end_src
** Brute-forcing all Magic Squares
** CodeWars Strikes Again

* TODO Videos: Haskell by Bartosz Milewski
  playlist: https://www.youtube.com/playlist?list=PL0pwx9zqJ9IamHxRXTf34dC3JeQ2oYmfJ
** DONE 1-1 => Why Haskell? https://www.youtube.com/watch?v=N6sOMGYsvFA
- Course based on "Parallel and concurrent programming" Oreilly book
- Based on math, lambda calculus
- Lists are the core DS while in other langs would be an array
** DONE 1-2 => Functions https://www.youtube.com/watch?v=ybba5tcOeEY
- keep the more reocurring thing simple
  - in morse code (? the letter "e" is just a dot
- ~function application~ is the strongest binding
  7 - f x y z - 1
- no variables in haskell, they are nonary functions
- write file
#+begin_src haskell
sqDist :: Num a => a -> a -> a
sqDist x y = x^2 + y ^2

main = print (sqDist 3 4)
#+end_src
- load foñe
#+begin_src haskell
> :l main.hs
> main
25
> :t sqDist
sqDist :: Num a => a -> a -> a
#+end_src
- there are things that are NOT expressable in haskell, that are left to the used (axioms)
- main :: IO ()
  print :: Show a => a -> IO ()
  putStrLn :: String -> IO ()
- ghci commands
  #+begin_src
  :l FILENAME
  :r reload
  :t expand type
  :q quit
  :i info
  #+end_src
- Num is a ~class of types~, Double is type
** DONE 2-1 => More Functions
- on tuples: fst, snd
- lowest possible binding is $
- (.) ~function composition~, very high precedence
- spaces kind of does't matter at times, precedence does
- sq . sqDist -- reads "sq after sqDist"
- the definition of a function is with a -> b -> c because
  - ~partial application~ happens automatically
- using a tuple as an argument, is not convenient for partial application
- polymorphism:
  - parametric: "it can handle values uniformly without depending on their type.
                 Parametric polymorphism is a way to make a language more expressive
                 while still maintaining full static type-safety."
                 ex: map function
  - adhoc: different behaviour for different types of arguments
- code
  #+begin_src haskell
main = print $ sqDist 3 4 -- using ($)

sqDist (x,y) = x^2 + y ^2 -- using ($) on a tuple
main = print $ sqDist $ (3,4)

sq x = x * x -- replacing parens
main = print $ sq $ 2 + 3
main = print $ sq (2 + 3)
main = print $ sq 2+3 -- NOT the same

dist pt = sqrt $ sqDist pt -- Partial Application in Function composition
dist = sqrt . sqDist
  #+end_src
** DONE 2-2 => Product data types https://www.youtube.com/watch?v=a6IkhX1zgXI
- ELM isn't lazy evaluated
#+begin_src haskell
inc x = 1 + x
inc x = (+) 1 x  -- () changes infix to prefix operator
inc   = (+ 1)    -- "x" cancells out
#+end_src
- partial application of an operator is called ~operator section~
- ~Void~ is type with no elements
- ~Unit~ is the "Singleton" Type denoted by "()", tuple of 0 elements
- Define a ~NEW type~ with:
  > data Unit = CONSTRUCTOR
              = U
  > data ()   = ()
    TYPE      = DATA
    CONSTRUCTOR CONSTRUCTOR
- Different namespace for types and data constructors
- Every constructor is a function (capitalized for some reason).
  > data Product a b = P a b
  > :t P
  P :: a -> b -> Product a b
- ~Destructuring~ happens with the Data Constructor
  > f (P x y) = x + y
- When you have more than 2 components, you are better using a ~record~ where fields are named
- 2 ways of constructing new data types??
** DONE 3-1 => Laziness https://www.youtube.com/watch?v=jWrRs-l8C1U
:set -Wall
:set -fforce-recomp
*** Kinds
- "In haskell we don't want to use many names, because the polute the namespace"
- ~*~ in type definitions means "any type"
- (,) is the data constructor for pair
- The Type Constructors have types and those types are called ~kinds~
- use ~:k~ to get the kind of the argument
#+begin_src haskell
> :t (,) -- Data Constructor
(,) :: a -> b -> (a, b)
> :k (,) -- Type Constructor
(,) :: * -> * -> *
#+end_src
- "If you define a data type in Haskell you can promote it to a kind"????
*** Lazyness
- Haskell by default is lazy evaluated
- ~:sprint~ prints a value WITHOUT evaluating it
- Haskell has ~polymorphic values~, so we need to type "x" here
#+begin_src haskell
> let x = 1 + 2 :: Int
> :sprint x
x = _
> x
3
> :sprint x
x = 3
#+end_src
- We can force eager evaluation by using ~seq~, it "sequences" the arguments, it evaluates the 1st before the 2nd
#+begin_src haskell
> let x = 2 + 3 :: Int
> let y = x + 1
> print (seq y ())
()
> :sprint y
y = 6
#+end_src
- ~swap~
#+begin_src haskell
> import Data.Tuple
> let z = swap (x,x+1)
> :sprint z
z = _
#+end_src
** 3-2 => Sum types https://www.youtube.com/watch?v=MagayXbH4oY
- Unlike product types, on ~sum types~ we can have either from a or b
  - In terms of sets is like a "discriminated union", aka "tagged union"
- "|" as in OR
- Either is used to return either an error or a valid output. We don't use a pair.
#+begin_src haskell
data Either a b = Left a | Right b
safeSqrt :: Either String Double -> Either String Double
safeSqrt (Left str) = Left str
safeSqrt (Right x) = if x < 0
                     then Left "Error"
                     else Right (sqrt x)
-- Alternative using case
safeSqrt sx =
    case sx of
        Left str -> Left str
        Right x -> if x < 0
                   then Left "Error"
                   else Right (sqrt x)
#+end_src
- What in other languages would be an "enumeration type" here is just another sum
  - data Bool = True | False
- Algebraic data types???
#+begin_src haskell
data X a = X a | Y Void -- a + 0 = a
type Y a = (a, ())      -- a * 1 = a
type Z a = (a, Void)    -- a * 0 = 0
#+end_src
** 4-1 => Recursion https://www.youtube.com/watch?v=F-nAAIH4e2s
- data List a = Nil | Cons a (List a)
- ~:~ Cons operator
- ~..~ range operator for lists
  [0..]         => PRINTSUNTILSTOP
  [0..4]        => [0,1,2,3,4]
  take 4 [0..]  => [0,1,2,3]
** 4-2 => Functors
** 5-1 => Monads
** 5-2 => The Monad Class
** 6-1 => IO Monad
** 6-2 => Parallellism and Concurrency
** 7-1 => The Eval monad
** 7-2 => Parallel sudoku solver, strategies, overview of Haskell parallelism.
** 8-1 => Concurrent Haskell, MVars
** 8-2 => Software Transactional Memory
* TODO Videos: Haskell 10X - Google TechTalks
  repo: https://github.com/google/haskell-trainings
** DONE Haskell 101 https://www.youtube.com/watch?v=cTN1Qar4HSw
- There is NO function that can go from impure to pure code
  f :: IO a -> a
- Going from pure to impure is ok
  f :: a -> IO a
- Strict evaluation: inner to outer
  Lazy evaluation: outer to inner (when needed you eval the arguments)
- Lazyness:
  - Memory pitfalls
  - IO and parallelism pitfalls: threads will just create the expressions, not evaluate them
  + Huge optimizations: compiler can re-arrange the code, simplify noop operations,
                        partially thanks to knowing about pure/impurity of a function
  + Great expressivity (e.g. infinite structures)
- Is NOT recommended to create your own operators.
- ($) lowest priority
- ~type synonyms~
  type Point = (Int, Int)
  type Map k v = [(k, v)] -- ~type parameters~
- ~data structures~
  - NO methods
  - NO modifiers (setters)
  - NO private members/slots
  - YES Constructors
- data
#+begin_src haskell
data None    = None
data Minutes = Minutes Int      -- Minutes 10
data Bool    = False   | True
data Maybe a = Nothing | Just a -- Just 10
data List  a =     Nil | Cell a (List a)
-- Records, named "fields". Fields are in the same namespace.
data User = User String Int
data User = User {
    userName :: String,
    userAge  :: Int
}
#+end_src
- Operators can be constructors
- Operators pattern matching CAN short-circuit
#+begin_src haskell
(&&) :: Bool -> Bool -> Bool
True && True = True -- does NOT short-circuit (comment this line)
True && y    = y    -- does short-circuit
x    && y    = False
#+end_src
- Deconstructor, pattern matching
#+begin_src haskell
data Minutes = Minutes Int
add :: Minutes -> Minutes -> Minutes
add (Minutes x) (Minutes y) = Minutes $ x + y
#+end_src
- "backslash because it kind of looks like a lambda"
- head is considered "bad design", as in some of the inputs panics
  also callled partial functions
- Point free style: is when we define functions without defining the arguments.
                    Because it doesn't use the (.) operator.
** Haskell 102 https://www.youtube.com/watch?v=Ug9yJnOYR4U
- If a library has 2 versions of a function, with (') is called "f prime".
  The one with the (') is ~eager~
  The one without the (') ~lazy~
- Type Constrains
- Cascading Maybe's, nested case's
- IO
  Can't apply regular functions
  Can't pattern match
  Can't get values from it

