* 20 | Learning React                  | Alex Banks
  https://github.com/MoonHighway/learning-react
** DONE 1 - Welcome to React
- Is a *small library* that doesn't come with everything you might need out of the box.
- Needs *webpack* to translate rom that code that looks like HTML
*** https://reactjs.org/blog/2013/06/05/why-react.html (this link?)
   - Not a MVC framework
   - Does not use template
   - Created .JSX https://reactjs.org/docs/jsx-in-depth.html
     - Syntatic sugar for the React.createElement(component, props, ...children)
     - Compiled with *Babel*
     - ...
   - The result of calling render() each time is compared with the prev for differences (aka *reconciliation*)
     Before updating the DOM.
   - You can do server side rendering (?) https://github.com/petehunt/react-server-rendering-example
*** A strong foundation (topics covered)
 - React Hooks: allows us to reuse stateful logic between components.
 - Suspense (& Hooks): helps with data fetching
   EXPERIMENTAL as of Sep 2021
   https://es.reactjs.org/docs/concurrent-mode-suspense.html
 - Also: routing, testing, server-side rendering
*** React's Past and Future
 - Created by Jordan Walke
 - 2011 Facebook
   2012 Instagram
   2013 OpenSource
   2015 Netflix
        React Native, for mobile applications
   2016 React Router, Redux, Mobx, for routing and state managment
   2017 React Fiber, rewrite of react's *rendering algorithm*, no public API changes
   2019 React Hooks, a way to add stateful logic across components.
        React Suspence, a way to optimize asynchronous rendering
 - "The V in MVC"
 - React's Blog https://reactjs.org/blog/2021/06/08/the-plan-for-react-18.html
*** Working with Files (npm)
 - React Developer Tools, browser addon that enables when a page is using React
 - Node.js would be used on Chapter 12, to build an Express server.
   - React is an npm library
   - To start from scratch
     > npm init -y
 - Yarn, alternative to *npm*. Released on 2016, by Facebook.
   > npm install -g yarn
   > yarn add package-name
   > yarn remove package-name
** DONE 2 - Javascript for React
*** (JS) History
- Released on 1995.
  1) used for  interactive elements
  2) added DHTML and AJAX
  3) added node.js
- ECMA - European Computer Manufacturers Association
  1) 1997
  2) 1998
  3) 1999, regex, string handling
  4) Never released
  5) 2009, new array methods, object properties, json support
  6) 2015
- Kangax Compatibility table
  http://kangax.github.io/compat-table/esnext/
*** Declaring variables
 - Declaring
   #+begin_src javascript
   var pizza = true;
   const pizza = true;
   let pizza = true;
   #+end_src
   - *var* keyworkd, not lexically scoped. Declaring it inside a *if/for*, would live outside it.
   - *const* keyword, since ES6
   - *let* keyword, lexically scoped
 - Strings templating, accepts whitespace (new lines)
   ${} takes any javascript that returns a value
   #+begin_src js
   console.log(lastName + ", " + firstName + " " + middleName);
   console.log(`${lastName}, ${firstName} ${middleName}`);
   ${new Date().getYear()}
   #+end_src
*** Creating Functions
**** Function *Declaration*
 #+begin_src js
 function logCompliment() {
   console.log("You're doing great!");
 }
 #+end_src
**** Function *Expression*, creating a function as a variable
 #+begin_src js
 const logCompliment = function() {
   console.log("You're doing great!");
 }
 #+end_src
**** Declarations are *hoisted*, while expressions not.
 Meaning you can invoke afunction before you write the function declaration.
**** functions can return *values*, or take *arguments*
 #+begin_src js
 const createCompliment = function(firstName, message) {
   return `${firstName}: ${message}`;
 }
 console.log(createCompliment("You're so cool", "Molly"));
 #+end_src
**** *Default parameters*, can be any type, not just strings
 #+begin_src js
 function logActivity(name = "ShaneConkey", activity = "skiing") {
   console.log(`${name} loves ${activity}`);
 }
 #+end_src
**** *Arrow functions*, the arrow points to what should be returned.
 - Can ommit the parens if only 1 argument.
 - Must use {} if more than 1 line.
   #+begin_src js
   const lordify = firstName => `${firstName} of Canterbury`;
   const lordify = (firstName, land) => `${firstName} of ${land}`;
   const lordify = (firstName, land) => {
     if (!firstName) {
       throw new Error("A firstName is required to lordify");
     }
     if (!land) {
       throw new Error("A lord must have a land");
     }
     return `${firstName} of ${land}`;
   }
   #+end_src
**** Returning *objects*
 - You should wrap the function with () parenthesis.
   #+begin_src js
   const person = (firstName, lastName) => ({
     first: firstName,
     last: lastName
   })
   #+end_src
**** Arrow functions, do NOT block the scope of *this*
 - You need to think how to combine arrow and no-arrow definitions.
   If I used arrow functions in both definitions. ~this~ would still be *Window {}*
   #+begin_src js
   const tahoe = {
     mountains: ["Freel", "Rose", "Tallac", "Rubicon", "Silver"],
     print: function(delay = 1000) {
       setTimeout(() => {
         console.log(this.mountain.join(", "));
       }, delay)
     }
   }
   #+end_src
*** Compiling Javascript
 - *Babel* allows to compile code using the lastest JS features, into JS understandable for most browsers.
   - Sometimes add "use strict" at the top, to run in strict mode.
   - There is also a Babel REPL: https://babeljs.io/repl
*** Objects and Arrays
**** Destructuring =objects=, affected too by the scoping of *const*, *let*
  #+begin_src js
  const sandwich = {
    bread: "dutch crunch",
    meat: "tuna",
    cheese: "swiss",
    toppings: ["lettuce", "tomato", "mustard"]
  };
  const { bread, cheese } = sandwich; // dutch crunch swiss
  const { hotness, cheese } = sandwich; //            swiss
  let   { bread, meat   } = sandwich; // dutch crunch tuna
  bread = "different";
  #+end_src
**** Can also destruct on function arguments =objects=, and nest it
  #+begin_src js
  const lordify = ({ firstName }) => {
    console.log(`${firstName} of Canterbury`);
  }
  const lordify = ({ spouse: { firstName } }) => {
    console.log(`${firstName} of Canterbury`);
  }
  #+end_src
**** Destructuring =arrays=, firth and nth-element
  #+begin_src js
  const [firstAnimal] = ["Horse","Mouse","Cat"]; // Horse
  const [,,thirdAnimal] = ["Horse","Mouse","Cat"] // Cat
  #+end_src
**** =Object= Literal Enhacement, making an object from vars. Makes the varnames the keys.
  #+begin_src js
  const name = "Tallac";
  const elevation = 9738;
  const funHike = { name, elevation };
  #+end_src
**** Declaring =object methods= with object literals enhancements, is not necessary to use the *function* keyword
  #+begin_src js
  const skier = {
    name,
    sound,
    powderYell() {
      let yell = this.sound.toUpperCase();
      console.log(`${yell} ${yell} ${yell}!!!`);
    },
    speed(mph) {
      this.speed = mph;
      console.log("speed:", mph);
    }
  }
  #+end_src
**** The =spread= operator (...)
 1) Combine the contents of *arrays*
    #+begin_src js
    const peaks = ["Tallac", "Ralston", "Rose"];
    const canyons = ["Ward", "Blacwood"];
    const tahoe = [...peaks, ...canyons];
    #+end_src
 2) Create a copy of an *array*, and perform mutatation on them.
    #+begin_src js
    const peaks = ["Tallac," "Ralston", "Rose"];
    const [last] = [...peaks].reverse();
    #+end_src
 3) Get the (rest) of the elements of an *array*.
     #+begin_src js
     const lakes = ["Donner", "Marlette", "Fallen Leaf", "Cascade"];
     const [first, ...others] = lakes;
     #+end_src
 4) Variadic *functions*, collect function arguments
    #+begin_src js
    function directions(...args) {
       let [start, ...remaining] = args;
       let [finish, ...stops] = remaining.reverse();
       console.log(`drive through ${args.length} towns`);
       console.log(`start in ${start}`);
       console.log(`the destination is ${finish}`);
       console.log(`stopping ${stops.length} times in between`);
       console.log(``);
    }
    directions("Truckee", "Tahoe City", "Sunnyside", "Homewood", "Tahoma");
    #+end_src
 5) To combine two *objects* into one
    #+begin_src js
    const morning = {
      breakfast: "oeatmeal",
      lunch: "peanut butter and jelly"
    };
    const dinner = "mac and cheese";
    const backpackingMeals = {
      ...morning,
      dinner
    }
    #+end_src
*** Async Javascript
 - Sync: while each operation is happening, nothing else is happening.
**** Simple =Promises= with Fetch
 #+begin_src js
 fetch("https://api.randomuser.me/?nat=US&results=1")
   .then(res => console.log(res.json()))
   .then(json => json.results)
   .then(console.log)
   .catch(console.error);
 #+end_src
 - fetch(), returns a promise
   a *promise* is an object that represents whether the async operations:
   - is pending
   - has been completed
   - or has failed
 - .then(), takes a callback function that will run if and when the previous operation was successful.
 - Whathever you return from then() becomes the argument on the next then, so you can chain them
**** Async/Await, another wait to handle Promises
 #+begin_src js
 const getFakePerson = async () => {
   try {
     let res = await fetch("https://api.randomuser.me/?nat=US&results=1");
     let { results } = res.json();
     console.log(results);
   } catch (error) {
     console.error(error);
   }
 };
 getFakePerson();
 #+end_src
 - Prefered by some due it looks more familiar, like code that's found in synchronous funcion.
 - Async functions can be told to wait for the promise to resolve
   before further executing any code found in the function
 - When using async/await, you NEED to surround your promise on a try/catch to handle unresolved errors
**** =new Promise()=
 #+begin_src js
 const getPeople = count =>
   new Promise((resolves, rejects) => {
     const api = `https://api.randomuser.me/nat?US&results${count}`;
     const request = new XMLHttpRequest();
     request.open("Get", api);
     request.onload = () =>
       request.status == 200
         ? resolves(JSON.parse(request.response).results)
         : reject(Error(request.statusText));
     request.onerror = err => rejects(err);
     request.send();
   });

 getPeople(5)
    .then(members => console.log(members))
    .catch(error => console.error(`getPeople failed: ${error.message}`))
 #+end_src
*** Classes
 - React started by leaning on classes, but nowadays they start to moving away from using them.
 - JS uses something called ~prototypical inheritance~
   #+begin_src js
   function Vacation(destination, length) {
     this.destination = destination;
     this.length = length;
   }
   Vacation.prototype.print = function() {
     console.log(this.destination + " | "  + this.length + " days");
   };
   const maui = new Vacation("Maui", 7);
   maui.print();
   #+end_src
 - and ES2015 added syntactic sugar for it (class name is Capitalized)
   #+begin_src js
   class Vacation {
     constructor(destination, length) {
       this.destination = destination;
       this.length = length;
     }
     print() {
       console.log(`${this.destination} will take ${this.length} days.`);
     }
   }
   #+end_src
 - Clases can be ~extends~, they inherit the methods. Use *super* to call parent method.
   #+begin_src js
   class Expedition extends Vacation {
     constructor(destination, length, gear) {
       super(destination, length); // parent constructor
       this.gear = gear;
     }
     print() {
       super.print();
       console.log(`Bring your ${this.gear.join(" and your ")}`);
     }
   }
   #+end_src
*** ES6 Modules
 - One file per module
   Can be used on any JS type: primitives, objects, arrays, and functions.
 - Exporting multiple objects, notice the lack of ~;~
   #+begin_src js
   export const print = (message) =>
     log(message, new Date())
   export const log = (message, timestamp) =>
     console.log(`${timestamp.toString()}: ${message}`)
   #+end_src
 - Exporting a (1) single main variable.
   #+begin_src js
   export default new Expedition("Mt.Freel", 2, ["water", "snack"]);
   #+end_src
 - Importing
   #+begin_src js
   import { print, log }           from "./text-helpers";
   import freel                    from "./mt-freel";
   import { print as p, log as l } from "./text-helpers";
   import * as fns                 from './text-helpers'
   #+end_src
*** CommonJS (nodejs)
 - Module pattern, supported by NodeJS. Also supported by Babel and webpack.
   #+begin_src js
   module.exports = {print, log}
   #+end_src
 - No ~import~ statement, uses ~require~
   #+begin_src js
   const { log, print } = require("./txt-helpers");
   #+end_src
** DONE 3 - Functional Programming with Javascript
*** What it means to be Functional (first class functions)
 - In javascript, functions can represent data in you application.
   In javascript, functions are variables.
 - We can add functions to objects.
   #+begin_src js
   const obj = {
     message: "They can be added to objects like variables",
     log(message) {
       console.log(message);
     }
   };
   obj.log(obj.message);
   #+end_src
 - We can add functions to arrays (mixed arrays too, yikes)
   #+begin_src js
   const messages = [
     "They can be inserted into arrays",
     message => console.log(message),
     "like variables",
     message => console.log(message)
   ]
   #+end_src
 - Can be send as arguments
   #+begin_src js
   const insideFn = logger => {
     logger("They can be sent to other functions as arguments");
   };
   insideFn(message => console.log(message);
   #+end_src
 - Can be returned
   #+begin_src js
   const createSream = function(logger) {
     return function(message) {
       logger(message.toUpperCase() + "!!!");
     };
   };
   const scream = createScream(message => console.log(message));
   scream("functions can be returned from other functions")
   scream("createScream returns a function");
   scream("scream invokes that returned function");
   #+end_src
 - If you use arrow function declaration, and you see more than 2 arrows, this means that you're useing a higher-order function
*** Imperative VS Declarative
 *Funcional programming* is part of a larger programming paradigm: *declarative programming*
 - Imperative
   #+begin_src js
   const string = "Restaurants in Hanalei";
   const urlFriendly = "";
   for (var i = 0; i < string.length; i++) {
     if (string[i] == " ") {
       urlFriendly += "-";
     } else {
       urlFriendly += string[i];
     }
   }
   console.log(urlFriendly);
   #+end_src
 - Declarative
   #+begin_src js
   const string "Restaurants in Hanalei";
   const urlFriendly = string.replace(/ /g, "-");
   console.log(urlFriendly);
   #+end_src
 - http://wiki.c2.com/?DeclarativeProgramming
 - React Component, declaratively creating a DOM
   #+begin_src js
   const { render } = ReactDOM;
   const Welcome = () => {
     <div id="welcome">
       <h1>Hello World</h1>
     </div>
   };
   render(<Welcome />, document.getElementById("target"));
   #+end_src
*** Functional Concepts
**** Immutability
 - In FP, data is immutable. It never changes.
 - In Javascript, function arguments are ~references~ to the actual data.
   Immutable version:
   #+begin_src js
   const rateColor = function(color, rating) {
     return Object.assign({}, color, { rating: rating });
   };
  #+end_src
 - Object.assign()
   1) creates a new object
   2) copies 2nd argument object into it
   3) updates 3rd argument property into new object
 - Arrow + Spread
   #+begin_src js
   const rateColor = (color, rating) => ({
     ...color,
     rating
   });
   #+end_src
 - Immutable array, .concat() instaed of .push()
   #+begin_src js
   const addColor = (title, array) => array.concat({ title });
   const addColor = (title, array)  => [...array, { title }]
   #+end_src
**** Purity
 - Pure Functions
   1) Always take at least 1 (one) argument.
   2) Return a value that's computed based on its arguments.
   3) Do not cause *side effects*, change global variables, or change anything about the application state.
   4) Treat their argumetns as immutable data.
 - React's Pure Function, is responsability of something else, add it to the DOM
   #+begin_src js
   const Header = props => <h1>{props.title}</h1>
   #+end_src
**** Data Transformation
 - !==
 - Array (methods)
   .map(), can produce an array of objects, values, arrays, other functions...any javascript
   .reduce()
   .join()
   .filter() over .pop() or .splice()
 - Ternary operator (?:)
   #+begin_src js
   const editName = (oldName, name, arr) =>
     arr.map(item => (item.name === oldName ? {...item, name} : item));
   #+end_src
 - Object to array with ~Object.keys()~
   #+begin_src js
   const schools = {
     Yorktown: 10,
     "Washington & Liberty": 2,
     Wakefield: 5
   };
   const schoolArray = Object.keys(schools).map(key => ({
     name: key,
     wins: schools[key]
   }));
   #+end_src
 - Using *reduce* to transform an array into a single value OR single object
 - Using *reduce* to transform an array into a different array (!!!)
   ME: the reduce function receives, an *accumulator* and a *element*
   #+begin_src js
   const colors = ["red", "red", "green", "blue", "green"];
   const uniqueColors = colors.reduce(
     (unique, color) =>
       unique.indexOf(color) !== -1 ? unique : [...unique, color],
     []
   );
   #+end_src
**** Higher-Order Functions
 - Functions that return other funtions can help us handle
   the complexities associated with asynchronicity in javascript.
 - ~Currying~, by using high-order functions (2 arrows)
   #+begin_src js
   const userLogs = username => message => console.log(`${userName} -> ${message}`);
   const log = userLogs("grandpa23");
   log("attemped to load 20 fake members");

   getFakeMembers(20).then(
     members => log(`successfuly loaded ${members.length} members`),
     error   => log("encountered an error loading members")
   );
   #+end_src
**** Recursion
 - Works particularilly well with asynchronous process
   - Functions can call themselves when they're ready
     - like when the data is *available*
     - or whan a *timer* has finished.
 - Using *setTimeout(f,t)*, calls f after t seconds have passed
   #+begin_src js
   const countdown = (value, fn, delay = 1000) => {
     fn(value);
     return value > 0
       ? setTimeout(() => countdown(value - 1, fn, delay), delay)
       : value;
   }
   const log = value => console.log(value);
   countdown(10, log);
   #+end_src
 - Is good for searching data-structures
   NOTE: code here uses ternary operator to distinguish between base and recursive case
   #+begin_src js
   const deepPick = (fields, object = {}) => {
     const [first, ...remaining] = fields.split(".");
     return remaining.length
       ? deepPick(remaining.join("."), object[first])
       : object[first];
   }
   #+end_src
**** Composition
 - *Chaining*, by using the dot notation. To act on the return value of the previous function.
 - Without composing
   #+begin_src js
   const both = date => appendAMPM(civilianHours(date));
   #+end_src
 - Using high-order functions
   #+begin_src js
   const both = compose(
     civilianHours,
     appendAMPM
   );
   both(new Data());
   #+end_src
 - Definition of compose()
   #+begin_src js
   const compose = (...fns) => arg =>
     fns.reduce((composed, f) => f(composed),
                 arg);
   #+end_src
*** TODO Putting It All Together
** DONE 4 - How React Works
*** Page Setup
 - There are "React Elements" and "React Components"
 - React Components that compose other components and elements
 - A page needs 2 .js, for *React* and *ReactDOM* (used to actually render the UI in the browser).
 - unpkg.com, uses react.development.js or react.production.min.js
 - Example HTML:
   #+begin_src html
   <!DOCTYPE html>
   <html>
     <head>
       <meta charset="utf-8" />
       <title> React Samples</title>
     </head>
     <body>
       <!-- Target container -->
       <div id="root"></div>
       <script src="https://unpkg.com/react@16/umd/react.development.js"></script>
       <script src="https://unpkg.com/react-dom@16/umd/react-dom.development.js"></script>
       <script>
         // Pure React and Javascript code
       </script>
     </body>
   </html>
   #+end_src
*** React Elements
 - HTML is a set of instructions a browser follows when constructing the DOM
 - HTML elements become DOM elements
   - The browser DOM is made of DOM   elements
     React's     DOM is made of React elements
 - AJAX: Asynchronous Javascript and XML, brought single-page applications (SPA)
 - DOM API, is a collection of objects that Javascript can use to intereact with the browser, to modify the DOM.
   document.createElement()
   document.appendChild()
 - Creating a ~React Element~
   #+begin_src js
   // Arguments:       type,      properties,      childrens
   React.createElement("h1", { id: "recipe-0" }, "Baked Salmon");
   // Output: <h1 id="recipe-0">Baked Salmon</h1>
   #+end_src
 - How the React Element looks like.
   #+begin_src js
   {
     $$typeof: Symbol(React.element),
     "type": "h1",
     "key": null,
     "ref": null,
     "props": {id: "receipe-0", children: "Baked Salmon"},
     "_owner": null,
     "_store": {}
   }
   #+end_src
*** ReactDOM
 - document.getElementById()
 - Provides the tools to render a React Element in the browser.
   ReactDOM.render()
   #+begin_src js
   const dish = React.createElement("h1", null, "Baked Salmon");
   ReactDOM.render(dish, document.getElementById("root"));
   #+end_src
 - You can render arrays of elements (since React 16, ReactConf 2017)
   #+begin_src js
   const dist = React.createElement("h1", null, "Baked Salmon");
   const dessert = React.createElement("h2", null, "Coconut Cream Pie");
   ReactDOM.render([dish, dessert], document.getElementById("root"));
   #+end_src
 - Any element that has an HTML *class* attribute uses *className* instead for that property.
   Since it is a reserved word in JS.
   #+begin_src js
   React.createElement("ul", { className: "ingredients"},...);
   #+end_src
 - Children, a part of the *Element Tree*.
   Every additional argument sent to the *createElement()* function is another child element.
   A react app is a tree of react elements all stemming from a single root element.
   #+begin_src js
   React.createElement(
     "ul", // type
     null, // properties
     React.createElement("li", null, "2 lb salmon"),
     React.createElement("li", null, "5 sprigs fresh rosemary"),
     React.createElement("li", null, "2 tablespoons olive oil"),
     React.createElement("li", null, "2 small lemons"),
     React.createElement("li", null, "1 teaspoon kosher salt"),
     React.createElement("li", null, "4 cloves of chopped garlic")
   );
   #+end_src
 - Programatically create elements, =elements need an unique key=
   In this case we use an arrow function with 2 params to accept the index of the array.
   #+begin_src js
   const items = ["a", "b", "c"];
   React.createElement(
     "ul",
     { className: "ingredients" },
     items.map((ingredient, i) =>
        React.createElement("li", { key: i }, ingredient));
   );
   #+end_src
*** React Components
 - Components are...The parts needed to create the UI
 - Components allow us to *reuse* the same structure,
   and then we can populate those structures with different sets of data.
**** Creating function components, manually hardcoded
 1) Define a function that returns a React.Element
    #+begin_src js
    function IngrediensList() {
      return React.createElement(
        "ul",
        { className: "ingredients" },
        React.createElement("li", null, "1 cup"),
      );
    }
    #+end_src
 2) Wrap it on another element, then render
    #+begin_src js
    ReactDOM.render(
      React.createElement(IngredientsList, null, null),
      document.getElementById("root")
    );
    #+end_src
 3) The end result would be a element with the name of the function.
    #+begin_src xml
    <IngredientsList>
      <ul className="ingredients">
        <li>1 cup of</li>
      </ul>
    </IngredientsList>
    #+end_src
**** Creating function components, with and array passed as a property
  #+begin_src js
  const secreetIngredients = [ "1 cup of" ];
  function IngredientsList() {
    return React.createElement(
      "ul",
      { className: "ingredients" },
      items.map((ingredient, i) => // USING ITEMS HERE!!!!!!!!!!!
        React.CreateElement("li", { key: i }, ingredient)
    );
  }
  ReactDOM.render(
    React.createElement(IngredientsList, { items: secretIngredients }, null), // PASSING ITEMS!!!!!!
    document.getElementById("root")
  );
  #+end_src
  OUTPUT
  #+begin_src xml
  <IngredientsList items="[...]">
    <ul className="ingredients">
      <li key=0>1 cup of</li>
    </ul>
  </IngredientsList>
  #+end_src
**** Creating function components, explicitly accepting the properties (props) argument
   #+begin_src js
   function IngredientsList({ items }) {
     returns React.createElement(
       "ul",
       { className: "ingredients" },
       items.map((ingredient, i) =>
         React.createElement("li", { key: i }, ingredient)
       )
     );
   }
   #+end_src
**** React Components: A Historical Tour
 - React.createClass
   #+begin_src js
   const IngridientsList = React.createClass({
     displayName: "IngridientsList",
     render() {
       return React.createElement(
         "ul",
         { className: "ingridients" },
         this.props.items.map((ingridient, i) =>
           React.createElement("li", { key: i }, ingridient)
         )
       );
     }
   });
   #+end_src
   - 2013 react was Open Sourced with this only way to create components
   - 2017 React 15.5 started throwing warnings if *React.createClass* was used
   - 2017 React 16.0 officially deprecated and was moved to its own package *create-react-class*
 - React.Component class
   #+begin_src js
   class IngredientsList extends React.Component {
   }
   #+end_src
   - 2015, when JS added *class* syntax
** DONE 5 - React with JSX
*** React Elements and JSX
 - Tag's represent the element *type*
 - Tag's attributes represent the *properties*
 - Passing attributes, surrounded with ={}= curly braces (a js *expression*)
   #+begin_src js
   React.createElement(IngredientsList, { list: [...] });
                      <IngredientsList list={[...]}>
   #+end_src
 - Mapping Arrays with JSX
   #+begin_src js
   <ul>
     {props.ingredients.map((ingredient, i) => (
       <li key="{i}">{ ingredient }</li>
     ))}
   </ul>
   #+end_src
*** Babel
 - 2014, called 6to5, used to convert ES6 syntax to ES5 syntax
   2015, renamed to Babel
 - Quickstart: dev jsx
   #+begin_src html
   <head>
     <meta charset="utf-8" />
     <title>React Examples</title>
   </head>
   <body>
     <div id="root"></div>
     <script src="https//unpkg.com/react@16.8.6/umd/react.development.js"></script>
     <script src="https//unpkg.com/react-dom@16.8.6/umd/react-dom.development.js"></script>
     <script src="https//unpkg.com/@babel/standalone/babel.min.js"></script>
     <script type="text/babel">
     <!-- JSX Code here -->
     </script>
   </body>
   #+end_src
   1) Include the babel CDN .js
   2) Will compile any code in <script> blocks that have type of "text/babel"
   3) No production ready
*** Recipies as JSX
**** TODO We create an UI with 2 (two) components
   A *Menu* component for listing the recipes and a *Recipe* components.
   #+begin_src js
   const data = [
     {name: "Baked Salmon", ingredients: [{}], steps: ["foo", "bar"]},
     {name: "Baked Salmon", ingredients: [{}], steps: ["foo", "bar"]},
   ];
   function Recipe({ name, ingredients, steps }) {
     return (
       <section id={name.toLowerCase().replace(/ /g, "-")}>
         <h1>{name}</h1>
         <ul className="ingredients">
           {ingredients.map((ingredient, i) => (
             <li key={i}>{ingredient.name}</li>
           ))}
         </ul>
         <section className="instructions">
           <h2>Cooking Instructions</h2>
           {steps.map((step, i) => (
             <p key={i}>{step}</p>
           ))}
         </section>
       </section>
     );
   }
   function Menu(props) {
     return (
       <article>
         <header>
           <h1>{props.title}</h1>
         </header>
         <div className="recipes">
           {props.recipes.map((recipe, i) =>
             <Recipe
               key={i}
               name={recipe.name}
               ingredients={recipe.ingredients}
               steps={recipe.staps}
             />
           ))}
         </div>
       </article>
     );
   }
   ReactDOM.render(
     <Menu recipes={data} title="Delicious Recipes" />,
     document.getElementById("root")
   );
   #+end_src
**** Refactor 1: Using the JSX =spred operator=, to add all the props from recipe on Recipe component
 #+begin_src js
 {
   props.recipes.map((recipe, i) => <Recipe key={i} {...recipe} />);
 }
 #+end_src
**** Refactor 2: Using =destructuring= to scope variables
 #+begin_src js
 function Menu({ title, recipes }) {
   return (
     <article>
       <header>
         <h1>{title}</h1>
       </header>
       <div className="recipes">
         {recipes.map((recipe, i) => (
           <Recipe key={i} {...recipe} />
         ))}
       </div>
     </article>
   );
 }
 #+end_src
*** React Fragments
**** Adjacent JSX elements must be wrapped in an enclosing tag!
 - Will not render to adjacent or sibling elements as a component.
   This WON'T work.
   #+begin_src js
   function Cat({ name }) {
     return (
       <h1>The cat's name is {name}</h1>
       <p>He's good.</p>
     );
   }
   ReactDOM.render(<Cat name="Jungle" />, document.getElementById("root"));
   #+end_src
 - People used to wrap it on a <div>
**** Use Fragments
 1) Long way: <React.Fragment>
    #+begin_src js
    function Cat({ name }) {
      return (
        <React.Fragment>
          <h1>The cat's name is {name}</h1>
          <p>He's good.</p>
        </React.Fragment>
      );
    }
    #+end_src
 2) Short way: <> </>
    #+begin_src js
    function Cat({ name }) {
      return (
        <>
          <h1>The cat's name is {name}</h1>
          <p>He's good.</p>
        </>
      );
    }
    #+end_src
*** Intro to webpack
 - Problems
   - JSX, ESNext transformation
   - Dependencies
   - Optimize images and CSS
 - Tools: Browserify, gulp, Grunt, Prepack, webpack
 - React Specific: create-react-app, Gatsby, Code Sandbox
 - Module Bundler: Turns (JS,LESS,CSS,JSX,ESNext) it into a single file.
 - Support:
   - Code Splitting: sometimes called *rollups* or *layers*, allows you to break up code and load it when needed (?)
   - Minification: removes whitespace, newline, long var names, and unnecesary code
   - Feature Flagging: sends code to some, but not all environmets
   - Hot Module Replacement(HMR): Watches for changes, and updates only the updated modules.
 - Features:
   - Modularity: allows to work on separate files that will be statically combined into a single file for production.
   - Composition: we can build reusable React Components that later we can reuse and compose
   - Speed: minification+singlel file=less network latency
   - Consistency: we can use JSX, ESNext and all will be compiled by Babel
**** Creating a React project
 - npm init -y
   npm install react react-dom serve
 - Breaking down this Component in Modules
   #+begin_src js
   export default function Recipe({ name, ingredients, steps }) {
       return (
           <section id="baked-salmon">
               <h1>{ name }</h1>
               <ul className="ingredients">
                   {ingredients.map((ingredient, i) => (
                       <li key={i}>{ingredient.name}</li>
                   ))}
               </ul>
               <section className="instructions">
                   <h2>Cooking Instructions</h2>
                   {steps.map((step, i) => (
                       <p key={i}>{step}</p>
                   ))}
               </section>
           </section>
       );
   }
   #+end_src
 - src/components/Instructions.js
  #+begin_src js
   export default function Instructions({ title, steps }) {
       return (
           <section className="instructions">
               <h2>{title}</h2>
               {steps.map((s, i) => (
                   <p key={i}>{s}</p>
               ))}
           </section>
       );
   }
  #+end_src
 - src/components/Ingredient.js
  #+begin_src js
   import React from "react";

   export default function Ingredient({ amount, measurement, name }) {
       return (
           <li>
               {amount} {measurement} {name}
           </li>
       );
   }
  #+end_src
 - src/components/IngredientList.js
  #+begin_src js
    import React from "react";
    import Ingredient from "./Ingredient";

    export default function IngredientList({ list }) {
        return (
            <ul className="ingredients">
                {list.map((ingredient, i) => (
                    <Ingredient key={i} {...ingredient} />
                ))}
            </ul>
        );
    }
  #+end_src
 - src/components/Recipe.js
  #+begin_src js
    import React from "react";
    import IngredientsList from "./IngredientList";
    import Instructions from "./Intructions";

    function Recipe({ name, ingredients, steps }) {
        return (
            <section id={name.toLowerCase().replace(/ /g, "-")}>
                <h1>{name}</h1>
                <IngredientList list={ingredients} />
                <Instructions title="Cooking Instructions" steps={steps} />
            </section>
        );
    }
    export default Recipe;
    #+end_src
 - src/components/Menu.js
  #+begin_src js
   import React from "react";
   import Recipe from "./Recipe";

   function Menu({ recipes }) {
       return (
           <article>
               <header>
                   <h1>Delicious Recipes</h1>
               </header>
               <div className="recipes">
                   {recipes.map((recipe, i) => (
                       <Recipe key={i} {...recipe} />
                   ))}
               </div>
           </article>
       );
   }
   export default Menu;
  #+end_src
 - src/index.js
   Instead of adding a <script> tag,
   we import react and react-dom so *webpack* can add them to our bundle
  #+begin_src js
   import React from "react";
   import { render } from "react-dom";
   import Menu from "./components/Menu";
   import data from "./data/recipes.json";

   render(<Menu recipes={ data } />, document.getElementById("root"));
    #+end_src
 - src/data/recipes.json
**** Creating the webpack build
 - npm install webpack webpack-cli
 - Since webpack 4.0.0, no custom config is explicitly needed
 - ./webpack.config.js: import statement will be "babelized" into require()
   #+begin_src js
   var path = require("path");
   module.exports = {
     entry: "./src/index.js",
     output: {
       path: path.join(__dirname, "dist", "assets"),
       filename: "bundle.js"
     },
     // List of loaders to run on this module
     module: {
       rules: [{ test: /\.js$/, exclude: /node_modules/, loader: "babel-loader" }]
     }
   };
   #+end_src
 - npm install babel-loader @babel/core # install loader
 - npm install @babel/preset-env @babel/preset-react # install babel transformer
 - ./.babelrc
   #+begin_src js
   {
     "presets": ["@babel/preset-env", "@babel/preset-react"]
   }
   #+end_src
 - npx webpack --mode development
 - ./package.json, add a build script to run "npm run build"
   #+begin_src js
   ...
    "scripts": {
        "build": "webpack --mode production"
    },
    ...
    #+end_src
**** Source Mapping
 - Maps the bundle to our code, for debugging
 - webpack.config.js
   #+begin_src js
   module.exports = {
     ...
     devtool: "#source-map"
   };
   #+end_src
 - We can step-through debugger on the provider browser webpack:// tab
   Or inspect scoped variables, or add variables to watch in the "watch panel"
**** create-react-app
 - npm install -g create-react-app
   create-react-app my-project
 - npx create-react-app myproject
 - Creates a project with 3 dependencies:
   - React
   - ReactDOM
   - react-scripts (installs babel, eslint, webpack, and more)
 - npm start
   npm test
   npm run build
** DONE 6 - React State Managment
 - The *state* of a React application is given by the data, that has the ability to change.
 - How to create stateful components?
 - How state can be sent *down* a component tree?
 - How send user interaction back *up* the component tree?
 - Stateful Context Providers?
*** Building a Star Rating Component
 - npm i react-icons # to get a SVG star icon
 - Example: Create component that renders the stars
   #+begin_src js
   import React from "react";
   import { FaStar } from "react-icons/fa";
   export default function StartRating() {
     return [
       <FaStar color="red" />
       <FaStar color="red" />
       <FaStar color="red" />
       <FaStar color="grey" />
       <FaStar color="grey" />
     ];
   }
   #+end_src
 - <Star> Create component that draws a painted star based on a prop
   #+begin_src js
   const Star = ({ selected = false }) => (
     <FaStar color={selected ? "red" : "grey"} />
   );
   #+end_src
 - <StarRating> Component that draws the selected number of stars
   #+begin_src js
   const createArray = length => [...Array(length)];
   export default function StarRating({ totalStars = 5 }) {
     return createArray(totalStars).map((n, i) => <Star key={i} />);
   }
   #+end_src
*** The =useState()= Hook
 - Hooks contain reusable code logic, that is separate from the *component tree*
 - Hooks can cause the component they're hooked into to rerender.
 - <StarRating> The hook is a function that we can invoke to return an array.
   First value is the *state variable* we want to use.
   #+begin_src js
   import React from "react";
   import FaStar from "react-icons/fa";

   export default function StarRating({ totalStars = 5 }) {
     const [selectedStars] = useState(3);
     return (
       <>
       {createArray(totalStars}.map((n, i)) => (
         <Star key={i} selected={selectedStars > i} />
       ))}
       <p>
         {selectedStars} of {totalStars} stars
       </p>
       </>
     );
   }
   #+end_src
 - <Star> Make FaStar clickable, onClick
   Filled second prop, onSelect with a fake function (identity) to fallback.
   #+begin_src js
   const Star = ({ selected = false, onSelect = f => f }) => (
     <FaStar color={selected ? "red" : "grey"} onClick={onSelect} />
   );
   #+end_src
 - <StarRating> Using the prop to change the state of the Star Rating
   The 2nd item in the array returned by useState hook is a function that can be used to change the state value.
   #+begin_src js
   export default function StarRating({ totalStars = 5 }) {
     const [selectedStars, setSelectedStars] = useState(0);
     return (
       <>
       {createArray(totalStars}.map((n, i) =>()
         <Star
           key={i}
           selected={selectedStars > i}
           onSelect={() => setSelectedStars(i+1)}
           />
       ))}
       <p>
         {selectedStars} of {totalStars} stars
       </p>
       </>
     );
   }
    #+end_src
*** React State the "Old Way"
 - < v16.8.0
   #+begin_src js
   import React, { Component } from "react";
   export default class StarRating extends Component {
     constructor(props) {
       super(props);
       this.state = {
         starsSelected: 0
       };
       this.change = this.change.bind(this);
     }
     change(starsSelected) {
       this.setState({ starsSelected });
     }
     render() {
       const { totalStars } = this.props;
       const { starsSelected } = this.state;
       return (
         <div>
           {[...Array(totalStars)].map((n, i) => (
             <Star
               key={i}
               selected={i < starsSelected}
               onClick={() => this.change(i + 1)}
             />
           ))}
         <p>
           {starsSelected} of {totalStars} stars
         </p>
         </div>
       );
     }
   }
     #+end_src
*** Refactoring f or Advanced Reusability
**** <StarRating>, style prop
   Problem: All react elements have *style* properties, a lot of components also have *style* properties.
   Solution: upgrade the React.Fragment to a proper <div>, and pass the style prop
   #+begin_src js
   export default function StarRating({ style = {}, totalStars = 5 }) {
     const [selectedStars, setSelectedStars] = useState(0);
     return (
       <div style={{ padding: "5px", ...style }}>
         {createArray({totalStars}.map(n, i) => (
           <Star
             key={i}
             selected={selectedStars > i}
             onSelect{() => setSelectedStars(i + 1)}
           />
           ))}
         <p>
           {selectedStars} of {totalStars} stars
         </p>
       </div>
     );
   }
   #+end_src
**** <StarRating>, other props
   Problem: they might want to add other props, like onDoubleClick.
   Solution: spread on <div>
   Note: This is not a blanket rule to apply to all your components.
   #+begin_src js
   export default function StarRating({ style = {}, totalStars = 5, ...props }) {
     const [selectedStars, setSelectedStars] = useState(0);
     return (
       <div style={{ padding: 5, ...style }} {...props}>
         ...
       </div>
     );
   }
   #+end_src
*** State in Components Trees
 - Problem:
   It's not a great idea to use *state* in every single component.
   Or have *state* data distributed throughout too many components
   makes it harder to track down bugs.
   (Here we will try to keep the components pure, without state,
    by sending down setter functions of our state)
**** 1) Storing state at the root of the component tree and, passing it down to child components via props
 - color-data.json
   #+begin_src js
 [
   {
     "id": "0175d1f0-a8c6-41bf-8d02-df5734d829a4",
     "title": "ocean at dusk",
     "color": "#00c4e2",
     "rating": 5
   }
 ]
 #+end_src
 - App.js Store the state on the App component.
    #+begin_src js
    import React, { useState } from "react";
    import colorData from "./color-data.json";
    import ColorList from "./ColorList.js";
    export default function App() {
      const [colors] = useState(colorData);
      return <ColorList colors={colors} />;
    }
    #+end_src
 - ColorList.js
   #+begin_src js
   import React from "react";
   import Color from "./Color";
   export default function ColorList({ colors = [] }) {
     if(!colors.length) return <div>No Colors Listed.</div>
     return (
       <div>
       { colors.map(color => <Color key={color.id} {...color} />) }
       </div>
     );
   }
   #+end_src
 - Color.js
   #+begin_src js
   export default function Color({ title, color, rating }) {
     return (
       <section>
         <h1>{title}</h1>
         <div style={{ height: 50, backgroundColor: color }} />
         <StarRating selectedStars={rating} />
       </section>
     );
   }
   #+end_src
 - StarRating.js
   #+begin_src js
   export default function StarRating({ totalStars = 5, selectedStars = 0 }) {
     return (
       <>
         {createArray(totalStars).map((n, i) => (
           <Star
             key={i}
             selected={selectedStars > i}
           />
           <p>
             {selectedStars} of {totalStars} stars
           </p>
         ))}
       </>
     );
   }
   #+end_src
**** 2) onRemoveColor Send state from children back to the root.
    Keep the component pure, and we only care about notifying about the deletion with his ID.
    Is up to the parent providing the onRemove(), to remove the ID.
    Changing the state of the colrs array causes the App component to be rerendered.
    - Color.js
      #+begin_src js
      import { FaTrash } from "react-icons/fa";
      export default function Color({ id, title, color, rating, onRemove = f => f }) {
        return (
          <section>
            <h1>{title}</h1>
            <button onClick={() => onRemove(id)}>
              <FaTrash />
            </button>
            <div style={{ height: 50, backgroundColor: color }} />
            <StarRating selectedStars={rating} />
          </section>
        );
      }
      #+end_src
    - ColorList.js
      #+begin_src js
      export default function ColorList({ colors = [], onRemoveColor = f => f }) {
        if (!colors.length) return <div>No Colors Listed. (Add a Color)</div>;
        return (
          <div>
          {colors.map(color => (
            <Color key={color.id} {...color} onRemove={onRemoveColor} />
          )}
          </div>
        );
      }
      #+end_src
    - App.js
      #+begin_src js
      export default function App() {
        const [colors, setColors] = useState(colorData);
        return (
          <ColorList
            colors={colors}
            onRemoveColor={id => {
              const newColors = colors.filter(color => color.id !== id);
              setColors(newColors);
            }}
          />
        );
      }
      #+end_src
**** 3) onRate        Send state from children back to the root
    - StarRating.js
      #+begin_src js
      export default function StarRating({
        totalStars = 5,
        selectedStars = 0,
        onRate = f => f
      }) {
        return (
          <>
            {createArray(totalStars).map((n, i) => (
              <Star
                key={i}
                selected={selectedStars > i}
                onSelect{() => onRate(i + 1)}
              />
            ))}
          </>
        );
      }
      #+end_src
    - Color.js
      #+begin_src js
      export default function Color({
        id,
        title,
        color,
        rating,
        onRemove = f => f,
        onRate = f => f
      }) {
        return (
          <section>
            <h1>{title}</h1>
            <button onClick={()=>onRemove(id)}>
              <FaTrash />
            </button>
            <div style={{ height: 50, backgroundColor: color }} />
            <StarRating
              selectedStars={rating}
              onRate={rating => onRate(id, rating)}
            />
          </section>
        );
      }
      #+end_src
    - ColorList.js
      #+begin_src js
      export default function ColorList({
        colors = [],
        onRemoveColor = f => f,
        onRateColor = f => f
      }) {
        if(!colors.length) return <div>No Colors Listed. (Add a Color)</div>
        return (
          <div className="color-list">
            {
              colors.map(color => (
                <Color
                  key={color.id}
                  {...color}
                  onRemove={onRemoveColor}
                  onRate={onRateColor}
                />
              )
            }
          </div>
        );
      }
      #+end_src
    - App.js
      #+begin_src js
      export default function App() {
        const [colors, setColors] = useState(colorData);
        return (
          <ColorList
            colors={colors}
            onRateColor={(id, rating) => {
              const newColors = colors.map(color =>
                color.id === id ? { ...color, rating } : color
              );
              setColors(newColors);
            }}
            onRemoveColor={id => {
              const newColors = colors.filter(color => color.id !== id);
              setColors(newColors);
            }}
          />
        );
      }
      #+end_src
*** Building <form> with =useRef()= or =useState()=
**** useRef() - Uncontrolled Components
 - using ref= JSX attribute
 - Creates *Imperative* code, an *uncontrolled component*, uses the DOM to save the form values.
 - refs: access the DOM directly.
         Stores values for the lifetime of a component.
   #+begin_src js
   import React, { useRef } from "react";

   export default function AddColorForm({ onNewColor = f => f }) {
     const txtTitle = useRef();
     const hexColor = useRef();
     const submit = e => {
       e.preventDefault(); // Prevents the browser to submit the form to the target= of the <form>
       const title = txtTitle.current.value;
       const color = hexColor.current.value;
       onNewColor(title, color);
       txtTitle.current.value = "";
       hexColor.current.value = "";
     }
     return (
       <form onSubmit={submit}>
         <input ref={txtTitle} type="text" placeholder="color title..." required />
         <input ref={hexColor} type="color" required />
         <button>ADD</button>
       </form>
     );
   }
   #+end_src
**** useState() - Controlled Components
     The component has full control over the input value content.
     event.target, is a reference to the DOM element
     They render() a lot more than UNcontrolled components.
     #+begin_src js
     import React, { useState } from "react";

     export default function AddColorForm({ onNewColor = f => f }) {
       const [title, setTitle] = useState("");
       const [color, setColor] = useState("#000000");
       const submit = e => {
         e.preventDefault();
         onNewColor(title, color);
         setTitle("");
         setColor("");
       };
       return (
         <form onSubmit={submit}>
           <input
             value={title}
             onChange={event => setTitle(event.target.value)}
             type="text"
             placeholder="color title..."
             required
           />
           <input
             value={color}
             onChange={event => setColor(event.target.value)}
             type="color"
             required
           />
           <button>ADD</button>
         </form>
       );
     }
     #+end_src
**** Custom Hooks useInput() made with with useState()
 Hooks are designed to be used inside of React components.
 1) Create, *Returns* an array, with A) the value ~and~ the setter function. B) a constructor, to reset the value
    #+begin_src js
    import { useState } from "react";
    export const useInput = initialValue => {
      const [value, setValue] = useState(initialValue);
      return [
        { value, onChange: e => setValue(e.target.value) },
        () => setValue(initialValue)
      ];
    };
    #+end_src
 2) Using the custom hooks, spreading the input elements instead of copying manually the props
    #+begin_src js
    import React from "react";
    import { use Input } from "./hooks";
    export default function AddColorForm({ onNewcolor = f => f }) {
      const [titleProps, resetTitle] = useInput("");
      const [colorProps, resetColor] = useInput("#000000");
      const submit = event => {
        event.preventDefaults();
        onNewColor(titleProps.value, colorProps.value);
        resetTitle();
        resetColor();
      };
      return (
        <form onSubmit={submit}>
          <input
            {...titleProps}
            type="text"
            placeholder="color title..."
            required
          />
          <input {...colorProps} type="color" required />
          <button>ADD</button>
        </form>
      );
    }
        #+end_src
**** App.js
 - Both controlled and uncontrolled pass up the value of the color to their param onNewColor= function.
   App component handles that.
   #+begin_src js
   import React, { useState } from "react";
   import colorData from "./color-data.json";
   import ColorList from "./ColorList.js";
   import AddColorFrorm from "./AddColorForm";
   import { v4 } from "uuid";

   export default function App() {
     const [colors, setColors] = useState(colorData);
     return (
       <>
         <AddColorForm
           onNewColor={(title, color) => {
             const newColors = [
               ...colors,
               {
                 id: v4(),
                 rating: 0,
                 title,
                 color
               }
             ];
             setColors(newColors);
           }}
         />
         <ColorList ... />
       </>
     );
   }
   #+end_src
*** React Context with =createContext()= and =useContext()=
 - pass state up and down a component tree works for small components or small applications
   still tedious and bug ridden
 - On complex UI's the root of the tree is often very far from the leaves.
   Passing the data around will bloat the code.
 - *Context Provider*, to put data in.
   Is a React Component, that you can wrap around your entire App() or parts of it (preferably)
 - *Context Consumer*, data destination.
   Is a React Component, that retrieves the data from the context.
**** =createContext()= Setting of the context (outside a component)
 - index.js - create a provider
   #+begin_src js
   import React, { createContext } from "react";
   import colors     from "./color-data";
   import { render } from "./color-data";
   import App        from "./App";
   export const ColorContext = createContext();
   render(
     <ColorContext.Provider value={{ colors }}>
       <App />
     </ColorContext.Provider>,
     document.getElementById("root")
   );
   #+end_src
 - App.js - Cleaned up version
   #+begin_src js
   import React from "react";
   import ColorList from "./ColorList.js";
   import AddColorForm from "./AddColorForm";

   export default function App() {
     return (
       <>
         <AddColorForm />
         <ColorList />
       </>
     );
   }
   #+end_src
**** =useContext()= Retrieving from the context with the hook
 - ColorList.js
   #+begin_src js
   import React, { useContext } from "react";
   import { ColorContext }      from "./";      // loads index.js
   import Color                 from "./Color";

   export default function ColorList() {
     const { colors } = useContext(ColorContext);
     if (!colors.length) return <div>No Colors Listed. (Add a color)</div>;
     return (
       <div className="color-list">
         {
           colors.map(color => <Color key={color.id} {...color} />)
         }
       </div>
     );
   }
   #+end_src
**** The "old" way. Using =<.Consumer>= instead of the hook
  Using a pattern called "render props"
  #+begin_src js
  export default function ColorList() {
    return (
      <ColorContext.Consumer>
        {context => {
          if (!context.colors.length) return <div>No Colors Listed. (Add a Color)</div>;
          return (
            <div className="color-list">
              {
                context.colors.map(color => <Color key={color.id> {...color} />)
              }
            </div>
          )
        }}
      </ColorContext.Consumer>
    );
  }
  #+end_src
**** Stateful Context Providers with =useState()=
     Options
 1) Create a stateful context that *renders* a Provider.
    AKA wrap the values returned by useState() in a Provider
    #+begin_src js
    import React, { createContext, useState } from "react";
    import colorData from "./color-data.json";
    const ColorContext = createContext();
    export default function ColorProvider ({ children }) {
      const [colors, setColors] = useState(colorData);
      return (
        <ColorContext.Provider value={{ colors, setColors }}>
          {children}
        </ColorContext.Provider>
      );
    }
    #+end_src
 2) It's a better idea, to not expose the raw setColors,
    but instead return specific functions for the operations we want.
    Ex: add a new color, remove a color, set rating to a color
    #+begin_src js
    export default function ColorProvider ({ children }) {
      const [colors, setColors] = useState(colorData);
      const addColor = (title, color) =>
        setColors([
          ...colors,
          {
            id: v4(),
            ration: 0,
            title,
            color
          }
        ]);
      const rateColor = (id, rating) =>
           setColors(
             colors.map(color => (color.id === id ? { ...color, rating } : color)));
      const removeColor = id =>
           setColors(
             colors.filter(color => color.id !== id ));
      return (
           <ColorContext.Provider value={{ colors, addColor, removeColor, rateColor }}>
             {children}
           </ColorContext.Provider>
         );
       }
        #+end_src
**** Custom Hooks around =useContext()=
 - We create a hook (useCol), to wrap any mention of *useContext()* or context everywhere, but on index.js
   #+begin_src js
   import React, { createContext, useState, useContext } from "react";
   import colorData from "./color-data.json";
   import { v4 } from "uuid";
   const ColorContext = createContext();
   export const useColors = () => useContext(ColorContext);
   #+end_src
 - index.js, uses our custom provider
   #+begin_src js
   import React from "react";
   import { ColorProvider } from "./color-hooks.js";
   import { render } from "react-dom";
   import App from "./App";
   render(
     <ColorProvider>
       <App />
     </ColorProvider>,
     document.getElementById("root");
   );
   #+end_src
 - ColorList.js, gets the colors
   #+begin_src js
   import React from "react";
   import Color from "./Color";
   import { useColors } from "./color-hooks";
   export default function ColorList() {
     const { colors } = useColors();
     return (...);
   }
   #+end_src
 - Color.js, we gets ONLY rating and remove functions
   #+begin_src js
   import React from "react";
   import StarRating from "./StarRating";
   import { useColors } from "./color-hooks";

   export default function Color ({ id, title, color, rating }) {
     const { rateColor, removeColor } = useColors();
     return (
       <section>
         <h1>{title}</h1>
         <button onClick={()=>removeColor(id)}>X</button>
         <div style={{ height: 50, backgroundColor: color }} />
         <StarRating
           selectedStars={rating}
           onRate={rating => rateColor(id, rating)}
         />
       </section>
     );
   }
   #+end_src
 - AddColorForm.js, gets ONLY the add color function
   #+begin_src js
   import React from "react";
   import { useInput } from "./hooks";
   import { useColors } from "./color-hooks";

   export default function AddColorForm() {
     const [titleProps, resetTitle] = useInput("");
     const [colorProps, resetColor] = useInput("#000000");
     const { addColor } = useColors();
     const submit = e => {
       e.preventDefault();
       addColor(titleProps.value, colorProps.value);
       resetTitle();
       resetColor();
     };
     return ( ... );
   }
   #+end_src
** 7 - Enhancing Components with Hooks
 - Hooks that define *rules* about *why/when* rendering should happen.
 - Hooks than enhance rendering perfomance
 - useEffect()
 - useLayoutEffect()
 - useReducer()
 - useCallback()
 - useMemo()
*** Introducing =useEffect()=, happens after render
 - Placing a function inside of an useEffect(),
   means that the function will be called after the render, as a side effect.
   #+begin_src js
   function Checkbox {
     const [checked, setChecked] = useState(false);
     useEffect(() => {
       alert(`checked: ${checked.toString()}`);
     });
     return (
       <>
         <input
           type="checkbox"
           value={checked}
           onChange={() => setChecked(checked => !checked)}
         />
         {checked ? "checked" : "not checked"}
       </>
     );
   }
   #+end_src
**** Example 1: set a value in storage, after the render was done
   #+begin_src js
   useEffect(() => {
     localStorage.setItem("checkbox-value", checked);
   });
   #+end_src
**** Example 2: set focus, after the render was done
   #+begin_src js
   useEffect(() => {
     txtInputRef.current.focus();
   });
   #+end_src
*** The Dependency Array
 - aka how to associate useEffect() with specific data changes.
   if there is no change, there is no code execution
**** Is the 2nd argument of =useEffect()=
 - Can be empty [] to run only once, after the initial render, never again
   Useful for initialization.
 - Can depend on multiple var changes
    #+begin_src js
   import React, { useState, useEffect } from "react";
   import "./App.css"; // ?

   function App() {
     const [val, set] = useState("");
     const [phrase, setPhrase] = useState("example phrase");
     const createPhrase = () => {
       setPhrase(val);
       set("");
     };
     useEffect(() => { console.log(`typing "${val}"`); }, [val]);
     useEffect(() => { console.log(`saved phrase: "${phrase}"`); }, [phrase]);
     return (
       <>
         <label>Favorite phrase:</label>
         <input
           value={val}
           placeholder={phrase}
           onChange={e => set(e.target.value)}
         />
         <button onClick={createPhrase}>send</button>
       </>
     );
   }
   #+end_src
**** If you =return= a function, it will run when the component is removed
    #+begin_src js
    const [posts, setPosts] = useState([]);
    const addPost = post => setPosts(allPosts => [post, ...allPosts]);
    useEffect(() => {
      newsFeed.subscribe(addPost);
      welcomeChime.play();
      return () = {
        newsFeed.unsubscribe(addPost);
        goodbyeChime.play();
      };
    }, []);
    #+end_src
 - For clarity, we might want to use separete useEffect(), for news feed and other for the chime events
    #+begin_src js
   useEffect(() => {
     newsFeed.subscribe(addPost);
     return () => newsFeed.unsubscribe(addPost);
   }, []);
   useEffect(() => {
     welcomeChime.play();
     return () => goodbyeChime.play();
   }, []);
   #+end_src
 - Or even better, create a custom hook
    #+begin_src js
    const useJazzyNews = () => {
      const [posts, setPosts] = useState([]);
      const addPost = post => setPosts(allPosts => [post, ...allPosts]);
      useEffect(() => {
        newsFeed.subscribe(addPost);
        return () => newsFeed.unsubscribe(addPost);
      }, []);
      useEffect(() => {
        welcomeChime.play();
        return () => goodbyeChime.play();
      }, []);
      return posts;
    };
    #+end_src
 - Use the custom hook
    #+begin_src js
    function NewsFeed({ url }) {
      const posts = useJazzyNews();
      return (
        <>
          <h1>{posts.length} articles</h1>
          {posts.map(post => {
            <Post key={post.id} {...post}>
          })}
        </>
      );
    }
    #+end_src
*** Deep Checking Dependencies - =useMemo()= + =useEffect()= OR =useCallback()= + =useEffect()=
 - In javascript, arrays, objects, and functions are the *same*
   only when they are the exact same *instance*.
**** =useMemo()= to be able to use an *array* as an element of the D.A. of =useEffect()=
 - If we want an element of the ~Dependency Array~ to be an Array
   - We should declare it outside the function(), if no argument is needed
   - Or useMemo() which will accept arguments, and cache his output using other ~Dependency Array~
     #+begin_src js
     function WordCount({ children = "" }) {
       useAnyKeyToRender();
       const words = useMemo(() => children.split(" "),
                             [children]);
       useEffect(() => {
         console.log("fresh render");
       }, [words]);
       return ( ... );
     }
     #+end_src
**** =useCallback()= if we want to memoize *functions* instead of values
   #+begin_src js
   const fn = useCallback(() => {
     console.log("hello");
     console.log("world");
   }, []);
   useEffect(() => {
     console.log("fresh render");
     fn();
   }, [fn]);
   #+end_src
**** Improved useJazzyNews hook, with =useMemo() + useEffect()=
 - That newPostChime.play() on each new message.
   #+begin_src js
   const useJazzyNews = () => {
     const [_posts, setPosts] = useState([]);
     const addPost = post => setPosts(allPosts => [post, ...allPosts]);
     const posts = useMemo(() => _posts, [_posts]);
     useEffect(() => {
       newPostChime.play();
     }, [posts]);
     useEffect(() => {
       newsFeed.subscribe(addPost);
       return () => newsFeed.unsubscribe(addPost);
     }, []);
     useEffect(() => {
       welcomeChime.play();
       return () => goodbyeChime.play();
     }, []);
     return posts;
   }
   #+end_src
*** When to use =useLayoutEffect()=
 Events
 1) Render
 2) useLayoutEffect()
 3) browser paint, when the components are actually added to the DOM
 4) useEffect()
 When the effect, is needed for the look of the component:
**** =useState()= to obtain the width and height of an element when the window is resized
   #+begin_src js
   function useWindowSize {
     const [width, setWidth] = useState(0);
     const [height, setHeight] = useState(0);
     const resize = () => {
       setWidth(window.innerWidth);
       setHeight(window.innerHeight);
     };
     useLayoutEffects(() => {
       window.addEventListener("resize", resize);
       resize();
       return () => window.removeEventListener("resize", resize);
     }, []);
     return [width, height];
   }
   #+end_src
**** =useState()= tracking the position of the mouse
   #+begin_src js
   function useMousePosition {
     const [x, setX] = useState(0);
     const [y, setY] = useState(0);
     const setPosition = ({ x, y }) => {
       setX(x);
       setY(y);
     };
     useLayoutEffect(() => {
       window.addEventListener("mousemove", setPosition);
       return () => window.removeEventListener("mousemove", setPosition);
     }, []);
   }
   #+end_src
*** 3 Rules to follow with Hooks
 1) Hooks only run on React Components, are not regular javascript.
 2) Break functionality into multiple, small hooks.
    React saves the values of Hooks in an Array so the values can be tracked.
 3) Hooks should be called at the top level.
    Not on conditionals or loops. If not, it will throw off the internal array of value in React.
    We can still nest conditional inside the Hook.
    Similar, you can nest async functions inside the function in a Hook.
*** =useReducer()= Improving code with it
 - useReducer() takes in the reducer function and the initial state.
                           a reducer takes the current state and returns a new state.
   #+begin_src js
   function Checkbox() {
     const [checked, toggle] = useReducer(checked => !checked, false);
     return (
       <>
         <input type="checkbox" value={checked} onChange={toggle} />
         {checked ? "checked" : "not checked"}
       </>
     );
   }
   #+end_src
*** =useReducer()= to handle complex state, instead of useState()
"Teach everyone to spread, they'll spread for a day.
 Teach everyone to useReducer() and they'll spread for life."
 - We can use it to *hide the spread* of an object, when updating a single value.
 - Instead of
   #+begin_src js
   const [user, setUser] = useState(firstUser);
   setUser({ ...user, admin: true});
   #+end_src
 - Make this
   #+begin_src js
   function User() {
     const [user, setUser] = useReducer(
       (user, newDetails) => ({ ...user, ...newDetails }),
       firstUser
     );
   }
   setUser({ admin: true });
   #+end_src
*** TODO Legacy setState and useReducer
*** =memo()= - Improving Component Perfomance
 - Tools to help you prevent unnecesarry renders: memo() useMemo() useCallback()
 - memo(), is used to create pure components
   We can replace <Cat> with <PureCat>
   #+begin_src js
   import React, { useState, memo } from "react";
   const Cat = ({ name }) => {
     console.log(`rendering ${name}`);
     return <p>{name}</p>;
   }
   const PureCat = memo(cat);
   #+end_src
 - Second argument accepts a *Predicate*, a function that returns only true or false.
   To decide wheter to render a cat or not.
   false means re-render
   true do not re-render
   #+begin_src js
   const PureCat = memo(
     Cat,
     (prevProps, nextProps) => prevProps.name === nextProps.name
   );
   #+end_src
*** shouldComponentUpdate() and React.PurenComponent
 - was the precusor of memo(), and we could use to let react knwo which props or state to watch
 - while the other was the name of the class we used to extend to get a pure component
 - useCallback() and useMemo() can be used to memoize object and function properties
   - Instead of provide props to check on the memo(), we use the callback
     to ensure that meow function ahd not changed.
   #+begin_src js
   const PureCat = memo(Cat);
   function App() {
     const meow = useCallback(name => console.log(`${name} has meowed`), []);
     return <PureCat name="Biscuit" meow={meow} />
   }
   #+end_src
*** When to refactor
 - useMemo+useCallback, don't
 - Use the React Profiler
** 8 - Incorporating Data
 - The UI components we've composed are vessels for data.
 - returning *null* from a omponent tells React to render nothing
 - fetch()
   - promises and async/await
   - 2nd parameter object of options
   - new FormData().append(k,v)
   - Authorization header
*** Fetching http data from a React Component =useState()= and =useEffect()=
 - require us to orchestrate both
   1) =useState()= to store the *response* in state
   2) =useEffect()= to make the fetch *request*
   #+begin_src js
   import React, { useState, useEffect } from "react";

   function GithubUser({ login }) {
     const [data, setData] = useState();
     useEffect(() => {
       if (!login) return
       fetch(`https://api.github.com/users/${login}`)
         .then(response => response.json())
         .then(setData)
         .catch(console.error);
     }, [login]);
     if (data)
       return <pre>{JSON.stringify(data, null, 2)</pre>
     return null;
   }

   export default function App() {
     return <GithubUser login="moonhighway" />;
   }
   #+end_src
*** Saving Data Locally: =window.localStorage=
 - We don't need it to cache data.
   Cache-Control: max-age=<EXP_DATE>
 - Synchronous:
   JSON.parse()
   JSON.stringify()
 - window.sessionStorage - for the user's sessions, lost after tab closed or restart
 - window.localStorage   - indefinitely, until you remove it
          localStore.clear()
          localStore.getkey(k)
          localStore.setkey(k,v)
**** Example: outside <GithubUser> component
   #+begin_src js
   const loadJSON = key =>
     key && JSON.parse(localStorage.getItem(key));
   const saveJSON = (key, data) =>
     localStorage.setItem(key, JSON.stringify());
   #+end_src
**** Caching Data on =useState()= updated by =useEffect()=
    On <GithubUser> component
 #+begin_src js
 const [data, setData] = useState(loadJSON(`user:${login}`));
 useEffect(() => {
   if(!data) return;
   if (data.login === login) return;
   const { name, avatar_url, location } = data;
   saveJSON(`user:${login}`, {
     name,
     login,
     avatar_url,
     location
   });
 }, [data]);
 #+end_src
*** Render Props
- Passed as argument/props, either
  1) A Components that are conditionally rendered
  2) A function that return components that will be rendered
  #+begin_src js
  function List({ data = [], renderItem, renderEmpty }) {
    return !data.length ? (
    ) : (
      <ul>
        {data.map((item, i) => (
          <li key={i}>{renderItem(item)}</li>
        ))}
      </ul>
    );
  }
  export default function App() {
    return (<List
             data={tahoe_peaks}
             renderEmpty={<p>This list is empty</p>}
             renderItem{item => (
               <>
                 {item.name} - {item.elevation.toLocaleString()}ft
               </>
             )}
           />
         );
  }
  #+end_src
*** Virtualized Lists (or Windowing)
 - If we have too many things to render,
   we can render just what is on screen and
   a bit of what is before and after.
 - Other Packages: react-virtualized
**** faker - Creating fake users
  #+begin_src js
  import faker from "faker";
  const bigList = [...Array(5000)].map(() => ({
    name: faker.name.findName(),
    email: faker.internet.email(),
    avatar: faker.internet.avatar(),
  }));
  #+end_src
**** <List> Render Props (52ms)
- We could after this render it with a render props
  #+begin_src js
  export default function App() {
    const renderItem = item => (
      <div style={{ display: "flex" }}>
        <img src={item.avatar} alt={item.name} width={50} />
        <p>
          {item.name} - {item.email}
        </p>
      </div>
    );
    return <List data={bigList} renderItem={renderItem} />;
  }
  #+end_src
**** <FixedSizeList> react-window (2.6ms)
 #+begin_src js
 import React from "react";
 import { FixedSizeList } from "react-window";

 export default function App() {
   const renderRow = ({ index, style }) => (
     <div style={{ ...style, ...{ display: "flex" } }}>
       <img
         src={bigList[index].avatar}
         alt={bigList[index].name}
         width={50}
       />
       <p>
         {bigList[index].name} - {bigList[index].email}
       </p>
     </div>
   );
   return (
     <FixedSizeList
       height={window.innerHeight}
       width={window.innerWidth - 20}
       itemCount={bigList.length}
       itemSize={50}
     >
       {renderRow}
     </FixedSizeList>
   );
 }
 #+end_src
*** Be careful: extra layes of abstractions, can add complexity to our code.
   It's our job reduce complexity wherever we can.
   However in this case, reduce complexity by abstracting away reusable logic into a component and Hook.
*** Hook - Custom Hook =useFetch()=
    Generalizing the fetch request mechanics
**** =useFetch()= making a new custom hook
  to represent the 3 possible states of a request (pending, successful, failed)
   #+begin_src js
   import React, { useState, useEffect } from "react";
   export function useFetch(uri) {
     const [data, setData] = useState();
     const [error, setError] = useState();
     const [loading, setLoading] = useState(true);
     useEffect(() => {
       if(!uri) return
       fetch(uri)
         .then(data => data.json())
         .then(setData)
         .then(() => setLoading(false))
         .catch(setError);
     }, [uri]);
     return { loading, data, error };
   }
   #+end_src
**** =useFetch()= using it on a component
  #+begin_src js
  function GithubUser({ login }) {
    const { loading, data, error } = useFetch(
      `https://api.github.com/users/${login}`
    );
    // Still handled the 3 states
    if (loading)
      return <h1>loading...</h1>;
    if (error)
      return <pre>{JSON.stringify(error, null, 2)}</pre>;
    return (
      <div className="githubUser">
        <img
          src={data.avatar_url}
          alt={data.login}
          style={{ width: 200 }}
        />
        <div>
          <h1>{data.login}</h1>
          {data.name && <p>{data.name}</p>}
          {data.location && <p>{data.location}</p>}
        </div>
      </div>
    );
  }
  #+end_src
**** Using the component that used the hook
  #+begin_src js
  import React, { useState } from "react";
  import GitHubUser from "./GitHubUser";
  import SearchFrom from "./SearchFrom"; // Component ready to collect search strings from the user

  export default function App() {
    const [login, setLogin] = useState("moontahoe");
    return (
      <>
        <SearchForm value={login} onSearch={setLogin} />
        <GitHubUser login={login} />
      </>
    );
  }
  #+end_src
*** Component - Generalizing the render mechanics
**** <Fetch> Create
  #+begin_src js
  function Fetch({
    uri,
    renderSucess,
    loadingFallback= <p>loading...</p>
    renderError = error => (
      <pre>{JSON.stringify(error, null, 2)}</pre>
    )
  }) {
    const { loading, data, error } = useFetch(uri);
    if (loading) return loadingFallback;
    if (error) return renderError(error);
    if (data) return renderSuccess({ data });
  }
  #+end_src
**** <Fetch> Using it on another component
  We no longer have to handle the "3 states"
  #+begin_src js
  import React from "react";
  import Fetch from "./Fetch";

  export default function GitHubUser({ login }) {
    // We could also provide custom implementations for
    // loadingFallback={<LoadingSpinner />}
    // renderError={error => return <p>Something went wrong.. {error.message}</p>;
    return (
      <Fetch
        uri={`http://api.github.com/users/${login}`}
        renderSuccess={UserDetails}
      />
    );
  }
  function UserDetails({ data }) {
    return (
      <div className="githubUser">
        <img
          src={data.avatar_url}
          alt={data.login}
          style={{ width: 200 }}
        />
        <div>
          <h1>{data.login}</h1>
          {data.name && <p>{data.name}</p>}
          {data.location && <p>{data.location}</p>}
        </div>
      </div>
    );
  }
  #+end_src
*** Hook - Custom Hook =useIterator()=
**** Cycle over an array
   #+begin_src js
   export const useIterator = (
     items = [],
     initialIndex = 0
   ) => {
     const [i, setIndex] = useState(initialIndex); // useState()
     const prev = () => {
       if(i === 0) return setIndex(items.length - 1);
       setIndex(i - 1);
     };
     const next = () => {
       if(i === items.length - 1) return setIndex(0);
       setIndex(i + 1);
     };
     return [items[i], prev, next];
   };
   #+end_src
**** Cycle over an array with memoization with =useMemo()= and =useCallback()=
 - Not for speed, but for usability in future comparisons made by the used of the Hook
   #+begin_src js
   import React, { useCallback, useMemo } from "react";
   export const useIterator = (
     items = [],
     initialValue = 0
   ) => {
     const [i, setIndex] = useState(initialValue);
     const prev = useCallback(() => {
       if (i === 0) return setIndex(items.length - 1);
       setIndex(i - 1);
     }, [i]);
     const next = useCallback(() => {
       if (i === items.length - 1) return setIndex(0);
       setIndex(i + 1);
     }, [i]);
     const item = useMemo(items[i], [i]);
     return [item || items[0], prev, next];
   };
   #+end_src
**** <RepoMenu> Using useIterator()
  #+begin_src js
  import React from "react";
  import { useIterator } from "../hooks";
  export function RepoMenu({
   repositories,
   onSelect = f => f
  }) {
    const [{ name }, previous, next ] = useIterator(
      repositories
    );
    useEffect(() => {
      if(!name) return;
      onSelect(name);
    }, [name]);
    return (
      <div style={{ display: "flex" }}>
        <button onClick={previous}>&lt;</button>
        <p>name</p>
        <button onClick={next}>&gt;</button>
      </div>
    );
  }
  #+end_src
**** <UserRepositories> using <RepoMenu>
  #+begin_src js
  import React from "react";
  import Fetch from "./Fetch";
  import RepoMenu from "./RepoMenu";
  export default function UserRepositories({
    login,
    selectedRepo,
    onSelect = f => f
  }) {
    return (
      <Fetch
        uri={`https://api.github.com/users/${login}/repos`}
        renderSuccess={({ data }) => (
          <RepoMenu
            repositories={data}
            selectedRepo={selectedRepo}
            onSelect={onSelect}
          />
        )}
      >
    );
  }
  #+end_src
**** <UserDetails> using <UserRepositories>
  #+begin_src js
  function UserDetails({ data }) {
    return (
      <div className="githubUser">
        <img src={data.avatar_url} alt={data.login} style={{ width: 200 }} />
        <div>
          <h1>{data.login}</h1>
          {data.name && <p>{data.name}</p>}
          {data.location && <p>{data.location}</p>}
        </div>
        <UserRepositories
          login={data.login}
          onSelect={repoName => console.log(`${repoName} selected`)}
        />
      </div>
    );
  }
  #+end_src
*** Waterfall Requests
    npm install react-markdown
**** loadReadme(), function to get the README.md, requires 2 requests
  #+begin_src js
  const loadReadme = async (login, repo) => {
    const uri = `https://api.github.com/repos/${login}/${repo}/readme`;
    const { download_url } = await fetch(uri).then(res =>
      res.json()
    );
    const markdown = await fetch(download_url).then(res =>
      res.next()
    );
    console.log(`Markdown for ${repo}\n\n${markdown}`);
  };
  #+end_src
**** <RepositoryReadme> with =useCallback()= in loadReadme() and =useEffect()= to run it
 - Note: the 3 states again
   #+begin_src js
   import React, {
     useState,
     useEffect,
     useCallback,
   } from "react";
   import ReactMarkdown from "react-markdown";

   export default function RepositoryReadme({ repo, login }) {
     const [loading, setLoading] = useState(false);
     const [error, setError] = useState();
     const [markdown, setMarkdown] = useState("");

     // Same as before, but with a useCallback() and set of some state
     const loadReadme = useCallback(async (login, repo) => {
       setLoading(true);
       const uri = `https://api.github.com/repos/${login}/${repo}/readme`;
       const { download_url } = await fetch(uri).then(res =>
         res.json()
       );
       const markdown = await fetch(download_url).then(res =>
         res.text()
       );
       setMarkdown(markdown);
       setLoading(false);
     },[]);

     useEffect(()=> {
       if (!repo || !login) return;
       loadReadme(login, repo).catch(setError);
     }, [repo]);

     if (error) return <pre>{JSON.stringify(error, null, 2)}</pre>;
     if (loading) return <p>Loading...</p>;
     return <ReactMarkdown source={markdown} />;
   }
   #+end_src
**** <RepoMenu>
  #+begin_src js
  export function RepoMenu({ repositories, login }) {
    const [{ name }, previous, next ] = useIterator(
      repositories
    );
    return (
      <>
        <div style={{ display: "flex" }}>
          <button onClick={previous}>&lt;</button>
          <p>{name}</p>
          <button onClick={next}>&gt;</button>
        </div>
        <RepositoryReadme login={login} repo={name} />
      </>
    );
  }
  #+end_src
*** Parallel Requests, explode components
 - The reason our application is currently making a waterfall forequest is that
   the components are rendered inside of one another.
**** Put them all on the same level. Will make them fetch at the same time.
   #+begin_src js
   import React, { useState } from "react";
   import SearchForm from "./SearchForm";
   import GitHubUser from "./GitHubUser";
   import UserRepositories from "./UserRepositories";
   import RepositoryReadme from "./RepositoryReadme";
   export default function App() {
     const [login, setLogin] = useState("moonhighway");
     const [repo, setRepo] = useState("learning-react");
     return (
       <>
         <SearchForm value={login} onSearch={setLogin} />
         <GitHubUser login={login} />
         <UserRepositories
           login={login}
           repo={repo}
           onSelect={setRepo}
         />
         <RepositoryReadme login={login} repo={repo} />
       </>
     );
   }
   #+end_src
**** <RepoMenu> modification
  #+begin_src js
  export function RepoMenu({ repositories, selected, onSelect = f => f}) {
    const [{ name }, previous, next] = useIterator(
      repositories,
      selected ? repositories.findIndex(repo => repo.name === selected) : null
    );
    //...
  }
  #+end_src
**** <UserRepositories>
  #+begin_src js
  <Fetch
    uri={`https://api.github.com/users/${login}/repos`}
    renderSuccess={({ data }) => (
      <RepoMenu
        repositories={data}
        selected={repo}
        onSelected={onSelected}
      />
    )}
  />
  #+end_src
*** (&&) <App> Waiting for values to render components
  #+begin_src js
  export default function App() {
    const [login, setLogin] = useState();
    const [repo, setRepo] = useState();
    return (
      <>
        <SearchForm value={login} onSearch={setLogin} />
        {login && <GitHubUser login={login} />}
        {login && (
          <userRepositories
            login={login}
            repo={repo}
            onSelect={setRepo}
          />
        )}
        {login && repo && (
          <RepositoryReadme login={login} repo={repo} />
        )}
      </>
    );
  };
  #+end_src
*** Cancelling requests, when component gets umounted
**** <App> Update onSearch() to set *repo* empty if *login* is empty
  #+begin_src js
  export default function App() {
    const [login, setLogin] = useState("moonhighway");
    const [repo, setRepo] = useState("learning-react");
    const handleSearch = login => {
      if (login) return setLogin(login);
      setLogin("");
      setRepo("");
    };
    if (!login)
      return (
        <SearchForm value={login} onSearch={handleSearch} />
      );
    return (
      <>
        <SearchForm value={login} onSearch={handleSearch} />
        <GitHubUser login={login} />
        <UserRepositories
          login={login}
          repo={repo}
          onSelect={setRepo}
        />
      </>
    );
  }
  #+end_src
**** =useMountedRef()= custom hook, to trigger actions on mount/umount
  - useRef(): When a component umounts, state is wiped clean. But refs are still available.
  #+begin_src js
  export function useMountedRef() {
    const mounted = useRef(false);
    useEffect(() => {
      mounted.current = true;
      return () => (mounted.current = false);
    });
  }
  #+end_src
**** <RepositoryReadme> (inside the component)
  #+begin_src js
  const mounted = useMountedRef(); // use the hook

  const loadReadme = useCallback(async (login, repo) => {
    setLoading(true);
    const uri = `https://api.github.com/repos/${login}/${repo}/readme`;
    const { download_url } = await fetch(uri).then(res =>
      res.json()
    );
    const markdown = await fetch(download_url).then(res =>
      res.json()
    );
    if (mounted.current) { // check if component is mounted
      setMarkdown(markdown);
      setLoading(false);
    }
  }, []);
  #+end_src
**** =usefetch()= custom hook update, to use our mount check
  #+begin_src js
  const mounted = useMountedRef();

  useEffect(() => {
    if (!uri) return;
    if (!mounted.current) return; // !!
    setLoading(true);
    fetch(uri)
      .then(data => {
        if (!mounted.current) throw new Error("component is not mounted"); // !!
        return data;
      })
      .then(data => data.json())
      .then(setData)
      .then(() => setLoading(false))
      .catch(error => {
        if (!mounted.current) return; // !!
        setError(error);
      });
  }); // dep array ommited
  // ...
  #+end_src
** DONE 10 - React Testing
*** ESLint (Quality)
 - Old: JSHint, JSLint
 - Hinting or Linting: the process of analyzing JS code.
 - https://github.com/dustinspecker/awesome-eslint
 - npm install eslint --save-dev
**** npx eslint --init
 - What it does?
   1) installs eslint-plugin-react
   2) adds deps on package.json
   3) creates .eslintrc.json or .eslintrc.yml
 - npx eslint sample.js
   npx eslint .
 - .eslintignore add dist/assets/
 - npm run lint
   add on package.json a script
   #+begin_src js
   {
     "scripts": {
       "lint": "eslint ."
     }
   }
   #+end_src
**** npm install eslint-plugin-react-hooks --save-dev
  add on .eslintrc.json
  #+begin_src js
  {
    "plugins": [
      "react-hooks"
    ],
    "rules": {
      "react-hooks/rules-of-hooks": "error",
      "react-hooks/exhaustive-deps": "warn"
    }
  }
  #+end_src
**** npm install eslint-plugin-jsx-a11y
    Checks for not breakage of accesability rules
    Add on .eslintrc.json
    #+begin_src js
    {
      "plugins": [
        "jsx-a11y"
      ],
      "extends": [
        "plugin:jsx-a11y/recommended"
      ],
    }
    #+end_src
*** Prettier (Formatting)
 - https://prettier.io/docs/en/options.html
 - npm install -g prettier
 - Needed for compatibility with ESLint
   npm install eslint-config-prettier --save-dev // turns off ESLint rules
   npm install eslint-plugin-prettier --save-dev // compat rules
 - prettier --check file.js
   prettier --write file.js
   prettier --write "src/*.js"
 - .prettierrc
   #+begin_src js
   {
     "semi": true,
     "trailingComma": none,
     "singleQuote": false,
     "printWidth": 80
   }
   #+end_src
 - .eslintrc.json
   #+begin_src js
   {
     "extends": [ "plugin:prettier/recommended" ],
     "plugins": [ "prettier" ],
     "rules": { "prettier/prettier": "error" }
   }
   #+end_src
*** Typechecking for React Applications
**** prop-types (App.propTypes)
 - Originally prepackaged with React, now optional
   npm install prop-types --save-dev
 - Types:
   PropTypes
   .array .object .bool .func .number .string .symbol .any
   .oneOf([])
   .isRequired
 - Usage, we type the props
   #+begin_src js
   import PropTypes from "prop-types";
   function App({ name }) {
     return (
       <div>
         <h1>{name}</h1>
       </div>
     );
   }
   App.propTypes = {
     name: PropTypes.string
   };
   ReactDOM.render(
     <App name="React" />
     document.getElementById("root");
   );
   #+end_src
**** flow-bin (type Props)
 - https://flow.org/en/docs/config/
 - npm install --save flow-bin
 - npm run flow
 - npm run flow init # will create .flowconfig
   #+begin_src
   [ignore]
   [include]
   [libs]
   [lints]
   [options]
   [strict]
   #+end_src
 - package.json
   #+begin_src js
   {
     "start": "react-scripts start",
     "build": "react-scripts build",
     "test" : "react-scripts test",
     "eject": "react-scripts eject",
     "flow" : "flow"
   }
   #+end_src
 - On each file add this to check it
   //@flow
 - Defines the props types
   #+begin_src js
   type Props = {
     item: string // might add a ? to indicate optional
   };
   function App(props: Props) {
   //...
   }
   #+end_src
 - Bug: check for nullable document.getElementById("root")
   #+begin_src js
   const root = document.getElementById("root");
   if (root != null) {
     ReactDOM.render(<App item="jacket" />, root);
   }
   #+end_src
**** TypeScript (type Props)
 - docs https://www.typescriptlang.org/docs/
 - cheatsheet https://github.com/typescript-cheatsheets/react
 - npm uninstall l-g create-react-app
 - npx create-react-app my-type --template typescript
 - packages.json: Any dependency that stars with
   @types/ describes the type definitons for a library.
 - .tsconfig.json
 - We can type and destructure
   function App({ item }: AppProps)
 - App.tsx
   #+begin_src typescript
   type AppProps = {
     item: string;
   };
   ReactDOM.render(
     <App item="jacket" />
     document.getElementById("root")
   );
   #+end_src
*** TDD
- Wrox's 2011 Book: Professional TDD with C#, Chapter 4
- Steps
  1) Write the *test* first
  2) Run the *tests* and watch them fail, before you write your code (red)
  3) Write the minimal amount of *code* required to make the test pass (green)
  4) Refactor *both* the code and the tests, try to make them look beatiful (gold)
*** Jest
 - npm run test
   npm test
 - Let's you access the DOM via JSDOM, to check on it if it render ok
 - Already configured with *create-react-app*
 - SUT: System Under Test, could be a function
 - .toBe() .toEqual()
 - describe(DESC, () => { test() })
   to wrap several test()
 - src/functions.js
   #+begin_src js
   export default function timesTwo(a) {
     return a * 2
   }
   #+end_src
 - src/functions.test.js
   #+begin_src js
   import { timesTwo } from "./functions";
   // (description, fn, timeout=5s)
   test("Multiplies by two", () => {
     expect(timesTwo(4)).toBe(8);
   });
   #+end_src
*** Testing React Components
 - JEST https://github.com/testing-library/jest-dom#custom-matchers
 - With Node.js, using *jsdom* package to simulate a DOM
 - Star.test.js
   #+begin_src js
   import React from "react";
   import ReactDOM from "react-dom";
   import Star from "./Star";
   test("renders a star", () => {
     const div = document.createElement("div")
     ReactDOM.render(<Star />, div);
     expect(div.querySelector("svg")).toBeTruthy();
   });
   #+end_src
**** extend "React Testing Library" aka @testing-library
 - is a project that was started by Kent C. Dodds as a way to enforce good testing practices
 - is an *umbrella* over many testing package for libraries like Vue, Svelte, Reason, Angular and more
 - Or import ALL extended expects (like on create-react-app)
   #+begin_src js
   import "@testing-library/jest-dom/extended-expect"
   #+end_src
 - Using Testing Library
   #+begin_src js
   import { toHaveAttribute } from "@testing-library/jest-dom";
   expect.extend({ toHaveAttribute });
   test("renders a star", () => {
     const div = document.createElement("div");
     ReactDOM.render(<Star />, div);
     expect(div.querySelector("svg")).toHaveAttribute("id", "star");
   });
   #+end_src
**** Queries - { getByText } = render()
 - render(), returns a series of queries
   #+begin_src js
   import { render } from "@testing-library/react"}
   test("renders an h1", () => {
     const { getByText } = render(<Star />; // @testing-library
     const h1 = getByText(/GreatStar/);
     expect(h1).toHaveTextContent("Great Star"); // Jest
   });
   #+end_src
**** Testing Events - render() - getByLabelText/getByTestId - fireEvent()
 - You can also add *data-testid* html prop to the component to help identify it while using
   getByTestId()
  #+begin_src js
  import { render, fireEvent } from "@testing-library/react";
  test("selecting the checkbox should change the value of checkd to true", () => {
    const { getByLabelText } = render(<Checkbox />);
    const checkbox = getByLabelText(/not checked/i);
    fireEvent.click(checkbox);
    expect(checkbox.checked).toEqual(true);
  });
  #+end_src
**** Code Coverage (Istanbul)
  - https://martinfowler.com/bliki/TestCoverage.html
  - npm test -- --coverage
  - Shooting for anything above 85% is a good target.
** DONE 11 React Router <Router path= element= />
 - https://github.com/remix-run/react-router
 - https://reactrouter.com/
 - Unlike Angular, Ember, or Backbone. React Doesn't come with a standard router.
 - React Router: created by Michael Jackson and Ryan Florence
 - Book uses version 6, before it was released on @experimental
 - npm install react-router react-router-dom
*** <Router> index.js
 - Component passes information about the current loation to any children
 - Used once
 - Near the root of our component tree
   #+begin_src js
   import React from "react";
   import { render } from "react-dom"; // ?
   import App from "./App";
   import { BroserRouter as Router } from "react-router-dom"
   render(
     <Router>
       <App />
     </Router>,
     document.getElementById("root")
   );
   #+end_src
*** <Routes> App.js
   #+begin_src js
   import React from "react";
   import { Routes, Route } from "react-router-dom";
   import {
     Home,
     About,
     Events,
     Products,
     Contact
   } from "./pages";
   function App() {
     return (
       <div>
         <Routes>
           <Route path="/" element={<Home />} />
           <Route path="/about" element{<About />} />
           <Route path="/events" element={<Events />} />
           <Route path="/products" element={<Products />} />
           <Route path="/contact" element={<Contact />}>
         </Routes>
       </div>
     );
   }
   #+end_src
*** <Link> Home() creates browser links to paths
   #+begin_src js
   import { Link } from "reat-router-dom";
   export function Home() {
     return (
       <div>
         <h1>[Company Website]</h1>
         <nav>
           <Link to="about">About</Link>
           <Link to="events">Events</Link>
           <Link to="products">Products</Link>
           <Link to="contact">Contact Us</Link>
         </nav>
       </div>
     );
   }
   #+end_src
*** =useLocation()= Hook for 404 page
 - Wildcard path to Whoops404 component
   #+begin_src js
   <Route path="*" element={<Whoops404 />} />
   #+end_src
 - useLocation() to get the current location
   #+begin_src js
   export function Whoops404() {
     let location = useLocation();
     console.log(location);
     return (
       <div>
         <h1> Resouce not found at {location.pathname} </h1>
       </div>
     );
   }
   #+end_src
*** <Outlet> for nested <Route>
 - Put in the parent component
 - Define the nested routes on App()
  #+begin_src js
    <Routes>
      <Route path="about" element={<About/>}>
        <Route path="services" element={<Services/>}/>
        <Route path="history" element={<History/>}/>
        <Route path="location" element={<Location/>}/>
      </Route>
      // ...
    </Routes>
  #+end_src
 - pages.js, add <Outlet/> on <About>
   #+begin_src js
   import {
     Link,
     useLocation,
     Outlet
   } from "react-router-dom";
   export function About() {
     return (
       <div>
         <h1>[About]</h1>
         <Outlet />
       </div>
     );
   }
   #+end_src
*** <Redirect>
 - Why? user bookmarks
 - /services -> /about/services
   #+begin_src js
   import {
     Routes,
     Route,
     Redirect
   } from "react-router-dom";
   function App() {
     return (
       <div>
         <Routes>
         <Route path="/" element={<Home />} />
         <Redirect from="services" to="about/services">
         </Routes>
       </div>
     );
   }
   #+end_src
*** =useRoutes()=
  - <Route> is actually a wrapper around useRoutes()
  - Takes a list of objects, with keys (path, element, children, redirecTo)
  - Returns a component that App() can return
*** Routing Parameters, =useParams()=
 - Ideal to obtains data that affects the presentation
 - ONLY used when we want to capture this details on the URL
**** index.js App is wrapped by <Router>
**** App.js, define a path with ":id"
   #+begin_src js
   import { Routes, Route } from "react-router-dom";
   import { ColorDetails } from "./ColorDetails";
   export default function App() {
     return (
     <ColorProvider>
       <AddColorForm />
       <Routes>
         <Route path="/" element="{<ColorList/>}"/>
         <Route path=":id" element="{<ColorDetails/>}"> // !!!
       </Routes>
     </ColorProvider>
     );
   }
   #+end_src
**** ColorDetails.js, =useParams()=
  #+begin_src js
  import { useParams } from "react-router-dom";
  export function ColorDetails() {
    let { id } = useParams();
    let { colors } = useColors();
    let foundColor = colors.find(
      color => color.id === id
    );
    return (
      <div>
        <div
          style={{
            backgroundCOlor: foundColor.color,
            height: 100,
            width: 100
          }}
          ></div>
          <h1>{foundColor.title}</h1>
          <h1>{foundColor.color}</h1>
      </div>
    );
  }
  #+end_src
**** Color.js, =useNavigate()= to navigate to the <ColorDetails>
 - retruns a function we can use to navigate to another page
  #+begin_src js
  import { useNavigate } from "react-router-dom";
  //...
  let navigate = useNavigate();
  return (
    <section
      className="color"
      onClick={() => navigate(`/${id}`)}
    >
    // Color component
    </section>
  );
  #+end_src
** DONE 12 React and the Server
 - https://medium.com/@ghengeveld/isomorphism-vs-universal-javascript-4b47fb481beb#.ldhznr24c
   https://www.youtube.com/watch?v=HaQhoGWrbaE&t=1049s
 - React is a view layer; it's intended to render UI.
 - Isomorphism vs Universalism
   Isomorphic applications: can render on multiple platforms
   Universal code: the exact same code, can run on multiple platforms
 - fetch() is available only on the browser
 - fetch() is not available on node.js, but on
   1. isomorphic-fetch module
   2. https module (built-in)
 - ReactDOM.render()
   ReactDOM.renderToString() // returns html string
   ReactDOM.hydrate()
*** Express
**** server/index.js - basic
  #+begin_src javascript
  import express from "express";
  const app = express();
  app.use(express.static("./build")); // serves the build folder
  #+end_src
**** server/index.js - ReactDOMServer.renderToString
   #+begin_src javascript
   import express from "express";
   import React from "react";
   import ReactDOMServer from "react-dom/server"; // !??!
   import { Menu } from "../src/Menu.js";
   const PORT = process.env.port || 4000;
   const app = express();
   app.use(express.static("./build")); // serves the build folder
   app.get("/*", (req, res) => {
     const app = ReactDOMServer.renderToString(
       <Menu/>
     );
     const indexFile = Path.resolve(
       "./build/index.html"
     );
     fs.readFile(indexFile, "utf8", (err,data) => {
       return res.send(
         data.replace(
           '<div id="root"></div>',
           `<div id="root">${app}</div>`
         )
       );
     });
   });
   app.listen(PORT, () =>
     console.log(`Server is listening port ${PORT}`));
   #+end_src
*** Babel
- npm install
  @babel/core
  @babel/preset-env
  babel-loader
  nodemon
  npm-run-all
  webpack
  webpack-cli
  webpack-node-externals
- .babelrc
  {
    "presets": ["@babel/preset-env", "react-app"]
  }
*** Webpack
 - .env
   SKIP_PREFLIGHT_CHECK=true
 - webpack.server.js
    #+begin_src js
    const path = require("path");
    const nodeExternals = require("webpack-node-externals");
    module.exports = {
      entry: "./server/index.js",
      target: "node",
      externals: [nodeExternals()],
      output: {
        path: path.resolve("build-server"),
        filename: "index.js"
      },
      module: {
        rules: [
        {
          test: /\.js$/,
          use: "babel-loader"
        }
        ]
      }
    };
    #+end_src
*** package.json
 - dev:build-server: runs webpack
   dev:start       : runs server nodemon
   dev             : runs both in parallel
    #+begin_src js
    {
      "scripts": {
        "dev:build-server": "NODE_ENV=development webpack --config webpack.server.js --mode=development -w",
        "dev:start": "nodemon ./server-build/index.js",
        "dev" "npm-run-all --parallel build dev:*"
      }
    }
    #+end_src
*** Next.js
**** npm init -y
   npm install --save react react-dom next
   mkdir pages
**** package.json
   #+begin_src js
   "scripts": {
     "dev": "next",
     "build": "next build",
     "start": "next start"
   }
   #+end_src
**** pages/index.js
 - No need to import react or reactdom
  #+begin_src js
  export default function Index() {
    return (
      <Layout>
        <div>
          <p>Hello everyone!</p>
        </div>
      </Layout>
    );
  }
  #+end_src
**** npm run dev
**** pages/Pets.js
 - if getINitialProps() is present in the component, Next.js will render the page in repose to each requst.
   SSR = Server-side rendered
 - Will load on localhost:3000/pets
 - A page with state that cannot be statically generated
   #+begin_src js
   import fetch from "isomorphic-unfetch";
   Pets.getInitialProps = async function() {
     const res = await fetch(`htp://pet-library.moonhighway.com/api/pets`);
     const data = await res.json();
     return {
       pets: data
     };
   }
   export default function Pets() {
     return (
       <Layout>
         <div>
           <h1>Pets!</h1>
           <ul>
             {props.pets.map(pet => (
               <li key={pet.id}>{pet.name}</li>
             ))}
           </ul>
         </div>
       </Layout>
     );
   }
   #+end_src
**** Pages/Header.js
 - Using <Link>, a wrapper links (like <Route>?)
   #+begin_src js
   import Link from "next/link";
   const linkStyle = {
     marginRight: 15,
     color: "salmon"
   };
   export default function Header() {
     return (
       <div>
         <Link href="/">
           <a style={linkStyle}>Home</a>
         </Link>
         <Link>
           <a style={linkStyle}>Pets</a>
         </Link>
       </div>
     );
   }
   #+end_src
**** pages/Layout.js
  #+begin_src js
  import Header from "./Header";
  export function Layout(props) {
    return (
      <div>
        <Header />
        {props.children}
      </div>
    );
  }
  #+end_src
*** Gatsby
 - for content driven website: blogs or static content
 - npm install -g gatsby-li
   gatsby new pets
   gatsby develop
 - components/
   - Header.js ???
   - Layout.js ???
   - seo.js
 - images/
 - pages/
   - index.js
   - 404.js
   - page-2.js
   - page-3.js
     #+begin_src js
     import React from "react";
     import { Link } from "gatsby";
     import Layout from "../components/layout";
     import SEO from "../components/seo";
     const ThirdPage = () => (
       <Layout>
         <SEO title="Page three" />
         <h1>Hi from the third page</h1>
         <Link to="/">Go back to the homepage</Link>
       </Layout>
     );
     export default ThirdPage;
     #+end_src
* 20 | Fullstack React with Typescript | Nate Murray
 - Types reduce 15% of bugs on JS https://earlbarr.com/publications/typestudy.pdf
 - TDD between 40%-90% of bug reduce http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.210.4502&rep=rep1&type=pdf
** Trello App
 - package.json https://docs.npmjs.com/cli/v8/configuring-npm/package-json
 - yarn
   yarn dev
 - npx create-react-app --template typescript trello-clone
   - Allow us to use c-r-a without installing it
 - yarn add nanoid@3.1.22
   yarn add use-immer@0.5.1 # allows you to mutate an object, and create a new one based on your mutation
   yarn add react-dnd@14.0.1 react-dnd-html5-backend@4.0.0 # drag and drop
 - These are the same, which could be a problem if no *default* is present on the module
   #+begin_src js
   import name from 'module';
   import { default as name } from 'module';
   #+end_src
 - Functional component, you don't need to declare the type returned.
   But you can.
   #+begin_src typescript
   export const Example: React.FC = () => {
     return <div>Functional component text</div>;
   }
   #+end_src
 - When I eed to know the name of some element type
   https://github.com/DefinitelyTyped/DefinitelyTyped/blob/master/types/react/global.d.ts
 - React Events
   https://reactjs.org/docs/events.html
 - React Types
   https://github.com/DefinitelyTyped/DefinitelyTyped/blob/14d95eb0fe90f5e0579c49df136cccdfe89b2855/types/react/index.d.ts#L1211
*** @types/*
 - https://github.com/DefinitelyTyped/DefinitelyTyped
 - packages contain type definitions for libraries originally written in JS
 - Example of a <MODULE>.d.ts definition
   declare function saveData(data: string): void
*** public/ - static files, untouched by the build
    https://create-react-app.dev/docs/using-the-public-folder/
    - index.html
    - manifest.json
      metadata for https://web.dev/progressive-web-apps/
      details https://developer.mozilla.org/en-US/docs/Web/Manifest
    - robots.txt
    - favicon.ico logo192.png logo512.png
*** src/    - processed by webpack, added to the bundle
 - App.test.tsx
 - setupTests.ts
 - reportWebVitals.ts
**** utils/useFocus.ts
  #+begin_src typescript
  import { useRef, useEffect } from "react";
  export const useFocus = () => {
    const ref = useRef<HTMLInputElement>();     // Will create a    mutable ref
    const ref = useRef<HTMLInputElement>(null); // Will create an inmutable ref
    useEffect(() => {
      ref.current?.focus() // chaining .?
    }, []);
    return ref;
  }
  #+end_src
**** styles.ts
  - We use the *flexbox layout*
    flex 0 to not try to taka all the horizontal space
  #+begin_src js
  export const AppContainer = styled.div`
    align-items: flex-start;
    background-color: #3179ba;
    display: flex;
    flex-direction: row;
    height: 100%;
    padding: 20px;
    width: 100%;
  `
  export const ColumnContainer = styled.div`
    background-color: #ebecf0;
    width: 300px;
    min-height: 40px;
    margin-right: 20px;
    border-radius: 3px;
    padding: 8px 8px;
    flex-grow: 0;
  `
  export const ColumnTitle = styled.div`
    padding: 6px 16px 12px;
    font-weight: bold;
  `
  type AddItemButtonProps = {
    dark?: boolean
  }
  export const AddItemButton = styled.button<AddItemButtonProps>`
    background-color: #ffffff3d;
    border-radius: 3px;
    border: none;
    color: ${props => (props.dark ? "#000" : "#fff")};
    cursor: pointer;
    max-width: 300px;
    padding: 10px 12px;
    text-align: left;
    transition: background 85ms ease-in;
    width: 100%;
    &:hover {
      background-color: #ffffff52;
    }
  `;
  export const NewItemFormContainer = styled.div`
    max-width: 300px;
    display: flex;
    flex-direction: column;
    width: 100%;
    align-items: flex-start;
  `;
  export const NewItemButton = styled.button`
    background-color: #5aac44;
    border-radius: 3px;
    border: none;
    box-shadow: none;
    color: #fff;
    padding: 6px 12px;
    text-align: center;
  `;
  export const NewItemInput = styled.input`
    border-radius: 3px;
    border: none;
    box-shadow: #091e4240 0px 1px 0px 0px;
    margin-bottom: 0.5rem;
    padding: 0.5rem 1rem;
    width: 100%;
  `;
  #+end_src
**** index.css
 - React.CSSProperties, type to pass a *style* prop of a component
   We provide the props with CamelCase, unlike the snake-case of CSS
 - https://github.com/styled-components/styled-components
   yarn add styled-components@^5.2.1 @types/styled-components@^5.1.9
   #+begin_src js
   import styled from "styled-components";
   const Button = styled.button`
     background-color: #5aac44;
     border-radius: 3px;
     border: none;
     box-shadow: none;
   `
   <Button>Clickme</Button>
   #+end_src
 - Source
  #+begin_src css
  html {
    box-sizing: border-box; /* include padding and border on W and H cals*/
  }
  *, *:before, *:after {
    box-sizing: inherit;
  }
  html, body, #root {
    height: 100%
  }
  #+end_src
**** index.tsx - webpack will start to build from it
 - <React.StrictMode>, only affects warnings for dev
   https://reactjs.org/docs/strict-mode.html
 - import './index.css';
 - reportWebDetails - https://create-react-app.dev/docs/measuring-performance/
 - Declare types
   #+begin_src typescript
   const text: string = "what"
   const text         = <string>"what"
   #+end_src
 - JSX
   https://reactjs.org/docs/introducing-jsx.html
   https://www.typescriptlang.org/docs/handbook/jsx.html#the-as-operator
 - Code
   #+begin_src typescript
   import React from "react";
   import ReactDOM from "react-dom";
   import "./index.css";
   import { App } from "./App";
   import { AppStateProvider } from "./state/AppStateContext";
   import { DndProvider } from "react-dnd";
   import { HTML5Backend as Backend } from "react-dnd-html5-backend";
   ReactDOM.render(
     <React.StrictMode>
       <DndPRovider backend={Backend}>
         <AppStateProvider>
           <App />
         </AppStateProvider>
       </DndProvider>
     </React.StrictMode>,
     document.getElementById("root")
     </React.StrictMode>
   );
   #+end_src
**** App.tsx
 - allowSyntheticDefaultImports, which will make the import of react work
 - You can use JSX without needing to import React (2020)
   It no longers converts to React.CreateElement(), although that is also available
   Still need to import it for Hooks
   npm update @babel/core @babel/plugin-transform-react-jsx // OR
   npm update @babel/core @babel/preset-react
   https://reactjs.org/blog/2020/09/22/introducing-the-new-jsx-transform.html
***** without context
   #+begin_src typescript
   import { AddNewItem } from "./AddNewItem";
   import { Column } from "./Column";
   import { Card } from "./Card";
   import { AppContainer } from "./styles";
   import { AddNewItem } from "./AddNewItem";
   export const App = () => {
     return (
       <AppContainer>
         <Column text="To Do">
           <Card text="Generate app scaffold"/>
         </Column>
         <Column text="In Progress">
           <Card text="Learn Typescript"/>
         </Column>
         <Column text="Done">
           <Card text="Begin to use static typing"/>
         </Column>
         <AddNewItem toggleButtonText="+ Add another list" onAdd={console.log} />
       </AppContainer>
     );
   }
   #+end_src
***** with context
  #+begin_src typescript
  import { addList } from "./state/actions";
  import { AddNewItem } from "./AddNewItem";
  import { Column } from "./Column";
  import { Card } from "./Card";
  import { AppContainer } from "./styles";
  import { AddNewItem } from "./AddNewItem";
  import { useAppState } from "./AppStateContext";
  export const App = () => {
    const { lists, dispatch } = useAppState();
    return (
      <AppContainer>
        {lists.map((list) => (
          <Column text={list.text} key={list.id} id={list.id} />
        ))}
        <AddNewItem
          toggleButtonText="+ Add another list"
          onAdd={text => dispatch(addList(text))}
        />
      </AppContainer>
    );
  }
  #+end_src
**** react-app-end.d.ts
 - *.d.ts contain TS type definitions
 - /// <reference types="react-scripts" />
 - Will include the *.d.ts package,except that a different =types:= is declared
   https://github.com/facebook/create-react-app/blob/main/packages/react-scripts/package.json#L29
 - Triple slash directives
   https://www.typescriptlang.org/docs/handbook/triple-slash-directives.html#-reference-types-
 - A declaration on react-app.d.ts, allow us to *import* SVG files
   As result SVG images can be imported as React Components
   https://create-react-app.dev/docs/adding-images-fonts-and-files/#adding-svgs
   #+begin_src typescript
   import { ReactComponent as Logo } from './logo.svg';
   import fullimagepath from './logo.svg';
   #+end_src
**** Card.tsx
  #+begin_src typescript
  import { CardContainer } from "./styles";
  type CardProps = {
    text: string
    id: string
  };
  export const Card = ({ text } : CardProps) => {
    return <CardContainer>{text}</CardContainer>;
  }
  #+end_src
**** Columnt.tsx
***** without context
 - we could add a ? to the field of the type to make it optional (aka that it can be also *undefined*)
    #+begin_src typescript
    type ColumnProps = {
      text: string
    }
    export const Column: FC<ColumnProps> = ({ text, children }) => {
      return (
        <ColumnContainer>
          <ColumnTitle>{text}</ColumnTitle>
          {children}
          <AddNewItem
            toggleButtonText="+ Add another task"
            onAdd={console.log}
            dark
          />
        </ColumnContainer>
      );
    };
    #+end_src
***** with context
  #+begin_src typescript
  import { useAppState } from "./AppStateContext";
  import { Card } from "./Card";
  import { addTask } from "./state/actions";
  type ColumnProps = {
    text: string
    id: string
  }
  export const Column = ({ text, id }: ColumnProps) => {
    const { getTasksByListId, dispatch } = useAppState();
    const tasks = getTasksByListId(id);
    return (
      <ColumnContainer>
        <ColumnTitle>{text}</ColumnTitle>
        {tasks.map(task => (
          <Card text={task.text} key={task.id} id={task.id} />
        ))}
         <AddNewItem
            toggleButtonText="+ Add another task"
            onAdd={text => dispatch(addTask(text,id))}
            dark
          />
         </ColumnContainer>
    );
  };
  #+end_src
***** 0) using a *type* for props
  - can use *type* or *interface* for the props
  #+begin_src typescript
  import { ColumnContainer, ColumnTitle } from "./styles";
  type ColumnProps = {
    text: string;
  };
  export const Column = ({ text }: ColumnProps) => {
    return (
    <ColumnContainer>
      <ColumnTitle>{ text }</ColumnTitle>
    </ColumnContainer>
    );
  }
  #+end_src
***** 1) FC
   #+begin_src typescript
   import { FC } from "react";
   export const Column: FC<ColumnProps> = ({ text, children }) => {
     return (
       <ColumnContainer>
         <ColumnTitle>{ text }</ColumnTitle>
         { children }
       </ColumnContainer>
     );
   }
   #+end_src
***** 2) React.PropsWithChildren
 - Definition: Where P is a *type argument*
  #+begin_src typescript
  type React.PropsWithChildren<P> = P & {
    children?: React.ReactNode;
  };
  #+end_src
 - Using it
   #+begin_src typescript
   type ColumnProps = ReactPropsWithChildren<{
     text: string
   }>
   // Same as
   type ColumnProps = {
     text: string
     children?: React.ReactNode;
   }
   #+end_src
**** AddNewItem.tsx
  #+begin_src typescript
  import { useState } from "react";
  import { AddItemButton } from "./styles";
  import { NewItemForm } from "./NewItemForm";
  type AddNewItemProps = {
    onAdd(text: string): void
    toggleButtonText: string
    dark?: boolean
  }
  export const AddNewItem = (props: AddNewItemProps) => {
    const [showForm, setShowForm] = useState(false);
    const { onAdd, toggleButtonText, dark } = props;
    if (showForm) {
      // We show item creation form here
      return (
        <NewItemForm
          onAdd={text => {
            onAdd(text)
            setShowForm(false)
          }
        />
      );
    }
    return (
      <AddItemButton dark={dark} onClick={() => setShowForm(true)}>
        {toggleButtonText}
      </AddItemButton>
    );
  }
  #+end_src
**** NewItemForm.tsx
  #+begin_src typescript
  import { useState } from "react";
  import { NewItemFormContainer, NewItemButton, NewItemInput } from "./styles";
  import { useFocus } from "./utils/useFocus";
  type NewItemFormProps = {
    onAdd(text: string): void
  }
  export const NewItemForm = ({ onAdd }: NewItemFormProps) => {
    const [text, setText] = useState("");
    const inputRef = useFocus();
    const handlAddText = (
      event: React.KeyboardEvent<HTMLInputElement>
    ) => {
      if (event.key === "Enter") {
        onAdd(text);
      }
    };
    return (
      <NewItemFormContainer>
        <NewItemInput
          ref={inputRef}
          value={text}
          onKeyPress={handleAddText}
          onChange={e => setText(e.target.value)}
        />
        <NewItemButton onClick={() => onAdd(text)}> Create </NewItemButton>
      </NewItemFormContainer>
    );
  }
  #+end_src
**** utils/arrayUtils.ts
 - =Type Constraint=
   WE willuse a type variable *TItem* that extend *Item*
  #+begin_src typescript
  type Item = {
    id: string
  }
  export const findItemIndexById = <TItem extends Item>(
    items: TItem[],
    id: string
  ) => {
    return items.findIndex((item: TItem) => item.id === id)
  };
  export const moveItem = <TItem>(array: TItem[], from: number, to: number) => {
    const item = array[from];
    return insertItemAtIndex(removeItemAtIndex(array, from), item, to);
  }
  export function removeItemAtIndex<TItem>(array: TItem[], index: number) {
    return [...array.slice(0, index), ...array.slice(index+1)]
  }
  export function insertItemAtIndex<TItem>(
    array: TItem[],
    item: TItem,
    index: number
  ) {
    return [...array.slice(0, index), item, ...array.slice(index)]
  }
  #+end_src
**** state/AppStateContext.tsx
  #+begin_src typescript
  import { createContext, useContext, Dispatch, FC } from "react";
  import { AppState, appStateReducer, List, Task } from "./state/appStateReducer";
  import { Action } from './actions';
  import { useImmerReducer } from "use-immer";
  type AppStateContextProps = {
    lists: List[]
    getTaskByListId(id: string): Task[]
    dispatch: Dispatch<Action>
  }

  const appData: AppState = {
    lists: [
    // ...
    ]
  };

  const AppStateContext = createContext<AppStateContextProps>({} as AppStateContextProps);

  export const useAppState = () => {
    return useContext(AppStateContext);
  }
  export const AppStateProvider: FC = ({ children }) => {
    const [state, dispatch] = useImmerReducer(appStateReducer, appData);
    const { lists } = appData;
    const getTasksByListId = (id: string) => {
      return lists.find((list) => list.id === id)?.tasks || []
    };
    return (
      <AppStateContext.Provider value={{ lists, getTasksByListId, dispatch }}>
        {children}
      </AppStateContext.Provider>
    );
  }
  #+end_src
**** state/actions.ts
***** Interfaces vs Types for disjunction
   (aka Discriminated Union, where the *type* will be the "discriminant")
  #+begin_src typescript
  // TYPE
  export type Action =
    | { type: "ADD_LIST" ; payload: string }
    | { type: "ADD_TASK" ; payload: { text: string; listId: string } }
    | { type: "MOVE_LIST"; payload: { draggedId: string; hoverId: string } }
  // INTERFACE
  interface AddListAction {
    type: "ADD_LIST"
    payload: string
  }
  interface AddTaskAction {
    type: "ADD_TASK"
    payload: { text: string; listId: string }
  }
  type Action = AddListAction | AddTaskAction
  #+end_src
***** Constructors
  #+begin_src typescript
  export const moveList = (
    draggedId: string,
    hoverId: string
  ): Action => ({
    type: "MOVE_LIST",
    payload: {
      draggedId,
      hoverId
    }
  })
  export const addTask = (
    text: string,
    listId: string,
  ): Action => ({
    type: "ADD_TASK",
    payload: {
      text,
      listId
    }
  })
  export const addList = (
    text: string,
  ): Action => ({
    type: "ADD_LIST",
    payload: text
  })
  #+end_src
**** state/appStateReducer.ts
***** without immer
  #+begin_src typescript
  import { Action } from './actions';
  import { nanoid } from "nanoid";
  export type Task = { id: string; text: string; };
  export type List = { id: string; text: string; tasks: Task[]; };
  export type AppState = { lists: List[]; };
  export const appStateReducer = (state: AppState, action: Action): AppState => {
    switch (action.type) {
      case "ADD_LIST" {
        return {
          ...state,
          lists: [
            ...state.lists,
            { id: nanoid(), text: action.payload, tasks: [] }
          ]
        };
      }
      default: {
        return state
      }
    }
  }
  #+end_src
***** with immer
  #+begin_src typescript
  import { Action } from './actions';
  import { nanoid } from "nanoid";
  import { findItemIndexById, moveItem } from "../utils/arrayUtils"
  export type Task = { id: string; text: string; };
  export type List = { id: string; text: string; tasks: Task[]; };
  export type AppState = { lists: List[]; };
  export const appStateReducer = (draft: AppState, action: Action): AppState => {
    switch (action.type) {
      case "MOVE_LIST" {
        const { draggedId, hoverId } = action.payload;
        const dragIndex = findItemIndexById(draft.lists, draggedId);
        const hoverIndex = findItemIndexById(draft.lists, hoverId);
        draft.lists = moveItem(draft.lists, dragIndex, hoverIndex);
        break;
      }
      case "ADD_TASK": {
        const { text, listId } = action.payload;
        const targetListIndex = findItemIndexById(draft.lists, listId);
        draft.lists[targetListIndex].tasks.push({
          id: nanoid(),
          text
        });
        break
      }
      case "ADD_LIST" {
        draft.lists.push({
          id: nanoid(),
          text: action.payload,
          tasks: [],
        });
        break;
      }
      default: {
        break
      }
    }
  }
  #+end_src
** Redux & Mobx - Poor's Man version of it using =useReducer(F,I)= and React Context API
   #+begin_src typescript
   // state = current state
   // dispatch = to send ACTIONS to the reducer
   const [state, dispatch] = useReducer(reducer, initialState);
   #+end_src
   - Instead of mutate the original object, we create a new one
   - A reducer: is a function that calculates the NEW state, combining
     1) the old *state*
     2) an *action* object
   - Must be Pure Functions
   - Actions: an object, must contain a =type= field and some field for payload.
     - Is common to use a constructor
*** App.tsx
    #+begin_src typescript
    interface State {
      count: number
    }
    type Action = { type: "increment" } | { type: "decrement" }
    const increment = (): Action => ({ type: "increment" });
    const decrement = (): Action => ({ type: "decrement" });
    const counterReducer = (state: State, action: Action) => {
      switch (action.type) {
        case "increment":
          return { count: state.count + 1 }
        case "decrement":
          return { count: state.count - 1 }
        default:
          throw new Error()
      }
    };
    const App = () => {
      const [state, dispatch] = useReducer(counterReducer, { count: 0 })
      return (
        <>
          <p>Count: {state.count}</p>
          <button onClick={dispatch(decrement())}> - </button>
          <button onClick={dispatch(increment())}> + </button>
        </>
      );
    }
    #+end_src
** HOC - High Order Component
 - a factory function, that you create
   1) that accepts a wrapped component as argument
   2) wraps it into another component that implements the desired behavior
   3) returns it
 - Omit<TProps, keyof InjectedProps>
   Allows us to create a type that won't have the keys of the InjectedProps type
 - Typescript Utility Types
   https://www.typescriptlang.org/docs/handbook/utility-types.html
 - keyof
   https://www.typescriptlang.org/docs/handbook/release-notes/typescript-2-1.html#keyof-and-lookup-types
*** 0       - src/withInitialState.tsx =Injector HOC=
   #+begin_src typescript
   import { useState, useEffect, ComponentType } from "react";
   import { AppState } from "./state/appStateReducer";
   type InjectedPRops = {
     initialState: AppState
   }
   export function withInitialState<TProps>(
     WrappedComponent: ComponentType<TProps & InjectedProps>
   ){
     return (props: Omit<TProps, keyof InjectedProps>) => {
       const [initialState, setInitialState] = useState<AppState>({
         lists: [],
         draggedItem: null,
       });
       return (
         <WrappedComponent
           {...props as TProps}
           initialState={initialState}
         />
       );
     }
   }
   #+end_src
*** 1 HACKS - src/withInitialState.tsx =Injector HOC=
    - with "type hacks to help he compiler"
   #+begin_src typescript
   import { useState, useEffect, ComponentType } from "react";
   import { AppState } from "./state/appStateReducer";
   type InjectedPRops = {
     initialState: AppState
   }
   type PropsWIthoutInjected<TBaseProps> = Omit<TBaseProps, keyof InjectedProps>
   export function withInitialState<TProps>(
     WrappedComponent: ComponentType<PropsWithoutInjected<TProps> & InjectedProps>
   ){
     return (props: PropsWithoutInjected<TProps>) => {
       const [initialState, setInitialState] = useState<AppState>({
         lists: [],
         draggedItem: null,
       });
       return (
         <WrappedComponent
           {...props}
           initialState={initialState}
         />
       );
     }
   }
   #+end_src
*** 2 Load  - src/withInitialState.tsx =Injector HOC=
    - with "type hacks to help he compiler"
   #+begin_src typescript
   import { useState, useEffect, ComponentType } from "react";
   import { AppState } from "./state/appStateReducer";
   import { load } from "./api";
   type InjectedPRops = {
     initialState: AppState
   }
   type PropsWIthoutInjected<TBaseProps> = Omit<TBaseProps, keyof InjectedProps>
   export function withInitialState<TProps>(
     WrappedComponent: ComponentType<PropsWithoutInjected<TProps> & InjectedProps>
   ){
     return (props: PropsWithoutInjected<TProps>) => {
       const [initialState, setInitialState] = useState<AppState>({
         lists: [],
         draggedItem: null,
       });
       const [isLoading, setIsLoading] = useState(true);
       const [error, setError] = useState<Error | undefined>();
       if (isLoading) {
         return <div>Loading</div>;
       }
       if (error) {
         return <div>{error.message}</div>;
       }
       useEffect(() => {
         const fetchInitialState = async () => {
           try {
             const data = await load();
             setInitialState(data);
           } catch (e) {
             setError(e);
           }
           setIsLoading(false);
         }
       }, []);
       return (
         <WrappedComponent
           {...props}
           initialState={initialState}
         />
       );
     }
   }
   #+end_src
*** 3 Use   - src/state/AppStateContext.tsx
  #+begin_src typescript
  import { withInitialState } from "../withInitialState";
  type AppStateProviderProps = {
    children: React.ReactNode
    initialState: AppState
  }
  export const AppStateProvider = withInitialState<AppStateProviderProps>(
    ({ children, initialState}) => {
      const [state, dispath] = useImmerReducer(appStateReducer, initialState);
      useEffect(() => {
        save(state);
      }, [state]);
      const { draggedItem, lists } = state;
      const getTasksByListId = (id: string) => {
        return lists.find((list) => list.id === id)?.tasks || []
      }
      return (
        <AppStateContext.Provider value={{ draggedItem, lists, getTasksByListId, dispatch }} >
        {children}
        </AppStateContext.Provider>
      );
    }
  )
  #+end_src
* 22 | React The Road to Enterprise    | Thomas Findlay
  code https://github.com/ThomasFindlay/react-the-road-to-enterprise
** 2 Project configuration and useful extensions
*** craco.config.js
 - Ways to override internal configuration of "create-react-app"
   1) https://www.npmjs.com/package/@craco/craco
   2) https://www.npmjs.com/package/react-app-rewired
 - npm install @craco/craco --save
   craco.config.js
   #+begin_src js
   const postcssConfig = require('./postcss.config')
   module.exports = {
     style: {
       postcss: postcssConfig,
     }
   }
   #+end_src
*** postcss.config.js
*** stylelint.config.js
 - Home https://stylelint.io/
 - Plugins https://github.com/stylelint/awesome-stylelint
   | stylelint-config-css-modules  | enable css module specific syntax                                  |
   | stylelint-config-prettier     | disable rules conflicting with prettier                            |
   | stylelint-config-recess-order | sort css properties in specific order                              |
   | stylelint-config-standard     | turns on additional ruls to enforce common stylistic conventions   |
   | stylelint-scss                | a collection of SCSS specific rules, don't install if not using it |
 - $ npm install -D stylelint-config-css-modules stylelint-config-prettier stylelint-config-recess-order stylelint-config-standard stylelint-scss
 - stylelint.config.js
   #+begin_src javascript
   module.exports = {
     extends: [
       'stylelint-config-recommended',
       'stylelint-config-standard',
       'stylelint-config-recess-order',
       'stylelint-config-css-modules',
       'stylelint-config-prettier',
     ],
     plugins: ['stylelint-scss'],
     ignoreFiles: ['./coverage/**/*.css', './dist/**/*.css'],
     rules: {
       'at-rule-no-unknown': [
         true,
         {
           ignoreAtRules: [
             'tailwind',
             'apply',
             'variants',
             'responsive',
             'screen',
           ],
         },
       ],
       'declaration-block-no-duplicate-custom-properties': null,
       'named-grid-areas-no-invalid': null,
       'no-duplicate-selectors': null,
       'no-empty-source': null,
       'selector-pseudo-element-no-unknown': null,
       'declaration-block-trailing-semicolon': null,
       'no-descending-specificity': null,
       'string-no-newline': null,
       // Use camelCase for classes and ids only (workds better with css modules
       // 'selector-class-patter': /^[a-z][a-zA-Z]*(-(enter|leave)(-(active|to))?)?$/,
       // 'selector-id-pattern': /^[a-z][a-zA-Z]*$/,
       'selector-max-universal': 1,
       // SCSS
       // .... ommited for lazy
     },
   }
   #+end_src
 - Disable VSCODE css/less/scss/vetur validation
*** tailwind.config.js + Sass/SCSS
 - https://tailwindcss.com/docs/installation
 - npm install node-sass --save
 - For CRA v4 we install tailwind 7
   - $ npm install -D tailwindcss@npm:@tailwindcss/postcss7-compat postcss@^7 autoprefixer@^9
   - $ npm install -D @tailwindcss/forms
   - $ npx tailwindcss init -p
 - tailwind.config.js
   #+begin_src javascript
   const colors = require('tailwindcss/colors')
   module.exports = {
     purge: ['./index.html', './src/**/*.{js,ts,jsx,tsx}'],
     mode: 'jit',
     darkMode: 'class', // or 'media'
     theme: {
       extend: {},
       colors: {
         ...colors,
       },
     },
     variants: {
       extend: {},
     },
     plugins: [require('@tailwindcss/forms')],
   }
   #+end_src
 - src/index.css
   #+begin_src css
   @tailwind base;
   @tailwind components;
   @tailwind utilities;
   #+end_src
*** prettier.config.js
 - https://prettier.io/docs/en/index.html
 - prettier.config.js
   #+begin_src js
   module.exports = {
     endOfLine: "if",
     jsxBracketSameLine: false,
     jsxSingleQuote: true,
     printWidth: 80,
     proseWrap: "never",
     quoteProps: "as-needed",
     semi: false,
     singleQuote: true,
     tabWidth: 2,
     trailingComma: "es5",
     useTabs: false,
   #+end_src
 - Tell VSCODE to format on save, not on type or paste
*** tsconfig.json
 - https://www.typescriptlang.org/tsconfig
 - $ npm install craco-alias
   to support alias on import
   - import Component from '../../../components/common/MyComponent'
   - import Component from '@/components/common/Component'
 - craco.config.js
   #+begin_src javascript
   const postcssConfig = require('./postcss.config')
   const cracoAlias = require('craco-alias')
   module.exports = {
     style: {
       postcss: postcssConfig,
     },
     plugins: [
       {
         plugin: cracoAlias,
         options: {
           source: 'tsconfig',
           baseUrl: './', // plugin does NOT take it from tsconfig
           tsConfig: './tsconfig.paths.json',
         },
       },
     ],
   }
   #+end_src
 - tsconfig.paths.json
   #+begin_src json
   {
     "compilerOptions": {
       "paths": {
         "@/*": ["src/*"]
       }
     }
   }
   #+end_src
 - tsconfig.json (jsx: "react-jsx" OR jsx: "react-jsxdev")
   #+begin_src json
   {
     "extends": "./tsconfig.paths.json",
     "compilerOptions": {
       "allowJs": true,
       "allowSyntheticDefaultImports": true,
       "baseUrl": ".",
       "esModuleInterop": true,
       "forceConsistentCasingInFileNames": true,
       "isolatedModules": true,
       "jsx": "react-jsx",
       "lib": [ "DOM", "DOM.Iterable", "ESNext",
       "module": "esnext",
       "moduleResolution": "node",
       "noEmit": true,
       "noFallthroughCasesInSwitch": true,
       "resolveJsonModule": true,
       "skipLibCheck": true,
       "strict": true,
       "target": "es5",
       ],
     },
     "include": [
       "src"
     ]
   }
   #+end_src
*** Cypress & Testing Library
 - Part of the contrived config is due Jest has colliding methods (such as expect)
   Using local-cypress is an alternative
   https://docs.cypress.io/guides/tooling/typescript-support#Using-an-External-Typings-File
 - More linux deps https://docs.cypress.io/guides/getting-started/installing-cypress#System-requirements
 - $ npm install cypress @testing-library/cypress start-server-and-test --save-dev
   $ yarn add cypress @testing-library/cypress --dev
 - cypress open // browse mode
   cyperss run  // headless mode
 - package.json
   #+begin_src json
   "scripts": {
     "start": "craco start",
     "build": "craco build",
     "test:unit": "craco test",
     "test:e2e:open": "start-server-and-test start http-get://localhost:3000 cypress:open",
     "test:e2e:run": "start-server-and-test start http-get://localhost:3000 crypress:run",
     "cypress:run": "cypress run",
     "cypress:open": "cypress open",
   }
   #+end_src
 - It creates cypress/{fixtures,integration,plugins,support}
 - cypress/plugins/index.ts, update it to use .ts
   #+begin_src typescript
   /// <reference types="cypress" />
   /* eslint-disable import/no-anonymous-default-export */
   /**
    * @type {Cypress.PluginConfig}
    */
   export default (
     on: Cypress.PlginEvents,
     config: Cypress.PluginConfigOptions
   ) => {
     return Object.assign({}, config, {
       fixturesFolder: 'cypress/fixtures',
       integrationFolder: 'cypress/integration',
       screenshotsFolder: 'cypress/screenshots',
       videosFolder: 'cypress/videos',
       supportFile: 'cypress/support/index.ts',
     })
   }
   #+end_src
 - cypress/support/commands.ts
   import '@testing-library/cypress/add-commands'
 - cypress/support/index.ts
   import './commands'
 - cypress.json (a tsconfig.json file for Cypress)
   {
     "baseUrl": "http://localhost:3000",
     "pluginsFile": "cypress/plugins/index.ts",
   }
 - .gitignore
   /cypress/videos
   /cypress/screenshots
 - cypress/tsconfig.json
   #+begin_src json
   {
     "extends": "../tsconfig.json",
     "compilerOptions": {
       "noEmit": true,
       "types": ["cypress", "@testing-library/cypress"],
       "isolatedMOdules": false,
     },
     "include": [
       "../node_modules/cypress",
       "../node_modules/@testing-library/cypress",
       "./**/*.ts",
     ]
   }
   #+end_src
*** Jest & Testing Library
 - libraries
   | @testing-library/react       | deals with rendering react omponents and provides methods to grab elements |
   | @testing-library/jest-dom    | adds a lot of useful matches to Jest                                       |
   | @testing-library/react-hooks | make it a breeze to test custom hooks                                      |
 - CRA comes with Jest configured out of the box
 - Testing Library dependencies are still needed to install.
   $ npm install @testing-library/react @testing-library/jest-dom @testing-library/react-hooks --save-dev
 - src/setupTests.ts
   #+begin_src js
   import '@testing-library/jest-dom';
   #+end_src
*** (git) Husky & lint-staged
 - To run linters and formatters before commiting code
 - $ npm install husky lint-staged --save-dev
 - package.json
   #+begin_src json
   "husky": {
     "hooks": {
       "pre-commit": "lint-staged",
     }
   },
   "lint-staged": {
     "lint-staged": {
       "src/*.{ts,tsx}": "eslint",
       "src/*.{css,scss}": "stylelint",
       "src/**/*.{js,jsx,ts,tsx,json,css,scss,md}": "prettier -w -u",
     }
   },
   #+end_src
*** Vite
 - uses Rollup as a bundler instead of Webpack https://rollupjs.org/guide/en/
 - might not work with Jest
 - uses import.meta.env instead of process.env
*** VSCODE
 - snippets
   - react snippets https://github.com/dsznajder/vscode-react-javascript-snippets
   - js snippets https://github.com/xabikos/vscode-javascript
   - Emacs version https://github.com/dsznajder/vscode-react-javascript-snippets/
 - Refactor (extract functions from selected code) https://github.com/planbcoding/vscode-react-refactor
 - GIT
   https://github.com/gitkraken/vscode-gitlens
   https://github.com/DonJayamanne/gitHistoryVSCode
 - Save vscode configuration on the cloud https://github.com/shanalikhan/code-settings-sync
 - Autoimport https://github.com/soates/Auto-Import
 - Import cost in size https://github.com/wix/import-cost
 - jump keybinds (like firefox's vixen but for vscode) https://github.com/wmaurer/vscode-jumpy
 - autocomplete npm imports https://github.com/ChristianKohler/NpmIntellisense
 - linter for web accesibility https://github.com/mvdschee/web-accessibility
 - multilanguage web support https://github.com/lokalise/i18n-ally
 - shows parameters name in function calls https://github.com/imliam/vscode-inline-parameters
 - shows regex matches on a new window https://github.com/chrmarti/vscode-regex
** 3 Scalable And Maintable Project Architecture
 - module based pattern
   - src/views/{PAGE1,PAGE2}
     src/modules/PAGE1/{views,components,api,routes,store,...}
     - Encourages the view that the application is "just" a few global pages
     - Does not account for mobile devices, where there is less of a relation between screen/view and url
     - Quasar/Ionic, and PWA allows users to run web applications like they were regular mobile apps
     - Is better to NOT associate "api" with any view, and keep it independent
 - recommended
   | src/api                                        | methods responsible for performing api request and talking with a server |
   | src/assets/{fonts,images}                      |                                                                          |
   | src/components/common/{button,form,text}/*.tsx |                                                                          |
   | src/components/transitions                     |                                                                          |
   | src/hooks                                      | reusable hooks, if not reusable should be along their component          |
   | src/context                                    |                                                                          |
   | src/layout                                     | are components, example: a layout if logged in, another one if not       |
   | src/config                                     | runtime config files, example: firebase or oidc config                   |
   | src/contants                                   | global const CAPITALIZED or in an object.CAPITALIZED                     |
   | src/helpers                                    | small reusable functions                                                 |
   | src/intl                                       | internationalization (i18n)                                              |
   | src/services                                   | reusable complex business logic code                                     |
   | src/store                                      | global state management (Redux,Zustand,Jotain)                           |
   | src/styles                                     |                                                                          |
   | src/types                                      | global or shareable types                                                |
   | src/views                                      | <Route> per page components, might be on a subdir per page               |
** TODO 6 State Management In React Apps
*** Sharing State Between Sibling Components
 - Imperative(how) to Declarative(what)
 - TIP: Is a good practice to keep the state as close to where it is used
 - TIP: the more functionality we pack into components, the less reusable and maintainable they become. Create smaller components.
 - PATTERN: lift the state to the lowest common ancestor and share it between siblings.
 - Tailwind's @apply
   Extracting classes from them
   #+begin_src css
   .formInput {
     @apply border border-gray-50 shadow-p4;
   }
   #+end_src
   Then apply it elsewhere
   #+begin_src js
   import styles from './Some.module.css';
   //....
   <input className={styles.formInput}
   #+end_src
 - <form>'s <input type="file">
   #+begin_src js
   const onFileUpload = (e: React.ChangeEvent<HTMLInputElement>) => {
     setForm((state) => ({
       ...state,
       avatarFile: e.target.files?.[0], // HERE
     }))
   }
   #+end_src
 - <form>'s <input type="text"> on Change handler, infer name (from name=) and value from event
   #+begin_src js
   const onInputChange = (e: React.ChangeEvent<HTMLInputElement>) => {
     setForm((state) => ({
       ...state,
       [e.target.name]: e.target.value, // HERE
     }))
   }
   #+end_src
*** TODO Context State Provider
 - if you need to pass data through many components that don't even need it, it is time....
*** TODO Better state handling using useimmer and useReduce
 - useImmer() can be used when stateless changes are too verbose (like nested objects) for readability and maintenance.
   | useImmer()        | useState()   |
   | useImmerReducer() | useReducer() |
* 21 | React Cookbook                  | David Griffiths
  code https://github.com/dogriffiths/ReactCookbook-source/
** 3 Managing State
*** 3 Create and Validate Forms
 - Form validation, when not deal in the same way across the app, leads to poor UX
*** 4 useClock() - Measure Time with a clock
 - Write code (hook) that *depends* on the current time and hides away all the details
 - Uses =moment.js=, could have used day.js
 - Can take
   - a time format such as 'HH:mm:ss'
   - a time in milliseconds, useul for polling a network service
 - Code
    #+begin_src js
    import { useEffect, useState } from 'react'
    import moment from 'moment'
    const useClock = (formatOrInterval) => {
      const format = typeof formatOrinterval == ='string'
        ? formatOrInterval
        : 'YYYY-MM-DDTH:mm:ss.SSS'
      const interval = typeof formatOrInterval === 'number' ? formatOrInterval : 500
      const [response, setResponse] = useState(
        moment(new Date()).format(format)
      )
      useEffect(() => {
        const newTimer = setInterval({
          setResponse(moment(new Date()).format(format))
        } , interval)
        return () => clearInterval(newTimer)
      } , [format, interval])

      return response
    }
    #+end_src
*** 5 useOnline() - Monitoring online state
 - navigator.onLine
   window.addEventListener('online')
   window.addEventListener('offline')
 - useOnline() hook
 #+begin_src js
 import { useEffect, useState } from 'react'
 const useOnline = () => {
   const [online, setOnline] = useState(navigator.onLine)
   useEffect(()=>{
     if (window.addEventListener) {
       window.addEventLIstener('online', () => setOnline(true), false)
       window.addEventListener('offline', () => setOnline(false, false)
     } else {
       document.body.ononline = () => setOnline(true)
       document.body.onoffline = () => setOnline(false)
     }
   }, [])
   return online
 }
 #+end_src
* 22 | Real-World Next.js              | Michele Riva
code https://github.com/PacktPublishing/Real-World-Next.js
postman alternative https://insomnia.rest/
atomic design https://bradfrost.com/blog/post/atomic-web-design
manifest.json https://web.dev/add-manifest/
public apis https://github.com/public-apis/public-apis
CORS https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS
** 04 Organizing the Code Base and Fetching Data in Next.js
*** /components/ Atomic design Principle
|-----------+-------------------------------------------------------+------------------------------------------------------|
| atoms     |                                                       | wrappers of html elemnts, animations, color palletes |
| molecules | small group of atoms                                  | <input> + <label> atom wrappers                      |
| organisms | molecules and atoms combined                          | registration form, footer, carousel                  |
| templates | "skeletons", organisms, atoms, and molecules together |                                                      |
|-----------+-------------------------------------------------------+------------------------------------------------------|
- mkdir -p components/{atoms,molecules,organism,templates}
- mkdir -p components/atoms/Button; cd $_
  index.js
  buton.test.js
  button.styled.js (or style.module.css)
*** /utilities/
- By scope
  touch utilities/{time.js, localStorage.js, jwt.js, logs.js}
- For files that do NOT export components
  eg: check whether a hour of the day has passed
*** /public/assets/ static assets
- images, compiled JS, compiled CSS, icons, manifest.json, robots.txt
- public/assets/{js,css,icons,images}
- public/manifest.json
  <link rel="manifest" href="/manifest.json">
  #+begin_src json
    {
      "name": "My next.js app",
      "short_name": "next.js app",
      "description": "a test app made with next.js",
      "background_color": "#a600ff",
      "display": "standalone",
      "theme_color": "#a600ff",
      "icons": [
        {
        "src": "/assets/icons/icon-192.png",
        "type": "image/png",
        "sizes": "192x192"
      },
        {
        "src": "/assets/icons/icon-512.png",
        "type": "image/png",
        "sizes": "512x512"
        }
      ]
    }
  #+end_src
*** /lib/
- scripts that wrap thid-party libraries as lib files
- lib/graphql/{queries,mutations}/*.js
  lib/graphql/index.js
*** Data Fetching
- delegate database connection and queries to external systems (REST/GraphQL)
- Fetch from the server
  getServerSideProps()
  getStaticProps()
  pages/api/
- Alternatices to not expose an /api endpoint
  - render the component list exclusively on the server GSSP()
  - use an authentication method (JWT,API...)
  - use a backend framework (rails, spring, lavarel, nest.js, strapi)
- Libraries to fetch() from the server (next.js)
  - isomorphic-unfetch
  - undici
  - Axios
- When to make HTTP requests on the client
  1) make it to trusted sources only
  2) call https apis
  3) never connect to a remote db from a browser
- Client side requests need a "Loading..." pagej
- Code
  #+begin_src js
    import axios from 'axios';
    export async function getServerSideProps() {
        const usersReq = await axios.get('https://api.rwnjs.com/04/users');
        if (userReq.status === 404) {
            return {
                notFound: true // !!!
            }
        }
        return {
            props: {
                users: usersReq.data
            }
        };
    }
  #+end_src
*** TODO GraphQL
** 12 Managing Authentication and User Sessions
*** JWT (Json Web Token)
https://jwt.io/
https://datatracker.ietf.org/doc/html/rfc7519#section-4
- 3 fields
  | Header    | token type and algorithm used for signing 3)                                     |
  | Payload   | non-sensistive data (eg: "sub"(subject), "aud"(audiene), "exp"(expiration time)) |
  | Signature | does NOT contain the *secretpassword*                                            |
- each base64 encoded
- separated by "."
- by auth0
- code: generate
  #+begin_src js
    const jwt = require('jsonwebtoken');
    const myToken = jwt.sign(
        {
            name: 'Jane Doe',
            admin: false,
        },
        'secretpassword',
    );
    const tokenValue = jwt.verify(myTOken, 'secretpassword');
  #+end_src
*** Custom Autentication
- Non-Custom Providers: auth0, firebase, aws cognito, magic.link
- Cookies should have =httOnly= flag set to true to prevent JS to accessing it
- Instead of returning a plain JSON with the information we return it JWT encoded.
  TO ensure it cannot be forged.
**** Server Code: Add the JWT encoded data to a cookie
  #+begin_src js
    // yarn add cookie
    import { serialize } from 'cookie';
    // ... user is JWT.encode()
    if (user) {
        res.SetHeader('Set-Cookie', serialize('my_auth', user, { path: '/', httpOnly: true }))
        return res.json({ success: true });
    } else {
        return res.status(401).json({
            success: false,
            error: 'Wrong email of password',
        });
    }
  #+end_src
**** Client Code: /pages/protected-route.js
  #+begin_src js
    import { useRouter } from 'next/router';
    import { useAuth } from '../lib/hook/auth';

    export default function ProtectedRoute() {
        const router = useRouter();
        const { loading, error, loggedIn } = useAuth();
        if (!loading && loggedIn) {
            router.push('/login');
        }
        return (
            <div>
                {loading && <p>Loading...</p>}
                {error   && <p> An error ocurred. </p>}
                {loggedIn && (
                    <>
                        <h1>Protected Route</h1>
                        <p>You can't see me if not logged-in!</p>
                    </>
                )}
            </div>
        );
    }
  #+end_src
**** Client Code: /pages/login.js, <form> with useRoute() target
#+begin_src js
  import { useState } from 'react';
  import { useRouter } from 'next/router';
  import { useAuth } from '../lib/hook/auth';
  export default function Home() {
      const router = useRouter();
      const [loginError, setLoginError] = useState(null);
      const { loading, loggedIn } = useAuth();
      const handleSubmit = (event) => {
          event.preventDefault();
          const { email, password } = event.target.elements; // !!!!
          setLoginError(null);
          handleLogin(email.value, password.value)
            .then(() => router.push('/protected-route'))
            .catch((err) => setLoginError(err.message));
      };
      if (loading) return <p>Loading..<p/>;
      if (!loading && loggedIn) {
          router.push('/protected-route');
          return null;
      }
      return (
          <div>
              <h1>Login</h1>
              <form onSubmit={handleSubmit}>
                <label htmlFor="email">Email</label>
                <input type="email" id="email" />
                <label htmlFor="password">Password</label>
                <input type="password" id="password" />
                <buton type="submit">Login</button>
                {loginError && (<div>{loginError}</div>)}
              </form>
          </div>
      );
  }
#+end_src
**** Client Code: handleLogin()
#+begin_src js
  async function handleLogin(email, password) {
      const resp await fetch('/api/login', {
          method: 'POST',
          headers: {
              'Content-Type': 'application/json',
          },
          body: JSON.stringify({
              email,
              password,
          }),
      });
      const data = await resp.json();
      if (data.success) {
          return;
      }
      throw new Error('Wrong email or password');
  }
#+end_src
**** Server Code: /pages/api/get-session.js, validates JWT cookie from the client
#+begin_src js
  import { parse } from 'cookie';
  import { decode } from '../../lib/jwt';
  export default (req, res) => {
      if (req.method !== 'GET') {
          return res.status(404).end();
      }
      const { my_auth } = parse(req.header.cookie || '');
      if (!my_auth) {
          return resjson({ loggedIn: false });
      }
      return res.json({
          loggedIn: true,
          user: decode(my_auth),
      });
  }
#+end_src
**** Client Code: lib/hooks/auth.js, handles login and JWT validation
#+begin_src js
  import { useState, useEffect } from 'react';
  export function useAuth() {
      const [loggedIn, setLoggedIn] = useState(false);
      const [user, setUser]         = useState(null);
      const [loading, setLoading]   = useState(true);
      const [error, setError]       = useState(null);
      useEffect(() => {
          setLoading(true);
          fetch('/api/get-session')
            .then((res) => res.json())
            .then((data) => {
                if (data.loggedIn) {
                    setLoggedIn(true);
                    setUser(data.user);
                }
            })
            .catch((err) => setError(err))
            .finally(() => setLoading(false));
      }, []);
      return {
          user,
          loggedIn,
          loading,
          error,
      };
  }
#+end_src
