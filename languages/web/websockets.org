- RFC https://datatracker.ietf.org/doc/html/rfc6455

- Steps
  1) HTTP based handshake
  2) TCP based binary frames

* TCP frame

#+begin_src
0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-------+-+-------------+-------------------------------+
|F|R|R|R| opcode|M| Payload len |    Extended payload length    |
|I|S|S|S|  (4)  |A|     (7)     |             (16/64)           |
|N|V|V|V|       |S|             |   (if payload len==126/127)   |
| |1|2|3|       |K|             |                               |
+-+-+-+-+-------+-+-------------+ - - - - - - - - - - - - - - - +
|     Extended payload length continued, if payload len == 127  |
+ - - - - - - - - - - - - - - - +-------------------------------+
|                               |Masking-key, if MASK set to 1  |
+-------------------------------+-------------------------------+
| Masking-key (continued)       |          Payload Data         |
+-------------------------------- - - - - - - - - - - - - - - - +
:                     Payload Data continued ...                :
+ - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - +
|                     Payload Data continued ...                |
+---------------------------------------------------------------+
#+end_src

|----+----------+--------------------------------------|
|  1 | FIN      | 0 = message split in multiple frames |
|    |          | 1 = single frame messages            |
|  3 | RSV      | unused                               |
|  4 | OPCODE   | eg: text(1), binary, ping            |
|  1 | MASK     | 1 = masked, always on clients frames |
|    |          | 0 = unmasked                         |
|  7 | PAYLOAD  | for length <126 bytes                |
|    | LENGTH   |                                      |
| 32 | MASK-KEY | to be XOR with masked payload        |
|----+----------+--------------------------------------|
* HTTP request/response

client handshake request
#+begin_src sh
  GET / HTTP/1.1
  Host: localhost:2345
  Connection: Upgrade
  Upgrade: websocket
  Sec-WebSocket-Version: 13
  Sec-WebSocket-Key: cG8zEwcrcLnEftn2qohdKQ==
#+end_src

server response
#+begin_src sh
  HTTP/1.1 101 Switching Protocols
  Upgrade: websocket
  Connection: Upgrade
  Sec-WebSocket-Accept: d9WHst60HtB4IvjOVevrexl0oLA=
#+end_src

** How is ~Sec-WebSocket-Accept~ generated?

1) Take the value provided by the client, append a magic string to it.
   - the magic string is hardcoded in the RFC (!)
   - called GUID in the RFC
2) Generate the SHA1 hash, then base64 encode it.

#+begin_src ruby
  Digest::SHA1.base64digest(
    [sec_websocket_accept, "258EAFA5-E914-47DA-95CA-C5AB0DC85B11"].join
  )
#+end_src

* Snippets

- client code
  #+begin_src web
    <body>
      <script>
      var exampleSocket = WebSocket("ws://localhost:2345"); // !!!!
      exampleSocket.onopen = (event) => {
        exampleSocket.send("Can you hear me?");
      };
      exampleSocket.onmessage = (event) => {
        console.log(event.data);
      };
      </script>
    </body>
  #+end_src

* articles

- https://nbaksalyar.github.io/2015/11/09/rust-in-detail-2.html
- https://nbaksalyar.github.io/2015/07/10/writing-chat-in-rust.html
- https://alexanderell.is/posts/websockets-from-scratch/
- diy ruby https://www.honeybadger.io/blog/building-a-simple-websockets-server-from-scratch-in-ruby/
  - invented to solve problems inherit to HTTP connections
    - uses when pooling is needed
    - transmission overhead of one-time connections

