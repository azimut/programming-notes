* Elixir Sips
- Book author https://github.com/knewter
** Language Fundamentals
*** 003   Pattern matching

Function Call:  print_name.(:josh)

1) =match operator=
   - (=) is just the equal sign
   - Is more like an assertion than assigment
   - if unbound binds
   - ~if you do _not_ want to rebound, you need to signal it to the compiler~
     *different from Erlang*
     a = 3
     [^a,2] = [4,2]

2) =Function definitions= (ocaml like)
   #+begin_src elixir
     print_name_egostistically = fn
       :josh -> "your name is josh!"
       _     -> "i don't care!"
   #+end_src

3) =Case Statements=
  #+begin_src elixir
    case {1,2,3} do
      {4,5,6} -> "no match here"
      {1,2,3} -> "this matches"
      {_,2,3} -> "thiw would match, but since it's below another match it isn't hit"
    end
  #+end_src

*** 004   Functions (and string interpolation)

- (.) invoking a funtion immediatly
  #+begin_src elixir
    (fn -> "foo" end).()
  #+end_src

- string intepolation
  #+begin_src elixir
    polite_greeter = fn
      name -> "Hello, #{name}, nice to meet you!"
    end
  #+end_src

*** 005   Modules

- Modules are the primary unit of code organization in Elixir
  - private and public functions

- modules are and documentation are first class constructs, can be returned or binded like other values
  #+begin_src elixir
    output = defmodule Foo do
      @moduledoc """
        whate is this
      """
      @doc """
        A function documentation
      """
      def bar do
        "where"
      end
    end
    # {:module, Foo, BINARY_BYTECODE, {:bar, 0}};
  #+end_src

*** 006   Unit Testing

- test/schizo_test.exs
  #+begin_src elixir
    defmodule SchizoTest do
      use ExUnit.Case
      test "uppercase does't change the first word" do
        assert(Schizo.uppercase("foo") == "foo")
      end
      def test_one_is_one() do
        assert 1 == 1
      end
      test "one is one" do
        assert 1 == 1
        refute 2 == 1
      end
    end
#+end_src

- lib/schizo.ex
  #+begin_src elixir
    defmodule Schizo do
      def uppercase(string) do
        words = String.split(string)
        words_with_index = Stream.with_index(words)
        transformed_words = Enum.map(words_with_index, &uppercase_every_otherword/1)o
        Enum.join(transformed_words, " ")
      end

      def uppercase_every_other_word({word, index}) do
        cond do
          rem(index, 2) == 0 -> word
          rem(index, 2) == 1 -> String.upcase(word)
        end
      end
    end
  #+end_src

- functions with empty body return ~nil~

- to pass functions to other functions, you need to pass it with reference (&) and arity (/1)
  &uppercase_every_other_word/1

- .vimrc
  map <leader>t :!mix test<CR>

- test/assert/refute are macros

- an exunit test case, is just a module that uses exunit.case
  - runs all functions that start with "test", with arity 1

**** doctest
- In the test
  #+begin_src elixir
    defmodule SchizoTest do
      use ExUnit.Case
      doctest Schizo
  #+end_src
- In the code
  #+begin_src elixir
    @doc """
      Uppercases every other word in a sentence. Example:

      iex> Schizo.uppercase["you are silly")
      "you ARE silly"
    """
    def uppercase(string) do
      transform_every_other_word(string, &uppercaser/1)
    end
  #+end_src

*** 010   List Comprehensions
#+begin_src elixir
  lc x inlist [1,2,3,4], do: x*2              # [2,4,6,8]
  lc x inlist [1,2,3,4], do: [x, x*2]         # [[1,2], [2,4], [3,6], [4,8]]
  lc x inlist [1,2,3,4], rem(x,2) == 0, do: x # [2,4]
  lc x inlist [1,2,3], y inlist [4,5,6], do: x*y # [4,5,6,8,10,12,12,15,18]
  lc x inlist [1,2,3], y inlist [4,5,6], do: {x,y} # [{1,4}, {1,5}, {1,6}, {2,4}, {2,5}...
#+end_src
*** 011   Records
- deprecated
- _records are just modules_
  #+begin_src elixir
    {:module, NewRecord, _, nil} = defrecord NewRecord, first_name: ni l, last_name: "Dudington"
    # 2 ways to create arecord .new() or []
    dude = NewRecord.new first_name: "Dude"
    bro = NewRecord[first_name: "Bro"]
  #+end_src
- IS NOT RECOMMENDED to declare the state and the behaviour in 1(one) place.
  it is more accepted for example define a record ina module and functions that work with it
  #+begin_src elixir
    defrecord Person, first_name: nil, last_name: "Dudington" do
      def name(record) do
        "#{record.first_name} #{record.last_name}"
      end
    end
    guy = Person.new first_name: "Guy"
    guy.name
  #+end_src
- _instances of it are just tuples_
  #+begin_src elixir
    fake_person = {Person, "fake", "person"}
    fake_person.name
  #+end_src
- pattern match on functinos
  #+begin_src elixir
    defmodule PersonPrinter do
      def say_hello(Person[first_name: first, last_name: "Dudington"]) do # matches the exact string
        "hey' it's my brother ${first}!"
      end
      def say_hello(Person[first_name: first) do
        "hello, #{first}"
      end
    end
  #+end_src
*** 016   Pipe Operator
- In elixir, the pipe operator:
  - takes the output of an expression on the _left_ of it
  - and feeds it in as the 1st argument to the function on the _right_ of it
- You can technically make the pipe operator work on other places than the first argument.
  #+begin_src elixir
    String.strip(line)
    |> (&Regex.split(%r/ /, &1, trim: true)).()
    |> Enum.at(column-1)
  #+end_src
*** 014   OTP Part 1: Servers (GenServer)
- :gen_server.start_link(FridgeServer, [], [])
- :gen_server.call(PID, MSG)
- :gen_server calls are usually wrapped in a function on our module
- init/1 is implicitly called when :gen_server.start_link
  - must return a tuple
    {:ok, STATE_OF_THE_SERVER}
- handle_call/1
*** 015   OTP Part 2: State Machines (GenFSM)
- use GenFSM.Behaviour
  :gen_fsm.start_link/3
  :gen_fsm.send_event/2?
  :gen_fsm.sync_send_event/2
- FSM API
  #+begin_src elixir
    def init(_) do {:ok, :starting, []} end
    def starting(:s, _from, state_data) do {:reply, :got_s, :got_s, state_data} end
    def starting(_, _from, state_data) do  {:reply, :starting, :starting, state_data} end
  #+end_src
- A FSM is a mean of modeling some computation
  1) Limited number of states
  2) Has an initial state
  3) It can transition from a state to another, based on some event or condition
- Example: Find a substring.
  Type: Acceptor State Machine. Produce binary output.
*** 020/1 OTP Part 3: GenEvent
- use GenEvent.Behaviour
- :gen_event.start_link/0
  :gen_event.add_handler/3
  :gen_event.call/3 (pid, ModuleImplementing, msg)
- handle_event/2
  handle_call/2
*** 022   OTP Part 4: Supervisors
- GenServer
- Supervisor
- :supervisor.start_link
  worker/2
  supervise/2
#+begin_src elixir
  defmodule ListSupervisor do
    use Supervisor.Behaviour
    def start_link do
      :supervisor.start_link(__MODULE, [])
    end
    def init(list) do
      child_processes = [ worker(ListServer, list) ]
      supervise child_processes, strategy: :one_for_one
    end
#+end_src
*** 023   OTP Part 5: Supervisors and Persistent State
- testing supervisors crashes might be tricky due startup timings
- :supervisor.start_child/3
- Example: storing the state on a different process
- Supervision Tree
  List(Sup)ervisor > ListData (GenServer)
                   > List(Sub)Supervisor > ListServer
- start supervising an empty tree and add them later,
  so you can get the pid of the ListData and give it to ListServer
- GenServer API, we store the state on it
  terminate/2 (reason, state)
- lib/lis_supervisor.ex
  #+begin_src elixir
    defmodule ListSupervisor do
      def start_link do
        result = {:ok, sup} = :supervisor.start_link(__MODULE__, [])
        start_workers(sup)
        result
      end
      def start_workers(sup) do
        {:ok, list_data} = :supervisor.start_child(sup, worker(ListData, []))
        :supervisor.start_child(sup, worker(ListSubSupervisor, [list_data]))
      end
      def init(_) do
        supervise [], strategy: :one_for_one
      end
    end
  #+end_src
*** 017/9 Enum module
- Enum works on anything that implements the "enum" protocol
| Enum.        | / |                                                                            |
|--------------+---+----------------------------------------------------------------------------|
| .all?        | 2 | true/false                                                                 |
| .any?        | 2 | true/false                                                                 |
| .at          | 2 | nil or index at                                                            |
| .chunks      | 2 | returns "sized" elements each                                              |
|              | 3 | adds a "step" argument (cl :by)                                            |
|              | 4 | adds a "padding" to fill in chunks                                         |
| .chunks_by   | 2 | splits each time time fn returns a new value                               |
| .concat      | 1 | aka flatten                                                                |
| .count       | 1 | aka length                                                                 |
|              | 2 | aka filter + length                                                        |
| .drop        | 2 |                                                                            |
| .drop_while  | 2 | while fn returns true                                                      |
| .each        | 2 | aka foreach, returns :ok                                                   |
| .empty?      | 1 | returns boolean                                                            |
| .fetch(!)    | 2 | returns a tuple, { :ok, elem_at_index } or :error                          |
| .filter      | 2 | returns only *elements* where fn returns true                              |
| .filter_map  | 3 | aka filter + map                                                           |
| .find        | 2 | returns the 1st *element* where fn returns true or nil                     |
|              | 3 | with default if not found                                                  |
| .find_index  | 2 | returns the *index* instead of the *element*                               |
| .find_value  | 2 | returns the *value* of the fn that was true                                |
| .first       | 1 | returns first or nil                                                       |
| .flat_map    | 2 |                                                                            |
| .join        | 2 | joins the collection with a joiner                                         |
| .map         | 2 |                                                                            |
| .map_join    | 3 | map + join                                                                 |
| .map_reduce  | 3 | map + reduce, does the map while keeping an accumulator                    |
|              |   | returns a tuple with the result of each map/reduce                         |
| .max         | 1 | raises an empty error                                                      |
| .max_by      | 2 | Enum.max_by([1,2,3], fn(x) -> 10-x end)                                    |
| .min         | 1 |                                                                            |
| .min_by      | 2 |                                                                            |
| .member?     | 2 |                                                                            |
| .partition   | 2 | partitions into 2(two) collections, based on a boolean fn                  |
| .reduce      | 2 | the first element is used as the initial value of the accumulator          |
|              | 3 | or pass the initial value directly                                         |
| .reject      | 2 | not filter                                                                 |
| .reverse     | 1 |                                                                            |
| .shuffle     | 1 |                                                                            |
| .slice       | 3 | (coll, from, howmany) NOTE: expects an ordered collection                  |
| .sort        | 1 | NOTE: uses merge-sort                                                      |
|              | 2 | you can pass it an order function                                          |
| .split       | 2 | splits into 2(two) collections, providing a number of elements for the 1st |
| .split_while | 2 | while fn returns true                                                      |
| .take        | 2 | NOTE: expects an ordered collection                                        |
| .take_every  | 2 | takes every nth item, starting with the first                              |
| .take_while  | 2 | NOTE: expects an ordered collection                                        |
| .to_list     | 2 | collection to list                                                         |
| .uniq        | 1 | remove duplicates                                                          |
| .with_index  | 1 | wraps each element on a tuple with their index                             |
| .zip         | 2 | if second list is shorter, values are filles with *nil*                    |
*** 026/7 Dict module
- Dict/HashDict
| .delete   | 2 | do nothing if missing                                                   |
| .drop     | 2 | can delete multiple                                                     |
| .empty    | 1 | receives a Dict, returns an empty Dict of the same type                 |
| .equal?   | 2 | compares 2 Dict, if diff types they are converted to lists before check |
| .fetch    | 2 | returns {:ok,value} or :error                                           |
| .fetch!   | 2 | returns value or throws an exception                                    |
| .get      | 2 | if not in dict, returns nil                                             |
|           | 3 | if not in dict, returns default argument                                |
| .has_key? | 2 |                                                                         |
| .keys     | 1 |                                                                         |
| .merge    | 2 | the key on the 2nd dict wins                                            |
|           | 3 | takes a fn to resolve the conflict (k,v1,v2)                            |
| .pop      | 3 | takes a default, returns {value,new_dict}                               |
| .put      | 2 | replaces value                                                          |
| .put_new  | 2 | does NOT replace                                                        |
| .size     | 1 |                                                                         |
| .split    | 2 | returns {dict,dict}, takes a list of keys                               |
| .take     | 2 | returns a dict of the provided keys                                     |
| .to_list  | 1 |                                                                         |
| .update   | 4 | updates a value with fn, takes an initial value                         |
| .update!  | 3 | exception if key not present, no initial value                          |
| .values   | 1 |                                                                         |
*** 041/2 File module
- there are variations with (!), which raises and exception
| function   | / | description                                                           |
|------------+---+-----------------------------------------------------------------------|
| cd         | 1 |                                                                       |
| chgrp      | 2 |                                                                       |
| chmod      | 2 |                                                                       |
| chown      | 2 |                                                                       |
| close      | 1 |                                                                       |
| copy       | 2 | /3 optional to specify the ammount of bytes to copy                   |
| cp         | 2 | /3 callback to determine if it should be overwritten, preserving mode |
| cp_r       | 2 |                                                                       |
| cwd        | 0 |                                                                       |
| dir?       | 1 |                                                                       |
| exists?    | 1 |                                                                       |
| ls         | 1 |                                                                       |
| mkdir      | 1 |                                                                       |
| mkdir_p    | 1 |                                                                       |
| open       | 2 | args: path and mode ([:utf8])                                         |
| open       | 3 | /3 is a function invoked with the file (ME: callback)                 |
| read       | 1 |                                                                       |
| regular?   | 1 |                                                                       |
| rm         | 1 |                                                                       |
| rmdir      | 1 |                                                                       |
| rm_rf      | 1 |                                                                       |
| stat       | 1 |                                                                       |
| stream!    | 1 | (slurp) returns a file contents into a stream for each line           |
| stream_to! | 1 | (spit)  will write a stream into a file                               |
| touch      | 1 | creates if it doesn't exist, updates modification and access time     |
| write      | 2 |                                                                       |
| write_stat | 2 | File.write_stat("/tmp/foo", stat.gid(1001))                           |
|------------+---+-----------------------------------------------------------------------|
*** 054   Maps
- Since Erlang R17 and Elixir 0.13
  - A new Erlang datatype
  - On top of the *enum* and *inspect* protocols
  - replace records
- Essentially the same as hashes in Ruby or map in Scala
*** 055   Structs (a tagged map)
- To define a *struct* you just need to define the following functions on a given module. This should return a map.
  - __struct
  - __function
- Primary means to provide polymorphic dispatch.
#+begin_src elixir
  defmodule SomeStruct do
    def __struct__ do
      %{foo: "bar"}
    end
  end

  %SomeStruct{}                         # => %SomeStruct{foo: "baz"}
  %{__struct__: SomeStruct, foo: "baz"} # => %SomeStruct{foo: "baz"}

  defmodule Person do
    defstruct first_name: nil, last_name: "Dudington"
    def name(person) do
      "#{person.first_name} #{person.last_name}"
    end
  end
  josh = %Person{first_name: "Josh"} # => %Person{first_name: "Josh", last_name: "Dudington"}
  Person.name(josh)                  # => "Josh Dudington"
#+end_src
*** 076   Streams
#+begin_src elixir
  Stream.repeatedly(fn () -> 1 end)     |> Enum.take(10)
  Stream.repeatedly(&:random.uniform/0) |> Enum.take(10)
  Stream.cycle([1,2,3])                 |> Enum.take(10)
  #
  # A file that is too big to fit into memory
  #
  file_stream = Stream.resource(
    fn -> File.open!("/usr/share/dict/words") end,
    fn (file) ->
      case IO.read(file, :line) do
       data when is_binary(data) -> {data, file}
        _ -> nil
      end
    end,
    fn (file) -> File.close(file) end
  )
  file_stream |> Stream.take_every(200) |> Enum.take(10)
  # BUG: `Enum.to_list` is necessary because `Stream.cycle` does not repeat if you take it out
  file_stream |> Stream.drop(2000) |> Stream.take(4) |> Enum.to_list |> Stream.cycle |> Enum.take(20)
  # => ["foo\n", "bar\n", "f\n"]
  file_stream |> Stream.drop(2000) |> Stream.take(4) |> Enum.to_list |> Stream.cycle |> stream.with_index |> Enum.take(20)
  # => [{"foo\n", 0}, {"bar\n", 1}, {"f\n", 2}]
  file_stream ¦> Stream.filter(fn(x) -> !Regex.match?(~r/[abcde]/i,x) end) |> Enum.take(20)
  # => ["f\n"]
  file_stream |> Stream.filter_map(fn(x) -> !Regex.match?(~r/[abcde]/i,x) end, fn(x) -> String.uppercase(x) end) |> Enum.take(20)
  # => ["F\n"]
#+end_src
*** 077   Exceptions and Errors
- exceptions are RARELY used on elixir code
  is idiomatic to return a tuple
  {:error, :enoent}
- define a function with (!) at the end for those that raise exceptions
  in your code you just wrap the normal function
#+begin_src elixir
  # raise/2 raise/1
  raise ArithmeticError, message: "nope.jpg"
  raise "some" # this raises RuntimeError

  defexception ElixirSipError, message: "No such ElixirSip"
  try do
    raise ElixirSipError
  rescue
    e in ElixirSipError ->
      IO.puts "Caugh an error: #{inspect e}"
  end
#+end_src
** Libraries
*** 024-25 Ecto
- Postgres persistence
- *repos* are what Ecto uses to persiste your entities on a database
- *entity* describes the data to be stored on the databse, defines a record
- *models* where behaviours live, defines how to connect the an entity to a database table
  1) Ecto.model.query
  2) Ecto.model.validations
  3) Ecto.model.callbacks
- lib/ecto_test/repo.exs
  #+begin_src elixir
    defmodule EctoTest.Repo do
      use Ecto.repo, adapter: EctoAdapters.Postgres
      def url do "ecto://postgres:postgres@localhost/ecto_test" end
      def priv do # Where private files are kept, where to place migrations
        app_dir(:ecto_test, "priv/repo")
      end
    end
  #+end_src
- lib/ecto_test/dweet.ext
  #+begin_src elixir
    defmodule EctoTest.Dweet do
      use Ecto.Model
      queryable "dweets" do
        field :content, :string
        field :author,  :string
      end
    end
  #+end_src
- psql -- create the database
  mix compile
  mix ecto.gen.migrate Ectotest.Repo create_dweets
  vim priv/repo/migrations/____create_dweets.exs
  #+begin_src elixir
    defmodule Dwitter.Repo.Migrations.CreateDweets do
      def up do
        "CREATE TABLE dweets(id serial primary key, content varchar(150), author varchar(50))"
      end
      def down do
        "DROP TABLE dweets"
      end
    end
  #+end_src
  mix ecto.migrate EctoTest.repo
- iex -S mix
  d = EctoTest.Dweet.new(content: "foo")
  d = d.author("djames")
  EctoTest.Repo.create(d)
- query
  #+begin_src elixir
    use Ecto.Query
    query = from d in Dwitter.Dweet, order_by: [Desc: d.id], limit: 10, select: d
    recent_dweets= Dwitter.Repo.all(query)
  #+end_src
*** 029 HTTP Clients (httpc/ibrowse/hackney)
- Regex.match?/2
**** httpc
- you need to start ":inets" application
- :httpc.request/1 takes a list as argument NOT a string
#+begin_src elixir
  { :ok, {{_version, 200, _reason}, _headers, body}} = :httpc.request('http://example.com')
#+end_src
**** ibrowse
- needs :ibrowse application to start
- :ibrowse.send_req/3
- '200' is a list
#+begin_src elixir
  { :ok, '200', _headers, body } = :ibrowse.send_req('http://example.com', [], :get)
#+end_src
**** hackney
#+begin_src elixir
  {:ok, 200, _headers, client} = :hackenet.get("http://example.com")
  {:ok, body, client} = :hackney. body(client)
#+end_src
*** 028 Parsing XML (xmerl)
- erlang buildin module https://www.erlang.org/doc/man/xmerl.html
- :xmerl_scan.string/1
  :xmerl_path.string
  :xmerl_xpath.string
**** Example: title text, :xmerl_path.string
- We need to define the Erlang record on elixir, since they differ (defrecord)
  #+begin_src elixir
    defrecord :xmlElement, Record.extract(:xmlElement, from_lib: "xmerl/include/xmerl.hrl")
    defrecord :xmlText, Record.extract(:xmlText, from_lib: "xmerl/include/xmerl.hrl")
    defmodule XmlParsingTest do
      { xml, _rest } = :xmerl_scan.string(bitstring_to_list(sample_xml))
      [ title_element ] = :xmerl_xpath.string('/html/head/title', xml)
      [ title_text ] = title_element.content
      title = title_text.value
  #+end_src
**** Example: title text, :xmerl_xpath.string
#+begin_src elixir
  { xml, _rest } = :xmerl_scan.string(bitstring_to_list(sample_xml))
  [ p_text ]= :xmerl_xpath.string('/html/body/p/text()', xml)
#+end_src
**** Example: <li> array
#+begin_src elixir
  { xml, _rest } = :xmerl_scan.string(bitstring_to_list(sample_xml))
  li_texts = :xmerl_xpath.string('/html/body/ul/li/text()', xml)
  texts = li_texts |> Enum.map(fn(x) -> x.value end)
#+end_src
** Projects
** 007 Dynamo, Part 1
- Web framework that runs on elixir
- ABANDONDED in 2014 https://github.com/dynamo/dynamo
- In favor of others like Plug https://github.com/elixir-plug/plug
- mix deps.get
  mix server
- .eex templates
  <%= @title %>
- use Dynamo.Router
  | prepare       | macro, runs for every action inside the router(file) |
  | get           | macro                                                |
  | post          | macro                                                |
  | render/2      | function, takes a connection and template filename   |
  | conn.assign/2 |                                                      |
  | conn.fetch/2  |                                                      |
  | con.params    | dictionary                                           |
** 008 Dynamo, Part 2 (Ecto/Amnesia)
- Code.require_file/2
  Amnesia.transaction macro
- test/test_helper.exs
  #+begin_src elixir
    defmodule Amnesia.Test do
      def start do
        :error_logger.tty(false)
        Amnesia.Schema.create
        Amnesia.start
        :ok
      end
      def stop do
        Amnesia.stop
        AMnesia.Schema.destroy
        :error_logger.tty(true)
        :ok
      end
    end
    ExUnit.start
  #+end_src
- test/amnesia_test.exs
  #+begin_src elixir
    Code.require_file "../test_helper.exs", __FILE__
    use Amnesia
    require Exquisit
    defdatabase Dwitter.Database do
      deftable Dweet, [:id, :content], type: :ordered_set do # first field becomes the PK
        @type t :: Dweet[:id integer, content: String.t]
        def in_reply_to(self) do Dweet.read(self.in_reply_to_id) end
        def replies(self) do Dweet.where(in_reply_to_id == self.id).values end
      end
    end
    defmodule AmnesiaTest do
      use ExUnit.Case
      use Dwitter.Database
      test "saving dweets" do
        Amnesia.transaction! do
          dweet = Dweet[id: 1, content: 'something things happened']
          dweet.write
        end
        assert 'some things happened.' == Dweet.read!(1).content
      end
      setup_all do AMnesiaTEst.start end
      teardown_all do Amnesia.Test.stop end
      setup do
        Dwitter.Database.create!
        ok:
      end
      teardown do
        Dwitter.Database.destroy
        :ok
      end
    end
  #+end_src
** 009 Dynamo, Part 3 (Amnesia)
- lib/dwitter/database.ex (has the defdatabase code)
- lib/dwitter.ex
  #+begin_src elixir
    defmodule Dwitter do
      def start(_type, _args) do
        Amnesia.Schema.create
        Amnesia.start
        Dwitter.Database.destroy
        Dwitter.Database.create
        Dwitter.Dynamo.start_link([max_restarts: 5, max_seconds: 5])
      end
    end
  #+end_src
** 012 Processes
- assert_receive (macro)
- erlang is a concurrency oriented programming language
  - a process is his unit of concurrency
- iex -S mix
** 013 Processes (CQRS/Event Sourcing)
- Command Query Responsability Segregation
  1) Where queries do not modify the state of the system
  2) And commands do not return any meaninful data
- CQRS happen naturally when you have a BEAM process with a *receive* for different commands
- For fun is modeled here as a list of events that ocurred in the account.
  Either, deposit or withdraw.
  aka *event sourcing*
** 030 ExActor
- simplifies the creation of GenServer's (provides macros)
- Example ListActor
  #+begin_src elixir
    defmodule ListActor do
        use ExActor, initial_state: []
        defcall get, state: state, do: state
        defcast put(x), state: state, do: new_state(state ++ [x])
        defcast take(x), state: state, do: new_state(List.delete(state, x)
    end
#+end_src
- Example CountActor
  - This time exports a named atom to register the  server under ":counter"
  - call/cast won't need to have a PID pass to them, they use the atom to call
  #+begin_src elixir
    defmodule CountActor do
      use ExActor, export: :counter
      #defcall get, state: state, do: state
      defcall get, state: state, when: state == 2, do: :two
      defcast inc, state: state, do: new_state(state + 1)
      defcast inc, state: state, do: new_state(state - 1)
    end
  #+end_src
** 031 TCP Servers (:gen_tcp)
| :gen_tcp.listen/2 | (port, options) |
| :gen_tcp.accept/1 | (socket)        |
| :gen_tcp.recv/2   | (socket,length) |
| :gen_tcp.send/2   | (socket,string) |
- we test it using telnet
- This example blocks for each processed connection
- lib/tcp_server/server.ex
  #+begin_src elixir
    defmodule TcpServer.Server do
      def listen(port) do
        IO.puts "listening on port #{port}"
        tcp_options = [:binary, {:packet, 0}, {:active, false}]
        {:ok, listen_socket} = :gen_tco.listen(port, tcp_options)
        do_accept(listening_socket)
      end
      def do_accept(listening_socket) do
        {:ok, socket} = :gen_tcp.accept(listening_socket)
        do_listen(socket)
      end
      def do_listen(socket) do
        case :gen_tcp.recv(socket, 0) do
          {:ok, data} ->
            IO.puts "Got some data! #{data}"
            :gen_tcp.send(socket, "roger, wilco\n")
            do_listen(socket)
          {:error, :closed} ->
            IO.puts "The client closed the connection..."
      end
    end
  #+end_src
** 032 Command Line Scripts
- Example: fetch local weather data from the internet
- Uses hackney to download the xml
- System.argv
- scripsts/get_temperature.exs
  #+begin_src elixir
    [woeid|_rest] = System.argv
    temp = CurrentWeather.YahooFetcher.fetch(woeid)
    IO.puts "The current weather for woed #{woeid} is #{temp} degrees fahrenheit."
  #+end_src
- Invoking it: mix run scripts/get_temperature.exs 2378489
** 033 IEx.pry
- Creates a breakpoint that has access the lexical scope of the function
  pry(1)> respawn -- to quit
- A tool to inspect or debug a running process (elixir build-in)
#+begin_src elixir
  require IEx
  defmodule IexPryTest do
    def start(_type, _args) do
      IexPryTest.Supervisor.start_link
    end
    def add(a,b) do
      c = a + b
      IEx.pry
      c
    end
#+end_src
** 034 Elixiak
- an ActiveRecord-like wrapper for Riak in Elixir
- Example: to store log data and filter by application
- .create().save!
  .find()
  .bucket
- test/elixiak_playground_test.exs
  #+begin_src elixir
    defmodule ElixiakPlaygroundTest do
      use ExUnit.Case
      setup do
        Riak.start
        Riak.configure(host: '127.0.0.1', port. 8087)
        delete_all_logs
        :ok
      end
      test "we can store logs" do
        Log.create(application: "web", content: "GET /foo/bar by 10.0.0.1").save!
        Log.create(application: "backened", content: "image foo1.jpg resized.").save!
        web_results = Log.find(application: "web")
        assert Enum.count(web_results) == 1
        assert List.last(web_results).content == "GET /foo/bar by 10.0.0.1")
      end
      def delete_all_logs do
        {:ok, keys} = Riak.Bucket.keys Log.bucket
        keys |> Enum.each(fn(key) -> Riak.delete(Log.bucket, key) end)
      end
    end
  #+end_src
- lib/elixiak_playground/log.ex
  #+begin_src elixir
    defmodule Log do
      use Elixiak.Model
      document "log" do
        field :application, :string, indexed: true
        field :time,        :datetime, indexed: true
        filed :content,     :binary
      end
    end
  #+end_src
** 035 Weber
- an MVC web framework for elixir
- make
  make test
  mix weber.new ../cityguide --grunt
  cd ../cityguide
  mix deps.get
  mix compile --all --force # compile each time you change the code
  ./start.sh
- :Cityguide.Main is a controller
  the function action() get run on request
- lib/controllers/main.ex
  lib/views/Main.html
  lib/views/Guide.html
  lib/controllers/guide.ex
- lib/route.ex
  #+begin_src elixir
    defmodule Route do
      import WEber.Route
      require Weber.Route
      route on("GET", "/", :Cityguide.Main, :action)
         |> on("GET", "/cities/:cityname", :Cityguide.Guide, :action)
    end
  #+end_src
- is important to be careful to avoid DOS attacks by generating atoms in your application
  eg: binary_to_existing_atom/1
- defining functions with guards
  #+begin_src elixir
    defrecord City, name: "", woeid: ""
    # defmodule . . .
    defp city(cityname) when is_binary(cityname) do
      city(binary_to_existing_atom(cityname))
    end
    defp city(cityname) when is_atom(cityname) do
      cities[cityname]
    end
    defp citites do
      [
        birmingham: City[name: "Birminhan, AL", woeid: "2364559"],
        atlanta:    City[name: "Atlanta, GA", woeid: "2357024"]
      ]
    end
  #+end_src
** 036 Weber Part 2
- building a cache for our API calls
  - only request 1 every 5 minutes for each city
- elixir vs node.js and ruby
- lib/simple_cache.ex
  #+begin_src elixir
    defrecord SimpleCacheState,
      cache_interval: 60,
      cache: HashDict.new,
      cache_timings: HAshDict.new

    defmodule SimpleCache do
      use ExActor, export: :simple_cache, initial_state: SimpleCacheState.new
      defcast configure(new_config), state: state do
        state = state.cache_interval(new_config[:cache_interval])
        new_state(state)
      end
      defcast clear, state: state do
        state = state.cache(HashDict.new)
        state = state.cache_timing(HashDict.new)
        new_state(state)
      end
    end
  #+end_src


* Elixir and Phoenix or Beginners

- LISP2 http://www.nhplace.com/kent/Papers/Technical-Issues.html

** 04,05 Thinking about concurrency, Concurrency in sequential languages

- Most programming languages, were designed for the ground up for ~sequential~ tasks
  - aka sequential programming languages
  - Were NOT designed with concurrency in mind
  - java, c#, python, ruby, js
  - concurrency is still possible through threads and locks, or lock-free queues

- While databases are a solution,
  - they are slow (network/disk access),
  - which causes idle threads

- Quotes
  - "Software follows Hardware"
  - "Shared memory is the root of all evil" Joe Armstrong

** 15 Strings

#+begin_src elixir
  # Byte size = 5
  "James" == <<74,97,109,101,115>> # true
#+end_src

- =String= in elixir are a collection of *bytes* encoded in UTF-8
- =Binary= if the series of bits is evenly divisible by 8
- =BitString= is a series of bits

- To pass a string to erlang, you need to use a *CharList*
  Using single quotes (')

** 22 Immutable data

- Google docs are like ~immutable~ data, because you change a document
  you are making a *copy* of a document and changing that one.

- Data in =Prolog= is immutable.

- Immutability helps with some, but not ALL problems of concurrency.

** 23 Variables

- naming
  - can end with "?" or "!"
  - all lowercase letters
  - can use "_" to separate words (snakecase)

- you can rebind variables

- Elixir is dynamically, strongly typed language

** 24 Pattern Matching

- The (=) represents a match operator
- The left side of the (=) gets binded

** 35 Anonymous Functions

- functions != methods
  + methods
    - act on their own data
    - may not return a value
  + functions
    - act on input data
    - return a value based on the input

- =Data and Code= (that modifies the data)
  - In OO, are combined together in classes/objects
  - In FP, we don't like to mix them

** 36 named functions

#+begin_src elixir
  defmodule Voter do       # CamelCase
    def add(arg1, arg2) do # snake_case
      arg1 + arg2 # returns the last value
    end
    def eligibility(age) when is_binary(age) do
      eligibility(Integer.parse(age))
    end
    def eligibility({age,_}) do
      eligibility(age)
    end
    def eligibility(age) when is_integer(age) and age < 18 do
      "You cannot vote"
    end
    def eligibility(age) when is_integer(age) and age < 25 do
      "You can vote"
    end
    def eligibility(:error) do
      "invalid number!"
    end
    def eligibility(_age) do
      "You can be run as a candidate"
    end
  end
#+end_src

** 48 pure vs impure functions

- in order to be pure
  1) take arguments
  2) return a value based on the arguments
  3) do NOT do anything else

- there could be functions that are neither pure or impure

- pure functions
  1) easier to understand
  2) better for function composition
  3) reusable
  4) easy to test
  5) cacheable
  6) parallelism

- Side effects: ??
- Side causes: eg, get the current time from Time.utc_now

** 56 Composition with ¦>

#+begin_src elixir
  district_canidate_votes = [
    %{district:1, candidate:1, votes:1050},
    %{district:1, candidate:2, votes:1200},
    %{district:1, candidate:3, votes:1050},
    %{district:2, candidate:2, votes:900}
  ]

  candidate_totals =
    district_candidate_votes
    |> Enum.filter(&(&1.district in [1,2]))
    |> Enum.map(&Map.take(&1, [:candidate, :votes]))
    |> Enum.group_by(&(&1.candidate), &(&1.votes))
    |> Enum.map(fn {k,v} -> {k,Enum.sum(v)} end)
    |> Enum.into(%{})
#+end_src

** 57 Streams

- Enumerables
  - are ~eager~, meaning they immediately generate data
  - And becomes a problem when processing large ammounts of data
  - resulting in large memory usage

- Functions on =Stream= module are ~lazy~
  - Composed of a stream struct
    #+begin_src
    #Stream<[enum: 1..10,
             funs: [#Function<49.123124/1 in Stream.map/2>]]>
    #+end_src
  - They take 1 element of the enumerable at the time,
    and sends it to the functions on our pipeline.
  - Example:
    #+begin_src elixir
      def lazy(nums) do
        nums
        |> Stream.map(&(&1 * 2))
        |> Stream.filter(&is_even/1)
        |> Enum.sum()
      end
    #+end_src

** 58 List Comprehension

- They shine when dealing with mapping&filtering&reduce
  over more than 1 list.
  #+begin_src elixir
    for x <- [1,2,3], do: x * 2
    for x <- [1,2,3], y <- [10,20,30], do: x * y
    for x <- [1,2,3], y <- [10,20,30], is_even(x), is_even(y), do: x * y
  #+end_src

- More complex example
  #+begin_src elixir
    state = "CA"
    ballot_type = [20,30]
    polling_props =
      for prop   = %{state: ^state} <- propositions,
        location = %{state: ^state} <- locations,
        location.ballot_type in ballot_type do
          %{
            prop_id:          prop.id,
            state:            state,
            prop_description: prop.description,
            location_id:      location.id,
            address:          location.address
          }
      end
  #+end_src

** 59 Protocols

- Protocols
  - allows *extensible* ~polymorphism~
  - implementations might require you to implement all functions or just a few

#+begin_src elixir
  # Protocol
  defprotocol Calculatetable do
    def sum(data)
  end

  # Implementation
  defimpl Calculatetable, for: List do
    def sum(list), do: do_sum(list, 0)
    defp do_sum([], total), do: total
    defp do_sum([head | tail], total), do: do_sum(tail, head + total)
  end

  # Usage
  defmodule Calculate do
    def sum(data), do: Calculatetable.sum()
  end
#+end_src

** 60 Macros

- Build-in macros: def, defmodule, defstruct, if, unless, fn

- macros are NOT loaded after IEX loading, either
  - =import=  it, which will import all the macros and functions
  - =require= it, which will import all the macros

#+begin_src elixir
  defmodule Util do
    defmacro reverse({:+, context, [a,b]}) do
      # {:-, context, [a,b]}
      quote do
        unquote(a) - unquote(b)
      end
    end
  end
#+end_src

*** Example: AST of 1+1 and 1+1*2

- will be called with the AST of "1 + 1" and NOT "2"

- AST of "1+1" being: {function, context, arguments}
  #+begin_src elixir
    {:+, [line: 3], [1,1]}
  #+end_src

- AST of "1+1*2"
  #+begin_src elixir
    {:+, context,
     [1,
      {:*, context, [1,2]}
     ]
    }
  #+end_src

*** Example: outout of =quote=, is an AST

#+begin_src elixir
  iex > quote do: 1 + 1
  {:+, [context: Elixir, import: Kernel], [1,1]}
  iex > quote do: 1 + 1 * 2 - 1
  {:-, [context: Elixir, import: Kernel],
       [{:+,
         [context: Elixir, import: Kernel],
         [1,{:*,
             [context: Elixir, import: Kernel],
             [1,2]}]}, 1]}
#+end_src

*** Example: "vote" macro on new _Proposition_ module

#+begin_src elixir
  defmodule Proposition do

    defstruct [:description, yes: 0, no: 0]

    def new(description) do
      %Proposition{description: description}
    end

    defmacro vote({:+, _, [prop,qty]}) do
      cast(prop, :yes, qty)
    end
    defmacro vote({:-, _, [prop,qty]}) do
      cast(prop, :no, qty)
    end

    defp cast(prop, vote, qty) do
      quote do
        Map.update!(unquote(prop), unquote(vote), &(&1 + unquote(qty)))
      end
    end

  end
#+end_src

*** Example: Macro.expand

#+begin_src elixir
  (quote do: vote gas_tax + 2)
  |> Macro.expand(__ENV__)
  |> Macro.to_string()
  # "Map.update!(gas_tax, :yes, &(&1 + 2)"
#+end_src

*** Example: extending a module with code from another module
#+begin_src elixir
  defmodule Html do
    defmacro __using__(_opts) do
      quote do
        import Html # code here is "injected" into another module
      end
    end
    def div(content), do: tag("div", content)
    def p(content), do: tag("p", content)
    def span(content), do: tag("span", content)
    defp tag(name, content) do
      "<#{name}>#{content}</#{name}>"
    end
  end

  defmodule Page do
    use Html
    def view(content) do
      content |> span() |> p() |> div()
    end
  end
  # >>> Page.view("Some content")
  # <div><p><span>Some content</span></p></div>
#+end_src

** 76 Testing

- Steps to test

  1) arrange: setting up, creating values to use for the test
  2)     act: invoking the function to test, using 1) values
  3)  assert: verifying the value returned is what you were expecting

** 79 What's a Process

|----------------+-----------|
|                | memory kb |
|----------------+-----------|
| elixir process |         2 |
| threads        | 1000-3000 |
|----------------+-----------|
