- elixir sips https://rutracker.org/forum/viewtopic.php?t=5262308
- https://david-delassus.medium.com/elixir-and-kubernetes-a-love-story-721cc6a5c7d5
- https://github.com/bitwalker/libcluster
  https://github.com/derekkraan/horde
- https://elixir-lang.org/getting-started/mix-otp/config-and-releases.html#releases
- https://github.com/lucasvegi/Elixir-Code-Smells
- https://github.com/Zensavona/domainatrex
  A library for parsing TLDs from urls in Elixir
https://elixirschool.com/en/
https://github.com/elixirkoans/elixir-koans
https://github.com/exercism/elixir
- Book https://joyofelixir.com/toc.html
* Data Types
- Records vs Structs https://groups.google.com/g/elixir-lang-talk/c/6kn7J2XnFg8/m/I5poTNCEHwAJ
|-------------------+---------+------------------------------+-----------------------------------------------|
| []                | [x,_]   | Lists                        |                                               |
| {}                | {x,_}   | Tuples                       |                                               |
| :atom             |         | Atoms                        | start with ":"                                |
| true/false/nil    |         |                              | syntactic sugar for atoms of the same name    |
| ~D[] ~T[] ~N[]    |         | date, timestamp, native date |                                               |
| [:a 1, :b 2]      |         | Keyword List                 |                                               |
| %r/[0-9]/         |         | regex                        |                                               |
|-------------------+---------+------------------------------+-----------------------------------------------|
| %Abc{a: a, b: b}  |         | structs                      | declared with *defstruct*                     |
|-------------------+---------+------------------------------+-----------------------------------------------|
| A.new a: a        | A[a: a] | records                      | declared with *defrecord*, compile-time based |
|-------------------+---------+------------------------------+-----------------------------------------------|
| %{name: "bob"}    |         | maps                         | run-time based                                |
| %{:name => "bob"} |         |                              |                                               |
|-------------------+---------+------------------------------+-----------------------------------------------|
* Channels
- Tetris Phoenix, https://www.youtube.com/playlist?list=PLKBMoE8mCkXi-sAkesjaUnDQqyrkAK8R5
- Cryptocurrency, https://www.youtube.com/c/KamilSkowron/videos
* TODO https://joearms.github.io/published/2013-05-31-a-week-with-elixir.html
- sigils are from ruby
- on erlang, the AST has a different form for everythin
  on elixir, the AST is more uniform
- ~static-single-assigment~ is to what the elixir re-binding gets reduced
* Book: Elixir In Action
- SELF: redefine variables? (shoddy closures), start from 0, dot operator, <> compares all?, what is the point of *with*???
** 1 First Steps
- Elixir code compiles to BEAM-compliant bytecode.
- Ecto: brings LINQ-style queries to Elixir, using macros
- Most Elixir is written in Elixir
- ~staircaising~ is the style of nesting function calls
  clumsy as you have to parse it inside-out
- |> aka the "pipeline operator"
** 2 Building Blocks
- Everything in Elixir is an *expression* that returns a value
- .ex, and .exs for scripts
- *def* and *defmodule* are actually macros
- # Comments
- mix run -e "IO.puts(MyProject.hello())
  elixir --no-halt script.exs
  iex my_source.ex
*** Variables: are_underscored_and_lowercase
- Assignment is called *binding*
- you CAN rebind the variable!!!!
  (internally creates a new variable)
*** Modules: CamelCase
- maybe (.) for hierarchy convinience (not actual meaning or way to query hierarchy)
- you CAN nest defmodule definitions
- import Module
- alias Geometry.Rectangle, as: Rectangle
  alias Geometry.Rectangle # SAME
- module @ attributes: compile-time constants
  defmodule Circle do
    @pi 3.14159
    def area(r), do: r*r*@PI
  end
  - @doc @moduledoc
  - ex_doc uses those to generate html documentation
  - Typespec
    @spec area(number) :: number
*** Functions: named_as_variables
- ALWAYS part of a module
- end with:
  - ? for a boolean function
  - ! for something that can raise an runtime error
- short form
  def area(a,b), do: a * b
- You can ommit parenthesis on call (not recommended)
- shorthand to default arg value, generate multiple functions
  def sum(a, b \\ 0) do
    a + b
  end
- *def*  creates public functions
  *defp* creates private functions
*** IEX
- do NOT try to measure performance from IEX (as what you type will be interpreted)
  unless you define a module (which will be compiled)
- *-pa* switch for alternative _code paths_
  code.get_path() to check live
- h() Module
*** Types
**** Numbers
  2         (integer)
  0xFF      (integer written in hex)
  3.14      (float)
  1.0e-2    (float, exponential notation)
  1_000_000 (rust!?)
  - no integer limit
**** Atoms
  :an_atom
  :"another atom with spaces"
  AnAtom == :"Elixir.AnAtom" (an alias)
**** Nil and Truth
  :true and :false are atoms and can be written as true and false (syntatic sugar)
  :nil or nil
  && returns the last false OR the last one
  || returns the first that is not false
**** Tuple {}
  Kernel.put_elem/3 to modify a value
  - Modifying tuples creates shallow copies
  - Rebinding creates new copies
**** Lists []
  For random access use tuples, maps or...¡?
  Enum.at/2 # to get an element from a list
  *in* operator
    5 in prime_numbers
  List.replace_at/3 # to modify a list
  List.insert_at/3  # to add a element at a position, -1 to the end
  There are also ~improper lists~, that is where the tail is NOT a list.
  Modifying Lists 1) creates shallow copies of the elements before the new one
                  2) allocates the new value
                  3) rest of the tail is shared
**** Maps %{}
- dynamically sized
  #+begin_src elixir
    %{1 => 2, 2 => 4, 3 => 9}
    amap = Map.new([{1,1},{2,4},{3,9}])
    amap[2] # OR Map.get/3    with a default value
            # OR Map.fetch/2  with {:ok, val} or :error returns
            # OR Map.fetch!/2 for an exception version
    Map.put/3
    Map.update/4
    Map.delete/2
  #+end_src
- Structured data
  #+begin_src elixir
    alice = %{:name => "Alice", :age => 25}
    bob = %{name: "Bob", age: 25} # shorthand if keys are atoms
    bob[:age] == bob.age
    %{bob | age: 26} # modify value, already existing
  #+end_src
**** Binary <<>>
- a chuck of bytes
- <<1,2,3>>
- truncated/mod to 255
- 1::N to tell the number of N bits to use
- <> can be used to concatenate binaries
**** Binary strings ""
  String.to_charlist/1
  - Recommended over...
  - #{} to place an expresion inside a string constant
  - ~s() also declared used *sigils*, useful include a quoted (") text
    ~S() same but not #{} support or escape
  - *heredocs* support """hey"""
  - <> can be used
**** Character List ''
  List.to_string/1
  - #{} ~c() ~C() '''hey'''
**** Lambdas
#+begin_src elixir
square = fn x -> x * x end
square.(5)
&IO.puts/1 # to refer to the function
           # capture operator
Enum.each([1,2,3], &IO.puts/1)
# same
&(&1 * &2 + &3)
fn x,y,z -> x * y + z end
#+end_src
*** Higher-level Types
- Range, Keyword, MapSet
  Date, Time, NaiveDateTime, Datetime
**** Range 1..2
- in operator
  > 2 in 1..10
  true
- are Enum
**** Keyword List [:monday 1, :tuesday 2]
- aka proplist
- internally as [{:monday, 1}]
- [] operator suport
- used for arbitrary number of arguments
  IO.inspect([100,200,300],[width: 3])
  IO.inspect([100,200,300, width: 3)
  def my_fun(arg1, arg2, opts \\ []) do
  end
**** MapSet (aka a set)
- Enum
- No order
- MapSet.New([:monday, :tuesday])
  MapSet.member?(days, :monday)
  MapSet.put(days, :friday)
**** Time and Dates
#+begin_src elixir
date = ~D[2018-01-31]
adate.year  # 2018
time = ~T[11:59:12.00007]
time.hour   # 11
naive_datetime = ~N[2018-01-31 11:59:12.00007]
naive_datetime.year # 2018
datetime = DateTime.from_naive!(naive_datetime, "Etc/UTC")
datetime.year # 2018
#+end_src
**** IO List
- Integer 0 to 255
  A binary
  An IO list
- iolist = [[['H', 'e'], "llo,"], " worl", "d!"]
- appending is O(1) unlike lists
*** Operators
#+begin_src elixir
1 ==  1.0 # true weak
1 === 1.0 # false strict
#+end_src
- Logical: and or not
- Short-circuit: || &&
*** Runtime
- Each modules is compiled into a separate file
  - With .beam extension
  - With name Elixir.ModuleName due the nature of Atoms
- BEAM Bogdan Bjorn's
       Erlang
       Abstract
       Machine
** 3 Control Flow
*** Pattern matching
- pattern matching returns the right side of the =
- _ is called ~anonymous variable~
- the *PIN operator* ^ on matching ensure that a variable is not rebound,
  and match fails if it tries with something different than what already has binded
- When matching a map, you don't need to have all the fields on the left side
- matching strings
  > command = "ping www.example.com"
  > "ping" <> url = command
  > url
  "www.example.com
- = is called ~match operator~
  - is right associative
  - you can chain several
  #+begin_src elixir
    date_time = {_, {hour, _, _}} = :calendar.local_time()
    {_, {hour, _, _}} = date_time = :calendar.local_time()
  #+end_src
*** Pattern Matching in Functions
- ~multiclause functions~ is a type of function overloading of the same arity
  - you can't reference a specific clause
- Elixir terms can be compared with the operators < and >,
  even if they’re not of the same type. In this case, the type ordering determines the result:
  number < atom < reference < fun < port < pid < tuple < map < list < bitstring (binary)
- Errors on guards are internally handled
- Multi-clause lambdas are allowed
*** Branching
- Multiclauses can give some kind of polymorphism
- if, if else, unless, cond (true), case (_)
  with:
  - binds several expressions in his scope
  - and returns the one that failed, if it did
*** Recursion
- Tail call recursion looks more procedural.
  While non-tail looks more declarative.
*** Comprehension
- Can return anything that is a *Collectable*
#+begin_src elixir
  for x <- [1,2,3] do
    x*x
  end
  for x <- [1,2,3], y <- [1,2,3], do: {x,y,x*y} # one liner, nested iteration
  for x <- 1..9, y <- 1..9,
    x <= y,      # comprehension filter
  into: %{} do # specify the type of collectable to return
    {{x,y},x*y}    # first elem will be the KEY, second the VALUE
  end
#+end_src
*** Streams
- Is a lazy Enumerable
- useful when multiple actions happen on a Enumerable
  so instead of iterate several times
  you lazily Stream. over it and then Enum.each/
#+begin_src elixir
  # Create the stream
  stream = [1,2,3] |>
    Stream.map(fn x -> 2 * x end)
  Enum.to_list/1
  Enum.take/2
  File.stream!/1
#+end_src
** 4 Data Abstractions
- Elixir promotes decoupling of date from the code.
- Modifier functions: return the same type as their input
  Query function: return a different type as their input
- Structs: define an abstraction and bind it to a module
#+begin_src elixir
  defmodule Fraction do
    defstruct a: nil, b: nil
  end
  one_half %Fraction{a: 1, b: 2}   # Initialization
  %Fraction{a: a, b: b} = one_half # Patter Matching
  %Fraction{} = one_half           # Type Assertion
#+end_src
* Course: Elixir Sips
|                |                       | str |                                             |
|----------------+-----------------------+-----+---------------------------------------------|
| book author    |                       |     | https://github.com/knewter                  |
| dynamo(2014)   | web framework         | 1.1 | https://github.com/dynamo/dynamo            |
| plug           | web framework         | 2.6 | https://github.com/elixir-plug/plug         |
| ecto           | ORM?                  | 5.6 | https://github.com/elixir-ecto/ecto         |
| amnesia(2019)  | in memory db          | 0.6 | https://github.com/meh/amnesia              |
| xmerl          | build-in (erlang)     |     | https://www.erlang.org/doc/man/xmerl.html   |
| gen_tcp        | build-in (erlang)     |     | https://www.erlang.org/doc/man/gen_tcp.html |
| httpc          | http client (erlang)  |     | https://www.erlang.org/doc/man/httpc.html   |
| ibrowse        | http client (erlang)  | 0.5 | https://github.com/cmullaparthi/ibrowse/    |
| hackney        | http client (erlang)  | 1.3 | https://github.com/benoitc/hackney          |
| exactor        | GenServer generation  | 0.6 | https://github.com/sasa1977/exactor         |
| riak           | decentralized db      | 3.8 | https://github.com/basho/riak               |
| elixiak (2013) | riak wrapper          | 0.1 | https://github.com/drewkerrigan/elixiak     |
| weber (2016)   | web framework(elixir) | 0.3 | https://github.com/elixir-web/weber         |
** 003 Pattern matching
Function Call:  print_name.(:josh)
1) =match operator=
   - (=) is just the equal sign
   - Is more like an assertion than assigment
   - if unbound binds
   - if you do _not_ want to rebound, you need to signal it to the compiler
     different from Erlang
     a = 3
     [^a,2] = [4,2]
2) =Function definitions= (ocaml like)
   #+begin_src elixir
     print_name_egostistically = fn
       :josh -> "your name is josh!"
       _     -> "i don't care!"
   #+end_src
3) =Case Statements=
  #+begin_src elixir
    case {1,2,3} do
      {4,5,6} -> "no match here"
      {1,2,3} -> "this matches"
      {_,2,3} -> "thiw would match, but since it's below another match it isn't hit"
    end
  #+end_src
** 004 Functions
- invoking a funtion immediatly
  #+begin_src elixir
    (fn -> "foo" end).()
  #+end_src
- string intepolation
  #+begin_src elixir
    polite_greeter = fn
      name -> "Hello, #{name}, nice to meet you!"
    end
  #+end_src
** 005 Modules
- Modules are the primary unit of code organization in Elixir
  - private and public functions
- mix
  | mix new project_name |                        |
  | mix deps.get         | install dependencies   |
  | mix docs             | generate documentation |
- iex lib/modules_example.ex
  h(ModuleExample)
- elixirc lib/modules/example.ex (creates a .bin file)
  iex
- mix.exs
  | def       | public function                                        |
  | defp      | private function                                       |
  | use       |                                                        |
  | defmodule |                                                        |
  | deps.()   | to add depedencies, like :ex_doc to generate html docs |
- modules are and documentation are first class constructs, can be returned or binded like other values
  #+begin_src elixir
    output = defmodule Foo do
      @moduledoc """
        whate is this
      """
      @doc """
        A function documentation
      """
      def bar do
        "where"
      end
    end
    # {:module, Foo, BINARY_BYTECODE, {:bar, 0}};
  #+end_src
** 006 Unit Testing
#+begin_src elixir
  defmodule SchizoTest do
    use ExUnit.Case
    test "uppercase does't change the first word" do
      assert(Schizo.uppercase("foo") == "foo")
    end
    def test_one_is_one() do
      assert 1 == 1
    end
    test "one is one" do
      assert 1 == 1
      refute 2 == 1
    end
  end
#+end_src
- lib/schizo.ex
  #+begin_src elixir
    defmodule Schizo do
      def uppercase(string) do
        words = String.split(string)
        words_with_index = Stream.with_index(words)
        transformed_words = Enum.map(words_with_index, &uppercase_every_otherword/1)
        Enum.join(transformed_words, " ")
      end
      def uppercase_every_other_word({word, index}) do
        cond do
          rem(index, 2) == 0 -> word
          rem(index, 2) == 1 -> String.upcase(word)
      end
    end
  #+end_src
- functions with empty body return "nil"
- Regular expressions
  %r([0-9])
- to pass functions to other functions, you need to pass it with reference (&) and arity (/1)
  &uppercase_every_other_word/1
- mix test
- .vimrc
  map <leader>t :!mix test<CR>
- test/assert/refute are macros
- an exunit test case, is just a module that uses exunit.case
  - runs all functions that start with "test", with arity 1
*** functions used
  Regex.replace/3
  Stream.with_index/1
  String.split/1
  String.upcase/1
  String.replace/3
  Enum.join/2
  Enum.to_list/1
  Enum.map/2
*** doctest
- In the test
  #+begin_src elixir
    defmodule SchizoTest do
      use ExUnit.Case
      doctest Schizo
  #+end_src
- In the code
  #+begin_src elixir
    @doc """
      Uppercases every other word in a sentence. Example:

      iex> Schizo.uppercase["you are silly")
      "you ARE silly"
    """
    def uppercase(string) do
      transform_every_other_word(string, &uppercaser/1)
    end
  #+end_src
** 007 Dynamo, Part 1
- ABANDONDED in 2014 https://github.com/dynamo/dynamo
- In favor of others like Plug https://github.com/elixir-plug/plug
- Web framework that runs on elixir
- mix deps.get
  mix server
- .eex templates
  <%= @title %>
- use Dynamo.Router
  | prepare       | macro, runs for every action inside the router(file) |
  | get           | macro                                                |
  | post          | macro                                                |
  | render/2      | function, takes a connection and template filename   |
  | conn.assign/2 |                                                      |
  | conn.fetch/2  |                                                      |
  | con.params    | dictionary                                           |
** 008 Dynamo, Part 2 (Ecto/Amnesia)
- Code.require_file/2
  Amnesia.transaction macro
- test/test_helper.exs
  #+begin_src elixir
    defmodule Amnesia.Test do
      def start do
        :error_logger.tty(false)
        Amnesia.Schema.create
        Amnesia.start
        :ok
      end
      def stop do
        Amnesia.stop
        AMnesia.Schema.destroy
        :error_logger.tty(true)
        :ok
      end
    end
    ExUnit.start
  #+end_src
- test/amnesia_test.exs
  #+begin_src elixir
    Code.require_file "../test_helper.exs", __FILE__
    use Amnesia
    require Exquisit
    defdatabase Dwitter.Database do
      deftable Dweet, [:id, :content], type: :ordered_set do # first field becomes the PK
        @type t :: Dweet[:id integer, content: String.t]
        def in_reply_to(self) do Dweet.read(self.in_reply_to_id) end
        def replies(self) do Dweet.where(in_reply_to_id == self.id).values end
      end
    end
    defmodule AmnesiaTest do
      use ExUnit.Case
      use Dwitter.Database
      test "saving dweets" do
        Amnesia.transaction! do
          dweet = Dweet[id: 1, content: 'something things happened']
          dweet.write
        end
        assert 'some things happened.' == Dweet.read!(1).content
      end
      setup_all do AMnesiaTEst.start end
      teardown_all do Amnesia.Test.stop end
      setup do
        Dwitter.Database.create!
        ok:
      end
      teardown do
        Dwitter.Database.destroy
        :ok
      end
    end
  #+end_src
** 009 Dynamo, Part 3 (Amnesia)
- lib/dwitter/database.ex (has the defdatabase code)
- lib/dwitter.ex
  #+begin_src elixir
    defmodule Dwitter do
      def start(_type, _args) do
        Amnesia.Schema.create
        Amnesia.start
        Dwitter.Database.destroy
        Dwitter.Database.create
        Dwitter.Dynamo.start_link([max_restarts: 5, max_seconds: 5])
      end
    end
  #+end_src
** 010 List Comprehensions
#+begin_src elixir
  lc x inlist [1,2,3,4], do: x*2              # [2,4,6,8]
  lc x inlist [1,2,3,4], do: [x, x*2]         # [[1,2], [2,4], [3,6], [4,8]]
  lc x inlist [1,2,3,4], rem(x,2) == 0, do: x # [2,4]
  lc x inlist [1,2,3], y inlist [4,5,6], do: x*y # [4,5,6,8,10,12,12,15,18]
  lc x inlist [1,2,3], y inlist [4,5,6], do: {x,y} # [{1,4}, {1,5}, {1,6}, {2,4}, {2,5}...
#+end_src
** 011 Records
- deprecated
- _records are just modules_
  #+begin_src elixir
    {:module, NewRecord, _, nil} = defrecord NewRecord, first_name: ni l, last_name: "Dudington"
    # 2 ways to create arecord .new() or []
    dude = NewRecord.new first_name: "Dude"
    bro = NewRecord[first_name: "Bro"]
  #+end_src
- IS NOT RECOMMENDED to declare the state and the behaviour in 1(one) place.
  it is more accepted for example define a record ina module and functions that work with it
  #+begin_src elixir
    defrecord Person, first_name: nil, last_name: "Dudington" do
      def name(record) do
        "#{record.first_name} #{record.last_name}"
      end
    end
    guy = Person.new first_name: "Guy"
    guy.name
  #+end_src
- _instances of it are just tuples_
  #+begin_src elixir
    fake_person = {Person, "fake", "person"}
    fake_person.name
  #+end_src
- pattern match on functinos
  #+begin_src elixir
    defmodule PersonPrinter do
      def say_hello(Person[first_name: first, last_name: "Dudington"]) do # matches the exact string
        "hey' it's my brother ${first}!"
      end
      def say_hello(Person[first_name: first) do
        "hello, #{first}"
      end
    end
  #+end_src
** 012 Processes
- assert_receive (macro)
- erlang is a concurrency oriented programming language
  - a process is his unit of concurrency
- iex -S mix
** 013 Processes (CQRS/Event Sourcing)
- Command Query Responsability Segregation
  1) Where queries do not modify the state of the system
  2) And commands do not return any meaninful data
- CQRS happen naturally when you have a BEAM process with a *receive* for different commands
- For fun is modeled here as a list of events that ocurred in the account.
  Either, deposit or withdraw.
  aka *event sourcing*
** 014 OTP Part 1: Servers (GenServer)
- :gen_server.start_link(FridgeServer, [], [])
- :gen_server.call(PID, MSG)
- :gen_server calls are usually wrapped in a function on our module
- init/1 is implicitly called when :gen_server.start_link
  - must return a tuple
    {:ok, STATE_OF_THE_SERVER}
- handle_call/1
** 015 OTP Part 2: State Machines (GenFSM)
- use GenFSM.Behaviour
  :gen_fsm.start_link/3
  :gen_fsm.send_event/2?
  :gen_fsm.sync_send_event/2
- FSM API
  #+begin_src elixir
    def init(_) do {:ok, :starting, []} end
    def starting(:s, _from, state_data) do {:reply, :got_s, :got_s, state_data} end
    def starting(_, _from, state_data) do  {:reply, :starting, :starting, state_data} end
  #+end_src
- A FSM is a mean of modeling some computation
  1) Limited number of states
  2) Has an initial state
  3) It can transition from a state to another, based on some event or condition
- Example: Find a substring.
  Type: Acceptor State Machine. Produce binary output.
** 016 Pipe Operator
- In elixir, the pipe operator:
  - takes the output of an expression on the _left_ of it
  - and feeds it in as the 1st argument to the function on the _right_ of it
- You can technically make the pipe operator work on other places than the first argument.
  #+begin_src elixir
    String.strip(line)
    |> (&Regex.split(%r/ /, &1, trim: true)).()
    |> Enum.at(column-1)
  #+end_src
** 017-019 Enum
- Enum works on anything that implements the "enum" protocol
| Enum.        | / |                                                                            |
|--------------+---+----------------------------------------------------------------------------|
| .all?        | 2 | true/false                                                                 |
| .any?        | 2 | true/false                                                                 |
| .at          | 2 | nil or index at                                                            |
| .chunks      | 2 | returns "sized" elements each                                              |
|              | 3 | adds a "step" argument (cl :by)                                            |
|              | 4 | adds a "padding" to fill in chunks                                         |
| .chunks_by   | 2 | splits each time time fn returns a new value                               |
| .concat      | 1 | aka flatten                                                                |
| .count       | 1 | aka length                                                                 |
|              | 2 | aka filter + length                                                        |
| .drop        | 2 |                                                                            |
| .drop_while  | 2 | while fn returns true                                                      |
| .each        | 2 | aka foreach, returns :ok                                                   |
| .empty?      | 1 | returns boolean                                                            |
| .fetch(!)    | 2 | returns a tuple, { :ok, elem_at_index } or :error                          |
| .filter      | 2 | returns only *elements* where fn returns true                              |
| .filter_map  | 3 | aka filter + map                                                           |
| .find        | 2 | returns the 1st *element* where fn returns true or nil                     |
|              | 3 | with default if not found                                                  |
| .find_index  | 2 | returns the *index* instead of the *element*                               |
| .find_value  | 2 | returns the *value* of the fn that was true                                |
| .first       | 1 | returns first or nil                                                       |
| .flat_map    | 2 |                                                                            |
| .join        | 2 | joins the collection with a joiner                                         |
| .map         | 2 |                                                                            |
| .map_join    | 3 | map + join                                                                 |
| .map_reduce  | 3 | map + reduce, does the map while keeping an accumulator                    |
|              |   | returns a tuple with the result of each map/reduce                         |
| .max         | 1 | raises an empty error                                                      |
| .max_by      | 2 | Enum.max_by([1,2,3], fn(x) -> 10-x end)                                    |
| .min         | 1 |                                                                            |
| .min_by      | 2 |                                                                            |
| .member?     | 2 |                                                                            |
| .partition   | 2 | partitions into 2(two) collections, based on a boolean fn                  |
| .reduce      | 2 | the first element is used as the initial value of the accumulator          |
|              | 3 | or pass the initial value directly                                         |
| .reject      | 2 | not filter                                                                 |
| .reverse     | 1 |                                                                            |
| .shuffle     | 1 |                                                                            |
| .slice       | 3 | (coll, from, howmany) NOTE: expects an ordered collection                  |
| .sort        | 1 | NOTE: uses merge-sort                                                      |
|              | 2 | you can pass it an order function                                          |
| .split       | 2 | splits into 2(two) collections, providing a number of elements for the 1st |
| .split_while | 2 | while fn returns true                                                      |
| .take        | 2 | NOTE: expects an ordered collection                                        |
| .take_every  | 2 | takes every nth item, starting with the first                              |
| .take_while  | 2 | NOTE: expects an ordered collection                                        |
| .to_list     | 2 | collection to list                                                         |
| .uniq        | 1 | remove duplicates                                                          |
| .with_index  | 1 | wraps each element on a tuple with their index                             |
| .zip         | 2 | if second list is shorter, values are filles with *nil*                    |
** 020-021 OTP Part 3: GenEvent
- use GenEvent.Behaviour
- :gen_event.start_link/0
  :gen_event.add_handler/3
  :gen_event.call/3 (pid, ModuleImplementing, msg)
- handle_event/2
  handle_call/2
** 022 OTP Part 4: Supervisors
- GenServer
- Supervisor
- :supervisor.start_link
  worker/2
  supervise/2
#+begin_src elixir
  defmodule ListSupervisor do
    use Supervisor.Behaviour
    def start_link do
      :supervisor.start_link(__MODULE, [])
    end
    def init(list) do
      child_processes = [ worker(ListServer, list) ]
      supervise child_processes, strategy: :one_for_one
    end
#+end_src
** 023 OTP Part 5: Supervisors and Persistent State
- testing supervisors crashes might be tricky due startup timings
- :supervisor.start_child/3
- Example: storing the state on a different process
- Supervision Tree
  List(Sup)ervisor > ListData (GenServer)
                   > List(Sub)Supervisor > ListServer
- start supervising an empty tree and add them later,
  so you can get the pid of the ListData and give it to ListServer
- GenServer API, we store the state on it
  terminate/2 (reason, state)
- lib/lis_supervisor.ex
  #+begin_src elixir
    defmodule ListSupervisor do
      def start_link do
        result = {:ok, sup} = :supervisor.start_link(__MODULE__, [])
        start_workers(sup)
        result
      end
      def start_workers(sup) do
        {:ok, list_data} = :supervisor.start_child(sup, worker(ListData, []))
        :supervisor.start_child(sup, worker(ListSubSupervisor, [list_data]))
      end
      def init(_) do
        supervise [], strategy: :one_for_one
      end
    end
  #+end_src
** 024-25 Ecto
- Postgres persistence
- *repos* are what Ecto uses to persiste your entities on a database
- *entity* describes the data to be stored on the databse, defines a record
- *models* where behaviours live, defines how to connect the an entity to a database table
  1) Ecto.model.query
  2) Ecto.model.validations
  3) Ecto.model.callbacks
- lib/ecto_test/repo.exs
  #+begin_src elixir
    defmodule EctoTest.Repo do
      use Ecto.repo, adapter: EctoAdapters.Postgres
      def url do "ecto://postgres:postgres@localhost/ecto_test" end
      def priv do # Where private files are kept, where to place migrations
        app_dir(:ecto_test, "priv/repo")
      end
    end
  #+end_src
- lib/ecto_test/dweet.ext
  #+begin_src elixir
    defmodule EctoTest.Dweet do
      use Ecto.Model
      queryable "dweets" do
        field :content, :string
        field :author,  :string
      end
    end
  #+end_src
- psql -- create the database
  mix compile
  mix ecto.gen.migrate Ectotest.Repo create_dweets
  vim priv/repo/migrations/____create_dweets.exs
  #+begin_src elixir
    defmodule Dwitter.Repo.Migrations.CreateDweets do
      def up do
        "CREATE TABLE dweets(id serial primary key, content varchar(150), author varchar(50))"
      end
      def down do
        "DROP TABLE dweets"
      end
    end
  #+end_src
  mix ecto.migrate EctoTest.repo
- iex -S mix
  d = EctoTest.Dweet.new(content: "foo")
  d = d.author("djames")
  EctoTest.Repo.create(d)
- query
  #+begin_src elixir
    use Ecto.Query
    query = from d in Dwitter.Dweet, order_by: [Desc: d.id], limit: 10, select: d
    recent_dweets= Dwitter.Repo.all(query)
  #+end_src
** 026-27 Dict
- Dict/HashDict
| .delete   | 2 | do nothing if missing                                                   |
| .drop     | 2 | can delete multiple                                                     |
| .empty    | 1 | receives a Dict, returns an empty Dict of the same type                 |
| .equal?   | 2 | compares 2 Dict, if diff types they are converted to lists before check |
| .fetch    | 2 | returns {:ok,value} or :error                                           |
| .fetch!   | 2 | returns value or throws an exception                                    |
| .get      | 2 | if not in dict, returns nil                                             |
|           | 3 | if not in dict, returns default argument                                |
| .has_key? | 2 |                                                                         |
| .keys     | 1 |                                                                         |
| .merge    | 2 | the key on the 2nd dict wins                                            |
|           | 3 | takes a fn to resolve the conflict (k,v1,v2)                            |
| .pop      | 3 | takes a default, returns {value,new_dict}                               |
| .put      | 2 | replaces value                                                          |
| .put_new  | 2 | does NOT replace                                                        |
| .size     | 1 |                                                                         |
| .split    | 2 | returns {dict,dict}, takes a list of keys                               |
| .take     | 2 | returns a dict of the provided keys                                     |
| .to_list  | 1 |                                                                         |
| .update   | 4 | updates a value with fn, takes an initial value                         |
| .update!  | 3 | exception if key not present, no initial value                          |
| .values   | 1 |                                                                         |
** 028 Parsing XML (xmerl)
- erlang buildin module https://www.erlang.org/doc/man/xmerl.html
- :xmerl_scan.string/1
  :xmerl_path.string
  :xmerl_xpath.string
*** Example: title text, :xmerl_path.string
- We need to define the Erlang record on elixir, since they differ (defrecord)
  #+begin_src elixir
    defrecord :xmlElement, Record.extract(:xmlElement, from_lib: "xmerl/include/xmerl.hrl")
    defrecord :xmlText, Record.extract(:xmlText, from_lib: "xmerl/include/xmerl.hrl")
    defmodule XmlParsingTest do
      { xml, _rest } = :xmerl_scan.string(bitstring_to_list(sample_xml))
      [ title_element ] = :xmerl_xpath.string('/html/head/title', xml)
      [ title_text ] = title_element.content
      title = title_text.value
  #+end_src
*** Example: title text, :xmerl_xpath.string
  #+begin_src elixir
    { xml, _rest } = :xmerl_scan.string(bitstring_to_list(sample_xml))
    [ p_text ]= :xmerl_xpath.string('/html/body/p/text()', xml)
  #+end_src
*** Example: <li> array
  #+begin_src elixir
    { xml, _rest } = :xmerl_scan.string(bitstring_to_list(sample_xml))
    li_texts = :xmerl_xpath.string('/html/body/ul/li/text()', xml)
    texts = li_texts |> Enum.map(fn(x) -> x.value end)
  #+end_src
** 029 HTTP Clients (httpc/ibrowse/hackney)
- Regex.match?/2
*** httpc
- you need to start ":inets" application
- :httpc.request/1 takes a list as argument NOT a string
#+begin_src elixir
  { :ok, {{_version, 200, _reason}, _headers, body}} = :httpc.request('http://example.com')
#+end_src
*** ibrowse
- needs :ibrowse application to start
- :ibrowse.send_req/3
- '200' is a list
#+begin_src elixir
  { :ok, '200', _headers, body } = :ibrowse.send_req('http://example.com', [], :get)
#+end_src
*** hackney
#+begin_src elixir
  {:ok, 200, _headers, client} = :hackenet.get("http://example.com")
  {:ok, body, client} = :hackney. body(client)
#+end_src
** 030 ExActor
- simplifies the creation of GenServer's (provides macros)
- Example ListActor
  #+begin_src elixir
    defmodule ListActor do
        use ExActor, initial_state: []
        defcall get, state: state, do: state
        defcast put(x), state: state, do: new_state(state ++ [x])
        defcast take(x), state: state, do: new_state(List.delete(state, x)
    end
#+end_src
- Example CountActor
  - This time exports a named atom to register the  server under ":counter"
  - call/cast won't need to have a PID pass to them, they use the atom to call
  #+begin_src elixir
    defmodule CountActor do
      use ExActor, export: :counter
      #defcall get, state: state, do: state
      defcall get, state: state, when: state == 2, do: :two
      defcast inc, state: state, do: new_state(state + 1)
      defcast inc, state: state, do: new_state(state - 1)
    end
  #+end_src
** 031 TCP Servers (:gen_tcp)
| :gen_tcp.listen/2 | (port, options) |
| :gen_tcp.accept/1 | (socket)        |
| :gen_tcp.recv/2   | (socket,length) |
| :gen_tcp.send/2   | (socket,string) |
- we test it using telnet
- This example blocks for each processed connection
- lib/tcp_server/server.ex
  #+begin_src elixir
    defmodule TcpServer.Server do
      def listen(port) do
        IO.puts "listening on port #{port}"
        tcp_options = [:binary, {:packet, 0}, {:active, false}]
        {:ok, listen_socket} = :gen_tco.listen(port, tcp_options)
        do_accept(listening_socket)
      end
      def do_accept(listening_socket) do
        {:ok, socket} = :gen_tcp.accept(listening_socket)
        do_listen(socket)
      end
      def do_listen(socket) do
        case :gen_tcp.recv(socket, 0) do
          {:ok, data} ->
            IO.puts "Got some data! #{data}"
            :gen_tcp.send(socket, "roger, wilco\n")
            do_listen(socket)
          {:error, :closed} ->
            IO.puts "The client closed the connection..."
      end
    end
  #+end_src
** 032 Command Line Scripts
- Example: fetch local weather data from the internet
- Uses hackney to download the xml
- System.argv
- scripsts/get_temperature.exs
  #+begin_src elixir
    [woeid|_rest] = System.argv
    temp = CurrentWeather.YahooFetcher.fetch(woeid)
    IO.puts "The current weather for woed #{woeid} is #{temp} degrees fahrenheit."
  #+end_src
- Invoking it: mix run scripts/get_temperature.exs 2378489
** 033 IEx.pry
- Creates a breakpoint that has access the lexical scope of the function
  pry(1)> respawn -- to quit
- A tool to inspect or debug a running process (elixir build-in)
#+begin_src elixir
  require IEx
  defmodule IexPryTest do
    def start(_type, _args) do
      IexPryTest.Supervisor.start_link
    end
    def add(a,b) do
      c = a + b
      IEx.pry
      c
    end
#+end_src
** 034 Elixiak
- an ActiveRecord-like wrapper for Riak in Elixir
- Example: to store log data and filter by application
- .create().save!
  .find()
  .bucket
- test/elixiak_playground_test.exs
  #+begin_src elixir
    defmodule ElixiakPlaygroundTest do
      use ExUnit.Case
      setup do
        Riak.start
        Riak.configure(host: '127.0.0.1', port. 8087)
        delete_all_logs
        :ok
      end
      test "we can store logs" do
        Log.create(application: "web", content: "GET /foo/bar by 10.0.0.1").save!
        Log.create(application: "backened", content: "image foo1.jpg resized.").save!
        web_results = Log.find(application: "web")
        assert Enum.count(web_results) == 1
        assert List.last(web_results).content == "GET /foo/bar by 10.0.0.1")
      end
      def delete_all_logs do
        {:ok, keys} = Riak.Bucket.keys Log.bucket
        keys |> Enum.each(fn(key) -> Riak.delete(Log.bucket, key) end)
      end
    end
  #+end_src
- lib/elixiak_playground/log.ex
  #+begin_src elixir
    defmodule Log do
      use Elixiak.Model
      document "log" do
        field :application, :string, indexed: true
        field :time,        :datetime, indexed: true
        filed :content,     :binary
      end
    end
  #+end_src
** 035 Weber
- an MVC web framework for elixir
- make
  make test
  mix weber.new ../cityguide --grunt
  cd ../cityguide
  mix deps.get
  mix compile --all --force # compile each time you change the code
  ./start.sh
- :Cityguide.Main is a controller
  the function action() get run on request
- lib/controllers/main.ex
  lib/views/Main.html
  lib/views/Guide.html
  lib/controllers/guide.ex
- lib/route.ex
  #+begin_src elixir
    defmodule Route do
      import WEber.Route
      require Weber.Route
      route on("GET", "/", :Cityguide.Main, :action)
         |> on("GET", "/cities/:cityname", :Cityguide.Guide, :action)
    end
  #+end_src
- is important to be careful to avoid DOS attacks by generating atoms in your application
  eg: binary_to_existing_atom/1
- defining functions with guards
  #+begin_src elixir
    defrecord City, name: "", woeid: ""
    # defmodule . . .
    defp city(cityname) when is_binary(cityname) do
      city(binary_to_existing_atom(cityname))
    end
    defp city(cityname) when is_atom(cityname) do
      cities[cityname]
    end
    defp citites do
      [
        birmingham: City[name: "Birminhan, AL", woeid: "2364559"],
        atlanta:    City[name: "Atlanta, GA", woeid: "2357024"]
      ]
    end
  #+end_src
** 036 Weber Part 2
- building a cache for our API calls
  - only request 1 every 5 minutes for each city
- elixir vs node.js and ruby
- lib/simple_cache.ex
  #+begin_src elixir
    defrecord SimpleCacheState,
      cache_interval: 60,
      cache: HashDict.new,
      cache_timings: HAshDict.new

    defmodule SimpleCache do
      use ExActor, export: :simple_cache, initial_state: SimpleCacheState.new
      defcast configure(new_config), state: state do
        state = state.cache_interval(new_config[:cache_interval])
        new_state(state)
      end
      defcast clear, state: state do
        state = state.cache(HashDict.new)
        state = state.cache_timing(HashDict.new)
        new_state(state)
      end
    end
  #+end_src
