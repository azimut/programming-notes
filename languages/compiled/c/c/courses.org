- 2h CS50 https://www.youtube.com/watch?v=cwtpLIWylAw
- 4h C Programming and Memory Management https://www.youtube.com/watch?v=rJrd2QMVbGM
  - by BootDev
- 18h Learn C Programming and OOP with Dr. Chuck https://www.youtube.com/watch?v=PaPN51Mm5qQ
  - by freeCode Camp
- [[https://www.youtube.com/playlist?list=PLnpfWqvEvRCchcCM-373x2630drhtdWEw][C Programming]] by Barry Brown
- COS 217 @Princeton
  - 20 Lecture https://www.youtube.com/playlist?list=PLwXw5yrGdQS55Q2ZODSqDNjm7Zhk4wFE3
  - 21 Lecture https://www.youtube.com/playlist?list=PLwXw5yrGdQS7zpF7M7yKQPJu7s7fFpnF3
  - 21 Q&A https://www.youtube.com/playlist?list=PLwXw5yrGdQS4HKVilgAm4mepG-7ZBS-2T
- Defensive Programming and Debugging
  - https://www.futurelearn.com/courses/defensive-programming-and-debugging
  - https://gjbex.github.io/Defensive_programming_and_debugging/
  - https://github.com/gjbex/DPD

* FrontEnd Masters - C Fundamentals

- Richard Feldman
- [[https://github.com/rtfeldman/c-workshop-v1][source]] [[https://docs.google.com/presentation/d/1CGtDVSazrJHI52OnwwJXgogQEHs63lrasfQWJvmcYM0/edit?usp=sharing][slides]]

** Part 1

- course uses Unix/POSIX/MacOS APIs
  - no Windows version of the course
  - in OSX, syscall numbers may change between os versions
    - forcing you to use the stdlib
    - unlike in Linux
- PDP-11 (Unix/C ran on it)
  - CPU 125kHz
  - 256Kb of memory
- in hardware/asm, ~scope~ is not a thing
- C
  - "portable assembly"
  - "the most universal language"
    - has interop with many/all
  - zero-overhead programming (eg: no gc)
    - +performance
  - almost zero-safety programming
  - has no stacktraces by default
  - ~print()~ comes from the tty/teletype era
  - "linking" removes unsused code by checking if anything jumps to it

*** Example: Hello World C / ASM

#+begin_src c
  #include <unistd.h>
  void main() {
    write(1, "Hello, World!", 13);
  }
#+end_src

#+CAPTION: equivalent in x86 assembly
#+begin_src asm
  .LC0: ; local constant 0
          .string "Hello, World!"
  main:
          mov edx, 13 ; length of string to write
          mov esi, OFFSET FLAT:.LC0
          mov edi, 1  ; write to stdout
          jmp write   ; OS provided
#+end_src

*** Example: write() with missmatched length and string length

#+CAPTION: if greater, it prints whatever is in the programs memory.
#+begin_src C :results value drawer both
  #include <unistd.h>
  int main() {
    write(1, "Hello, World!", 14);
    return 0;
  }
#+end_src

#+RESULTS:
:results:
Hello, World!^@
:end:

*** Example: giving wrong arguments to printf() format

- printf(): A wrapper around write()
  - when given 0 to %s prints "null"
- Calculates the length of the string
- Throws a segmentation fault.
  - When trying to read memory outside the program.

#+begin_src C :results drawer both
  #include <stdio.h>
  int main() { // program entry point
    int a = 42;
    int b = 21;
    /* printf("a = %d\nb = %5\n", a, b); */ // <-- Segmentation Fault
    printf("a = %d\nb = %d\n", a, b);
    return 0;
  }
#+end_src

#+RESULTS:
:results:
a = 42
b = 21
:end:

** Part 2 - Building HTTP Responses

Part1.mp4 01:27:00

*** Numbers in memory

- =We decide how to interpret memory=

- ASCII: American Standard ...
  - _always_ has the first bit set to zero(0)
  - so in reality it uses 7 bits, of the 8 of *char*
- UTF-8:
  - is backwards compatible with ASCII
  - uses the extra 8 bit to flag it as UTF-8

#+begin_src C
  write(int32, *char, int64)
#+end_src

*** Byte arrays

- referenced by the _memory address_ of the first element
  - aka pointer

*** Null-terminated strings

- aka the byte 0
- what strings use to know the end of a string

*** Getting a string's length

#+begin_src c
  #include <unistd.h> // write
  #include <string.h> // strlen
  char *header = "HTTP/1.1 200 OK"; // char header[]
  write(1, header, strlen(header)); // walks the array each time
  printf("Header: %zud\n", header); // %zud to print the address
#+end_src

** Part 3 - Parsing HTTP Requests

#+begin_src c
  char req[] = ""; // on the stack
  char *req = ""; // on read only memory
#+end_src

#+begin_src c
  // char *req = "GET /blog HTTP/1.1"
  // to_path(req) // blog/index.html
  char *to_path(char *req) {
    char *end;
    char *start = req;
    while(start[0] != ' ') {
      if (start[0] == '\0') { // == 0 / !start[0]
        return NULL; // return 0;
      }
      start = start + 1; // start += 1; start++;
    }
    start++; // skip over the space
    for (end = start; end[0] != ' '; end++) {
      if(!end[0]) return NULL;
    }
    if(end[-1] == '/') {
      end--;
    } else {
      end[0] = '/';
    }
    memcpy(end + 1, "index.html", 11);
    printf("Start: %s", start);
  }
#+end_src

** Part 4 - File I/O

#+begin_src c
  // Opening a file
  char *path = "example.txt";
  int fd = open(path, O_RDONLY);
  if (fd = -1) { /* handle error */}
  close(fd);

  // Reading Its contents
  char buffer[100];
  ssize_t length = read(fd, buffer, 100);
  if (length == -1) { /* handle error */ }
  // Getting its size
#+end_src

*** Stack vs Heap
