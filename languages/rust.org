- https://www.fpcomplete.com/blog/philosophies-rust-haskell/
- http://technosophos.com/2019/08/07/writing-a-kubernetes-controller-in-rust.html
- https://github.com/unknownue/vulkan-tutorial-rust
- https://hackernoon.com/programming-in-rust-the-good-the-bad-the-ugly-d06f8d8b7738
- Type on destructuring = instead of :
- https://github.com/bevyengine/bevy
- tut dns server https://github.com/EmilHernvall/dnsguide
- Implementing TCP in Rust (part 1) https://www.youtube.com/watch?v=bzja9fQWzdA
- 4k demo https://github.com/janiorca/sphere_dance
  https://www.codeslow.com/2020/07/writing-winning-4k-intro-in-rust.html
  https://www.youtube.com/watch?v=SIkkYRQ07tU
- https://research.mozilla.org/rust/
* Video: Build a cryptocurrency! - Blockchain in Rust #01: Blocks & Hashing
  https://www.youtube.com/watch?v=vJdT05zl6jk
#+begin_src rust
use supper:**; // import all files on project
pub struct Block {
  pub field1: u32,
}
[u8; 16]
[0; 16]
#+end_src
- Create      [u8; 16]
  Instantiate [0; 16]
- use supper:**;
* Video: 12 Things to Help You Learn Rust
  https://www.youtube.com/watch?v=a8abW3RlOn8
- println!
  - basic:      {}
  - alias(?:    {valx}
  - debug:      {:?}
  - positional: {0}
- ALL variables are immutable by default
- HOWEVER, shadowing of variables with the same name is possible with immutable vars
* Video: Considering Rust - Jon Gjengset
  https://www.youtube.com/watch?v=DnT-LUQgc7s
- Generics
  #+begin_src rust
  struct MyVect<T> {
  }
  impl<T> MyVect<T> {
    pub fn find<P>(&self, predicate: P) -> Option<&T>
     where P: Fn(&T) -> bool
    {
      for v in self {
        if predicate(v) {
          return Some(v);
        }
      }
      None
    }
  }
  #+end_src
- Algebraic data types: A type that contains other types
- Zero-cost abstraction
- ? "try operator" a error match, catch error
- FREE ffi calls, given there is no interpreter that needs to be noticed of an external call
- unsafe{} free compiler checks
- bindgen - generates rust code from C header
  cbindgen - generates a header file that you can use from other languages
- tools that work with rust: perf, gdb/lldb, valgrind, llvm sanitizers
* Video: Rust 101 - 2017 - E. Dunham
  https://www.youtube.com/watch?v=FMqydRampuo
- "Go is a SysAdmins programming language, Rust is language for system level programming."
- Compiler can output:
  - LLVM IR
  - ASM
- Macro syntax
  - "shorthand for funftions with variable number of arguments." ???????
  - end with "!", ex: println!
- Rust team compiles all public projects (?) and PR breaking changes on code in Stable to those projects.
* Video: Why would a python programmer learn rust when there are no jobs in it - 2019
  https://www.youtube.com/watch?v=IYLf8lUqR40
- C++ has no stable ABI
- Enumerated types can contain variables
- Structures+Traits VS Objects
- No exceptions
- Does NOT support inheritance
- Use the *has a* not the *is a* model
- OO - Binding a method to a structure
  #+begin_src rust
  struct Point {
    x: f64,
    y: f64,
  }
  // A freestanding function - Borrowed point to a string
  fn point_to_string(point: &Point) -> String { ... }
  // an "inherent impl"
  impl Point {
    // automatically borrows the Point
    fn to_string(&self) -> String { ... }
  }
  #+end_src
- OO - Traits: A common method to multiple types
  #+begin_src rust
  trait Hash {
    fn hash(&self) -> u64;
  }
  impl Hash for bool {
    fn hash(&self) -> u64 {
      if *self { 0 } else { 1 }
    }
  }
  impl Hash for i64 {
    fn hash(&self) -> u64 {
      *self as u64
    }
  }
  #+end_src
* Video: All about rust - 2019 - Microsoft Developer
  https://www.youtube.com/watch?v=FYGS2q1bljE
- "Cost on the compiler"
- linkerd "proxy" is written in Rust, the rest (cli, webservice) in Go
- Libraries:
  - Tokio: async run-time (similar to getty in Go)
  - Hyper: http library that uses Tokio
  - Tower: service framework
- Microsoft IOT does some rust: https://github.com/Azure/iotedge/
* Video: Rust Programming Techniques
  https://www.youtube.com/watch?v=vqavdUGKeb4
  Year: 2018
  By: Nicholas Cameron
- A rust a reference is a pointer, but references can never be NULL
- *match* the compiler checks that the matching type gets ~exhausted~
- *if let* on the other hand does ~non-exhaustive~ pattern matching
- A macro can hide a return

* Tutorial: EasyRust
  https://github.com/Dhghomon/easy_rust

|                | UpperCamelCase | snake_case |   |   |
|----------------+----------------+------------+---+---|
| Implementation | YES            |            |   |   |
| Struct         | YES            |            |   |   |
| Enum           | YES            |            |   |   |
| Variables      |                | YES        |   |   |
| Functions      |                | YES        |   |   |


|         | Create         | Access    | Match        | Insert            |
|---------+----------------+-----------+--------------+-------------------|
| Tuple   |                | .0        | (a,_b)       |                   |
| struct  |                | .FIELD    |              |                   |
| enum    |                |           | ENUM::Val(a) |                   |
| HashMap | HashMap::new() | .get(key) | (key,val)    | .insert(key, val) |
| Vector  | vec![]         |           |              |                   |
** Comments
#+begin_src rust
// Comment
/* Comment */
let some_number  /*: i16*/ = 100;
#+end_src
** Types
*** Primitive types
- ~usize~, ~isize~, are architecture dependant i32 or i64
  - usize is used for indexing
- ~as~ used for casting
  - can be used twice
  - *casting* is like "pretend" a value is a type
- ~char~
  - use single quotes for char
  - 4 bytes
  - some characters are 1,2,3 or 4 bytes long
  - .len() gives the size in bytes
  - .chars().count()
** Type inference
#+begin_src rust
let a = 100_000; // default to i32
let b = 5.;      // default to f64 ... but depending of context used it might choose f32...
let c: u8 = 1;
let d = 1u8;     // uses type u8
#+end_src
*** Floats
- Can't add f32 and f64 directly
- Defaults to f64
- Rust compiler miiiight infer to use f32n
** Printing 'hello, world!'
- ~macros~ have a ~!~ after them
- return and ~;~
  #+begin_src rust
  fn beta() -> i32 {
    8 // without a ; it can be used like this, otherwise it would return ()
    // return 8;  // Same but less idiomatic
    // 8;         // It will return ()
  }
  #+end_src
- ~->~ is called *skinny arrow*, shows the return type of a function
- {} *code blocks* can be def anywhere, and return values from it
** Display and debug
- {} and ~pretty printers~ {:?} {:#?}
- std::i8::MIN, std::i8::MAX
** Mutability
- let mut x = 10; - ~mutability~, when a variable can be changed
- let x = 2;      - ~shadowing~, if are the same type, although effectively are different variables
  let x = 10;
** The Stack, Head and Pointers
|       | Speed   | Size at compilation |
|-------+---------+---------------------|
| Stack | Fastest | yes                 |
| Heap  | Fast    | no                  |
- let x: isize = 3;
  let b = &x; // b is a ~reference~ to x, b ~borrows~ x
              // b has type &isize
** More about printing
- r#""raw"\tlines\n"#
- b"this string of ASCII bytes"
- \u{D589} - unicode printing
- {:p}           - pointer
  {:b} {:x} {:o} - binary, hexa, and octal
  {0} {1}        - order of arguments
  {foo} {bar}    - name of arguments
- {variable:padding alignment minimum.maximum}
  - no spaced ({:0^10})
  - can ommit variable name
  - alignment <>^ (left/right/middle)
** Strings
- Types of string
| type   | initialization                 | ownership | alloc? | speed   |
|--------+--------------------------------+-----------+--------+---------|
| &str   | let a = "hello";               | borrowed  | data?  | fastest |
| String | let a = String::from("hello"); | owned     | heap   | fast    |
- std::mem::size_of::<String>() = 24bytes
  std::mem::size_of::<i8>()     =  1bytes
  std::mem::size_of_val("abc")  =  3bytes
- ~format!()~ -- like print! but returns the value instead
** const and static
#+begin_src rust
const NUMBER_OF_MONTHS: u32 = 12;
static SEASONS: [&str; 4] = ["Spr", "Su", "F", "Win"];
#+end_src
- ~const~ , doesn't change
  ~static~, doesn't change, fixed memory location
- people use const more often
- CAPITALIZED
- outside main
** More on references
- Memory refences live by scope (function, block?)
  -  A function cannot return a reference that it created
- While you own *String*, you can't pass around ownership through &String
** Mutable references
- * ~dereferencing~ ("I dont't want the value...I want the value behind")
- &mut instead of &
  - defined both on referee and reference
- many immutable references allowed
  1    mutable reference allowed
- Cannot interwine mutable and immutable reference usages
#+begin_src rust
fn main() {
    let mut my_number = 8;
    let num_ref = &mut my_number; // is a mutable reference to an TYPE
    *num_ref += 10;
}
#+end_src
*** Shadowing Again
** Giving references to functions
- ~A value can only have one owner~
- Without passing a reference to a function, we pass the ownership along the value.
  - We don't get that back
  - Once we lost the ownership we can't use it or pass it back
  - If the new owner dies (exits) the data is *destroyed*
- A mutable reference, can be modified ofc
- A mutable value    , takes the ownership AND can modify it
** Copy types
- integers, floats, booleans and char
  - always passed a copy to a function (no ownership)
  - stack allocated
- String implements the trait ~Clone~
  - .clone()
  - effectively creates a copy of the String
  - using &String is preffered
- un-initialized variables
  - when we assign it on a sub block of code
** Collection Types
| Type   | init                     | signature   | access | size    | Types     |
|--------+--------------------------+-------------+--------+---------+-----------|
| array  | [1,2] ["A";10]           | [TYPE;SIZE] | a[0]   | fixed   | uniform   |
| vector | Vec::new() .push()       | Vec<TYPE>   | v[0]   | dynamic | uniform   |
|        | Vec<String> = Vec::new() |             |        |         |           |
|        | vec![1,2]                |             |        |         |           |
|        | Vec<_> = [1,2].into()    |             |        |         |           |
| tuples |                          | (T1, T2)    | t.0    | fixed?  | different |
- tuple, an empty one is () and means nothing
       , is used for ~destructuring
- vectors have a ~capacity~, automatically doubled when needed
  - let mut avector = Vec::with_capacity(100)
- array/vector slicing &a[1..2]
               has exclusive index slicing
** DONE Control flow
- both must return the same type
- if
  else if
  else
- match
  - mandatory to cover all, "else" with _
  - each line is called *arm*
    - => separate match and action
    - ,  comma between each line
    - ;  semicolon after the braces to return a value
  - support for guards (if)
  - support tuples, creating it on the argument or on the matches
  - @ can be used to name the match
** DONE Structs
#+begin_src rust
struct AUnit;         // "unit struct"
struct ATuple(i8,i8); // "tuple struct" or "unnamed struct"
struct ANamed {       // "named struct"
    size: u32,
    color: ATuple,
} // DO NOT add a semicolon after, "there is whole block of code after it"
#+end_src
** Enums
- let a = ThingsInsky::Sun; // Assign a *variant*
- each member gets a number from 0 to 10
  - can be given different numbers
#+begin_src rust
enum ThingsInSky {
    Sun,
    Stars,
}
enum ThingsInSky {
    Sun = 10,
    Stars = 100,
}
#+end_src
- can add content to each
#+begin_src rust
enum ThingsInSky {
    Sun(String),
    Stars(String),
}
let b = ThingsInSky::Stars("I can see the Sky");
#+end_src
- can destructure (on a match), the content of the enum
- can import (with ~use ENUMNAME::*~) the enum
  (in a function) to avoid writing the ENUMNAME
- each member can have different types
  - can be (mis?)used to return different types, while being that enum
** DONE Loops
- loop {break}
  loop {break RETURNVALUE;}
  'named_loop: loop {break 'named_loop}
- while 1==1 {}
- for n in 1..3 {}
** DONE Implementing (on) structs and enums
- impl
- #[] are attributes
- Methods
  - Regular: take &self(or &mut self), use .methoname() to call them
  - Associated/Static: do NOT take &self, use ::methodname() to cal them
- ~Self~ and ~self~ can be replaced with the literal StructName
   fn new() -> Self
   fn new() -> Animal
   fn change(&mut self)
   fn change(&mut Animal)
   fn change(&self)
   fn change(&Animal)
   #+begin_src rust
   #[derive(Debug)]
   struct Animal {
       age: u8,
       animal_type: AnimalType,
   }
   #[derive(Debug)]
   enum AnimalType {
       Cat,
       Dog,
   }
   impl Animal {
      new() -> Self {
          Self {
            age: 10,
            animal_type: AnimalType::Cat,
          }
      }
   }
   #+end_src
** DONE Destructuring
- a Struct can be destructure on a let
** DONE References and the dot operator
- ~*~ dereferencing happens automatically with the ~.~ operator in struct fields
  - from &i32 to i32
** DONE Generics
- We can make a function to take any type. Usually name T.
  #+begin_src rust
  fn afunction<T>(name: T) -> T {
     T
  }
  #+end_src
- We can also ensure certain traits on it.
  #+begin_src rust
  use std::fmt::Debug;
  fn afunction<T: Debug>(name: T) -> T {
     T
  }
  #+end_src
- We can have multiple types for multiple arguments, with different traits
   #+begin_src rust
   use std::fmt::Display;
   use std::cmp::PartialOrd;
   fn afunction<T: Display, U: Display + PartialOrd>(name: T, num_1: U) -> T {
      T
   }
   // Alternative format
   fn afunction<T,U>(name: T, num_1: U)
   where
       T: Display,
       U: Display + PartialOrd,
   {
       println!("WHAAAT")
   }
   #+end_src
** DONE Option and Result
- Make rust code safer
- ~Panic~ means that the program stopped before a problem happened.
  And the stack has been unwinded.
- ~.unwrap()~  if there is Some/Ok
  - None/Err CANNOT be
- ~if let~ do something if matches
  ~while let~ loop while it matches
*** Option<T>
- Internal shape of Option
  #+begin_src rust
  enum Option<T> {
     None,
     Some(T),
  }
  #+end_src
- can use match to destructure with Some(_)
- .is_some()
  .is_none()
*** Result<T,E>
#+begin_src rust
enum Result<T, E> {
    Ok(T),
    Err(E),
}
#+end_src
- .is_ok()
  .is_err()
** DONE Other Collections
   https://doc.rust-lang.org/beta/std/collections/
- all under
  use std::collections::
*** HashMap<T,T> (and BTreeMap)
- .entry() returns an *enum* called *Entry*
#+begin_src rust
enum Entry<K,V> {
    Occupied(OccupiedEntry<K,V>),
    Vacant(VacantEntry<K,V>),
}
#+end_src
- .or_insert(VALUE) inserts it if the Entry is Vacant,
   otherwise returns a *mut* of the entry
*** HashSet
- A HashMap with ONLY keys
- Used to check the existence of a key on a group.
*** BinaryHeap<T>
- .pop()
- A mostly unsorted collection where the front always has the bigger value
  - works with tuples
- Use case: priority queue
*** VecDeque
- A vector that is fast/good for removing things from both sides
- .pop_front() .pop_back()
  .push_front()
** DONE The ? Operator
- Unwraps if Ok otherwise, returns Error and ends (function)
- panic!()
  assert!()
  assert_eq!()
  assert_ne!()
- ~.expect()~ instead of using a lot of .unwrap() to explain the error
- ~.unwrap_or()~ to provide a default when a normal unwrap fails
** DONE Traits
- Traits about what a struct *can do*
- Once defined a *trait* you can *impl* for a type
  - On the *impl* you can redefine the default implementation
    - You cannot redefine with a new signature
- use std::fmt;
  impl fmt::Display for T {...}
- ~Trait bounds~, where neither the trait or the impl have method
  instead traits are used as *restrictions* for regular functions
- ~From<T>~
  - use std::convert::From
  - impl From<T> for S {
      fn from (a: T) -> Self {
         Self { a }
      }
    }
- ~AsRef~
  - We can use the trait Asref<str> + Display to accept both &str and String on a function
** DONE Chaining methods
- aka functional style
- let new_vec = (1..=10).collect::<Vec<i32>>()
  OR
  let new_vec: Vec<i32> = (1..=10).collect()
- .into_iter()
  .skip()
  .take()
  .collect()
** DONE Iterators
- .iter()      - iterator of references
  .iter_mut()  - iterator of mutable references (a for loop for example)
  .into_iter() - iterator of values (not references) as a result it destroys the values (ownage)
- .map()     - iters over each element and pass it on
  .for_each()- iters over each element
- An iterator in the backend are calling .next()
    which gives an Option.
- ~Associated Type~ means "a type that goes together"
    they might be required to define for impl (?)
  #+begin_src rust
  // Item is the Assoc. Type
  impl Iterator for T {
    type Item = S;
    fn next(&mut self) -> Option<i32> {
    }
  }
   #+end_src
** DONE Closures
- aka lambdas
- no argument:   || println!("This is a closure");
  typed arg:     |x: i32| println!("{}", x);
  multiple line: || {}
  unused arg:    |_| println!("I dont use the argument")
- normal call: my_closure();
- *closures* vs *anonymous functions*: wheter ~||~ encloses external vars or not
  the later gets compiled to the same of a regular function
- Take a closure: .unwrap_or_else() .map() .for_each()
*** Iterators
- Iterators are ~lazy~, you have to collect() them to process them
  #+begin_src rust
  num_vec         //                Vec<i32>
    .iter()       //               Iter<i32>
    .enumerate()  //     Enumerate<Iter<i32>>
    .map()        // Map<Enumerate<Iter<i32>>>
  #+end_src
- There are times where the type of collect is not needed so these are the same:
  .collect::<HashMap<i32, &str>>();
  .collect::<HashMap<_, _>>();
  .collect();
- .enumerate(), vec![10,20,30] -> (0,10),(1,20),(2,30)
  .char_indices(), for strings
  .match_indices(), for strings, but finds the provided substring
                    ex: find number of spaces .collect().len()
- .filter()    , takes a closure returns a boolean
  .filter_map(), takes a closure must return an Option
- .ok()    - Result<> into Option<>
  .parse::<T>().ok()
- .ok_or() - Option<> into Result<>
  .ok_or_else()
- .and_then()  - Option<> into Option<>, like a "safe" unwrap
- .and()       - A boolean for Option<>
- .any() all() - Take a boolean closure
- .rev()       - to reverse an *iterator*
- .find()      - return an Option<>
  .position()
- .cycle()     - makes an infinite iterator
- .skip()
  .take()
- .fold()
- .chars()     - makes an iterator from a string
- .take_while()
  .skip_while()
  .map_while()
- .cloned()  - Reference into a Value
  .by_ref()  - Makes and iterator take a reference
- .sum()
- .chunks()  - Consume by chunks
  .windows() - Slide by window
- .peekable() makes an iterator able to use .peek(),
              moving forward with .next()
** DONE The dbg! macro and .inspect
- dbg!() can print variables OR expressions
- .inspect() is like map (!?)
** DONE Types of &str
- Literals: they last the whole program, are ~&'static str~
- Borrowed: a String being referenced (&)
** DONE Lifetimes
- Can be provided on a struct or a field, as a requirement
  struct Name<'a> {
    name: &'a str,
  }
- &'static - if lives for the whole program
  &'a      - if lives as long as
  &'_      - anonymous lifetime, used by impl <'_>
             to indicate that a reference is being used
- avoid lifetimes by staying with "owned types", "cloning"m
- avoid &str in favor or String on structs
** DONE Interior Mutability
|                    | Define     | New               | Set                          |
|--------------------+------------+-------------------+------------------------------|
| std::cell::Cell    | Cell<T>    | Cell::new(VAL)    | .set(VAL)                    |
| std::cell::RefCell | RefCell<T> | RefCell::new(VAL) | .replace(VAL)                |
|                    |            |                   | .replace_with(CLOSURE)       |
| std::sync::Mutex   |            | Mutex::new(VAL)   | *mutex.lock().unwrap() = VAL |
| std::sync::RwLock  |            | RwLock::new(VAL)  | .write().unwrap();           |
|                    |            |                   | *writer = VAL;               |
*** RefCell
- .borrow()
  .borrow_mut()
- Checks borrows at *runtime* not compilation time
- Borrowing:
  1) Many borrows are fine
  2) 1 Mutable borrows is fine
  3) mutable AND immutable are not fine
*** Mutex (Mutual Exclusion)
- .try_lock()
- chan = mutex.lock().unwrap();
  *chan = VAL;
- Locks lasts until the scope is finished
- Unlock manually
  std::mem::drop(mutex_changer)
*** RwLock
- .try_read() .try_write()
- Unlock with std::mem::drop
- Adquires writers/readers same as RefCell
- .read().unwrap()
  let mut writer = .write().unwrap(); *writer = VAL; drop(writer);
** Cow (Clone On Write)
** DONE Type Aliases
- It does NOT create a new type.
  #+begin_src rust
  type CharacterVec = Vec<char>;
  use std::iter::{Take, Skip};
  use std::slice::Iter;
  type SkipFourTakeFive<'a> = Take<Skip<Iter<'a, char>>>
  #+end_src
- If you want the type to be *seen* by the compiler...
  An accepted hack is wrap it on a struct.
- Can use *as* to alias an import
** DONE The todo! macro
- same as ~unimplemented!()~
- Put it inside some function implementation, to silence compiler
** Rc (Reference Counter)
- Reminder: a variable can only have ONE owner
- With *Rc*, a variable can have >1 owner
  - When you CANNOT .clone() it
** DONE Multiple threads
- std::thread::spawn()
  - returns a JoinHandle
  - we can .join() the handle to have the program wait for the thread
- Closure types, takes
  - FnOnce: the whole values
    FnMut: a mutable reference
    Fn: a regualar reference
- Values from outside the thread into the tread need to use
  *move* on the closure to take ownership
** TODO Closures in functions
- A closure is a generic because every time it is a different type
** impl Trait
** Arc
** Channels
** Reading Rust documentation
** Attributes
** DONE Box
- Box<T>, wraps a type
- Box::new(), creates the Box<T> instance
- AKA ~smart pointer~
  - Can use * operator with Box, just like with an &
  - Stored on the *heap* instead of the *stack*
- Has not Copy, you need to .clone() it
- Can be used to create *recursive structs* not allowed by default
** DONE Box around traits
- Box can be used to return Traits from functions
  Otherwise the compiler won't allow return something of size unknown.
  JustATrait
  to
  Box<dyn JustATrait>
- Seen often as
  Box<dyn Error>
- Creating an Error
#+begin_src rust
use std::error::Error;
use std::fmt;

#[derive(Debug)]
struct ErrorOne
impl Error for ErrorOne{} // ONE
impl fmt::Display for ErrorOne { // TWO
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "You got the first error!")
    }
}
fn returns_errors(input: u8) -> Result<String, Box<dyn Error>> {
    Err(Box::new(ErrorOne))
}
#+end_src
** DONE Default and the builder pattern
- impl Default for T {
     fn default() -> Self
  }
- let char = T::default();
- The so called *builder pattern* comes into picture with methods that take ownership
  impl Character {
      fn name(mut self, name: &str) -> Self {
          self.name = name.to_string();
          self
      }
  }
  Which can be called like
  let char = T::default().name("WILLY");
- Sanity validations can happen on a method, that is called last on the creation.
  By creating a boolean field on the struct and
    - TRUE on new() and build()
    - FALSE on any other builder method
  fn build(mut self) -> Result<Character, String>
** Deref and DerefMut
** DONE Crates and modules
- crate>mod
  std::collections::HashMap
       ^ module

- *fn* inside a *mod* are ~private~ by default
  - they can't be imported/use either
  - *pub* on fn, struct (on each item), enum, trait, mod

- Create module
  #+begin_src rust
  mod print_things {
    use std::fmt::Display;
    fn prints_one_thing<T: Display>(input: T) {
      println!("{}", input)
    }
  }
  #+end_src
- You can nest *mod* (a child mod), can *use* anything from the parent mod
  - When we are inside a module we can use *super* to bring in items from above.
** Testing
** DONE External Crates
- Cargo.toml on root dir
  - code into src/main.rs by default
  - cargo run
- *rand* to generate random numbers,
  within a range with .gen_range()
  use rand::{thread_rng, Rng}
- *rayon* (like cl-parallel),
  it provides parallel alternatives to .iter() methods, like:
  .par_iter()
  .par_iter_mut()
  .par_into_iter()
  .par_chars()
  use rayon::prelude::*;
- *serde*, to convert from/to JSON/YAML
  add Serialize and Deserialize traits to a struct #[]
  Then you can call methods to serialize the struct.
- *regex*
- *chrono* functions for time outside stdlib
** A Tour of the Standard Library
** Writing Macros
** DONE cargo
- cargo>crate
- cargo build/run/check/new/clean
- --release
  longer to compile
  runs faster
- generics take longer to compile, because it needs
  to figure them out, and make it concrete.
** DONE Taking user input
- use std::io
  io::stdin().read_line(&mut something).unwrap()
- .trim()
  .clear()
- std::env::args()
  can be turned into_iter() or just *for*
- std::env::vars()
  for environment variables
  - These do the same
    option_env!()
    env!()
** TODO Using Files
- ? needs to be used on a function that returns Result
- main can return result
  - Ok(())                   // on last time
  - Result<(),ParseIntError> // return value for main()
- special Result for files
  std::io::Result
  which is
  type Result<T> = Result<T,Error>
- std::fs // Where all the functions for files are at
  std::io::Write
- fs::File::create("myfile.txt")?
      .write_all(b"These are bytes written to the file")?
  - same functionality of
  std::fs::write
- std::fs::File::open()
  .read_to_string()
** cargo doc
** The end?
* Tutorial: Rust In Action
** DONE 1 Introducing Rust
- Not all security bugs can be solved
  - Hearthbleed: buffer reutilization bug
  - goto fail: extra goto, variable initialized with success
- println!() exists as a macro since it does a bunch of type detection
- Integer overflow checks on debug mode
** DONE 2 Language Foundations
- Words: lifetime elision, hygienic macros, algebraic datatypes
- ->, "dagger" or "thin arrow"
- {:b} 0b11 {:x} 0xff {:o} 0o11
- floats have special values for:
  infinity
  negative infinity
  not a number
- fn add<T: Add<Output = T>>(i: T, j: T)
  - Type T should have the *trait* Add and the Output should be of type T
- ~lifetime elision~, happens when we explicitly provide the lifetime of some variables
  - The use of references is neccesary when using lifetimes, as lifetimes are not required for normal arguments
- u8.saturating_sub() is substraction that returns 0 on integer underflow
- String.lines()
        .contains()
        .truncate(0) // shrink back to 0
- cargo doc
  generates html documentation for all crates used by this project
- rustup doc
  opens local stdlib html doc
- *clap* crate for command line arguments
- .lines() iterator for files
- io::stdin()
  io::stdin().lock()
*** String vs str
  - str is not copied
    - Usually seen as &str, aka string slice
  - String is an owned type
*** Array, fixed size
  - Type: [T; 3]
  - Taking an reference of an Array, returns a slice (support iteration without .iter())
  - Stack allocated
*** Slices
  - Dynamic size: not specified at compile time
  - Type: [T]
  - Both slices and references to slices are called slices
  - Easier to implement Traits than Arrays
  - Made from two u8, an pointer and a length
*** Vector, dynamic size
  - Type: Vec<T>
  - Vec::with_capacity(N) size allocation hint
** 3 Compound Data Types
* Learn
- https://github.com/sger/RustBooks
- https://github.com/mre/idiomatic-rust
- https://rams3s.github.io/rust-ebookshelf/
- https://github.com/ctjhoa/rust-learning
- examples https://github.com/rust-lang/rust-by-example
           https://doc.rust-lang.org/stable/rust-by-example/
- examples https://github.com/rust-lang-nursery/rust-cookbook
** Medium
- https://doc.rust-lang.org/nightly/nomicon/
- https://rust-unofficial.github.io/too-many-lists/
- https://os.phil-opp.com/
- https://github.com/dtolnay/proc-macro-workshop
** Algorithms
- Common data structures and algorithms in Rust
  https://github.com/EbTech/rust-algorithms
- Small exercises to get you used to reading and writing Rust code!
  https://github.com/rust-lang/rustlings
- Implementing Rosetta Code problems in Rust.
  https://github.com/rust-rosetta/rust-rosetta
* youtube
- Jon Gjengset https://www.youtube.com/channel/UC_iD0xppBwwsrM9DegC5cQQ/
- Crazcalm's Tech Stack https://www.youtube.com/channel/UCfgXeSss8LaDtlK0ohwUX_w
