- https://github.com/sagiegurari/cargo-make
- https://github.com/burtonageo/cargo-bundle
- https://github.com/glium/glium
- https://github.com/not-fl3/macroquad
- Ultimate Rust 2: Intermediate Concepts
  https://github.com/CleanCut/ultimate_rust2
- PNGme: An Intermediate Rust Project
  https://picklenerd.github.io/pngme_book/
- open source training *courses* about distributed database and distributed systemes
  https://github.com/pingcap/talent-plan
- "RustBelt: Logical Foundations for the Future of Safe Systems Programming".
  https://plv.mpi-sws.org/rustbelt/
- Developers Reveal Why Rust Programming Language Is Losing Popularity
  https://fossbytes.com/developers-reveal-why-rust-programming-language-is-losing-popularity/
- An interpreter for Rust's mid-level intermediate representation
  https://github.com/rust-lang/miri
- https://users.rust-lang.org/t/rust-cves-should-i-worry/59904/7
- https://blog.akquinet.de/2021/01/03/haskell-is-faster-than-rust-wait-a-sec/
- https://www.fpcomplete.com/blog/philosophies-rust-haskell/
- http://technosophos.com/2019/08/07/writing-a-kubernetes-controller-in-rust.html
- https://github.com/unknownue/vulkan-tutorial-rust
- https://hackernoon.com/programming-in-rust-the-good-the-bad-the-ugly-d06f8d8b7738
- Type on destructuring = instead of :
- https://github.com/bevyengine/bevy
- tut dns server https://github.com/EmilHernvall/dnsguide
- Implementing TCP in Rust (part 1) https://www.youtube.com/watch?v=bzja9fQWzdA
- 4k demo https://github.com/janiorca/sphere_dance
  https://www.codeslow.com/2020/07/writing-winning-4k-intro-in-rust.html
  https://www.youtube.com/watch?v=SIkkYRQ07tU
- https://research.mozilla.org/rust/
* Video: Build a cryptocurrency! - Blockchain in Rust #01: Blocks & Hashing
  https://www.youtube.com/watch?v=vJdT05zl6jk
#+begin_src rust
use supper:**; // import all files on project
pub struct Block {
  pub field1: u32,
}
[u8; 16]
[0; 16]
#+end_src
- Create      [u8; 16]
  Instantiate [0; 16]
- use supper:**;
* Video: 12 Things to Help You Learn Rust
  https://www.youtube.com/watch?v=a8abW3RlOn8
- println!
  - basic:      {}
  - alias(?:    {valx}
  - debug:      {:?}
  - positional: {0}
- ALL variables are immutable by default
- HOWEVER, shadowing of variables with the same name is possible with immutable vars
* Video: Considering Rust - Jon Gjengset
  https://www.youtube.com/watch?v=DnT-LUQgc7s
- Generics
  #+begin_src rust
  struct MyVect<T> {
  }
  impl<T> MyVect<T> {
    pub fn find<P>(&self, predicate: P) -> Option<&T>
     where P: Fn(&T) -> bool
    {
      for v in self {
        if predicate(v) {
          return Some(v);
        }
      }
      None
    }
  }
  #+end_src
- Algebraic data types: A type that contains other types
- Zero-cost abstraction
- ? "try operator" a error match, catch error
- FREE ffi calls, given there is no interpreter that needs to be noticed of an external call
- unsafe{} free compiler checks
- bindgen - generates rust code from C header
  cbindgen - generates a header file that you can use from other languages
- tools that work with rust: perf, gdb/lldb, valgrind, llvm sanitizers
* Video: Rust 101 - 2017 - E. Dunham
  https://www.youtube.com/watch?v=FMqydRampuo
- "Go is a SysAdmins programming language, Rust is language for system level programming."
- Compiler can output:
  - LLVM IR
  - ASM
- Macro syntax
  - "shorthand for funftions with variable number of arguments." ???????
  - end with "!", ex: println!
- Rust team compiles all public projects (?) and PR breaking changes on code in Stable to those projects.
* Video: Why would a python programmer learn rust when there are no jobs in it - 2019
  https://www.youtube.com/watch?v=IYLf8lUqR40
- C++ has no stable ABI
- Enumerated types can contain variables
- Structures+Traits VS Objects
- No exceptions
- Does NOT support inheritance
- Use the *has a* not the *is a* model
- OO - Binding a method to a structure
  #+begin_src rust
  struct Point {
    x: f64,
    y: f64,
  }
  // A freestanding function - Borrowed point to a string
  fn point_to_string(point: &Point) -> String { ... }
  // an "inherent impl"
  impl Point {
    // automatically borrows the Point
    fn to_string(&self) -> String { ... }
  }
  #+end_src
- OO - Traits: A common method to multiple types
  #+begin_src rust
  trait Hash {
    fn hash(&self) -> u64;
  }
  impl Hash for bool {
    fn hash(&self) -> u64 {
      if *self { 0 } else { 1 }
    }
  }
  impl Hash for i64 {
    fn hash(&self) -> u64 {
      *self as u64
    }
  }
  #+end_src
* Video: All about rust - 2019 - Microsoft Developer
  https://www.youtube.com/watch?v=FYGS2q1bljE
- "Cost on the compiler"
- linkerd "proxy" is written in Rust, the rest (cli, webservice) in Go
- Libraries:
  - Tokio: async run-time (similar to getty in Go)
  - Hyper: http library that uses Tokio
  - Tower: service framework
- Microsoft IOT does some rust: https://github.com/Azure/iotedge/
* Video: Rust Programming Techniques
  https://www.youtube.com/watch?v=vqavdUGKeb4
  Year: 2018
  By: Nicholas Cameron
- A rust a reference is a pointer, but references can never be NULL
- *match* the compiler checks that the matching type gets ~exhausted~
- *if let* on the other hand does ~non-exhaustive~ pattern matching
- A macro can hide a return

* Tutorial: EasyRust
  https://github.com/Dhghomon/easy_rust

|                | UpperCamelCase | snake_case |   |   |
|----------------+----------------+------------+---+---|
| Implementation | YES            |            |   |   |
| Struct         | YES            |            |   |   |
| Enum           | YES            |            |   |   |
| Variables      |                | YES        |   |   |
| Functions      |                | YES        |   |   |


|         | Create         | Access    | Match        | Insert            |
|---------+----------------+-----------+--------------+-------------------|
| Tuple   |                | .0        | (a,_b)       |                   |
| struct  |                | .FIELD    |              |                   |
| enum    |                |           | ENUM::Val(a) |                   |
| HashMap | HashMap::new() | .get(key) | (key,val)    | .insert(key, val) |
| Vector  | vec![]         |           |              |                   |
| Array   | []             |           |              |                   |
** Comments
#+begin_src rust
// Comment
/* Comment */
let some_number  /*: i16*/ = 100;
#+end_src
** Types
*** Primitive types
- ~usize~, ~isize~, are architecture dependant i32 or i64
  - usize is used for indexing
- ~as~ used for casting
  - can be used twice
  - *casting* is like "pretend" a value is a type
- ~char~
  - use single quotes for char
  - 4 bytes
  - some characters are 1,2,3 or 4 bytes long
  - .len() gives the size in bytes
  - .chars().count()
** Type inference
#+begin_src rust
let a = 100_000; // default to i32
let b = 5.;      // default to f64 ... but depending of context used it might choose f32...
let c: u8 = 1;
let d = 1u8;     // uses type u8
#+end_src
*** Floats
- Can't add f32 and f64 directly
- Defaults to f64
- Rust compiler miiiight infer to use f32n
** Printing 'hello, world!'
- ~macros~ have a ~!~ after them
- return and ~;~
  #+begin_src rust
  fn beta() -> i32 {
    8 // without a ; it can be used like this, otherwise it would return ()
    // return 8;  // Same but less idiomatic
    // 8;         // It will return ()
  }
  #+end_src
- ~->~ is called *skinny arrow*, shows the return type of a function
- {} *code blocks* can be def anywhere, and return values from it
** Display and debug
- {} and ~pretty printers~ {:?} {:#?}
- std::i8::MIN, std::i8::MAX
** Mutability
- let mut x = 10; - ~mutability~, when a variable can be changed
- let x = 2;      - ~shadowing~, if are the same type, although effectively are different variables
  let x = 10;
** The Stack, Head and Pointers
|       | Speed   | Size at compilation |
|-------+---------+---------------------|
| Stack | Fastest | yes                 |
| Heap  | Fast    | no                  |
- let x: isize = 3;
  let b = &x; // b is a ~reference~ to x, b ~borrows~ x
              // b has type &isize
** More about printing
- r#""raw"\tlines\n"#
- b"this string of ASCII bytes"
- \u{D589} - unicode printing
- {:p}           - pointer
  {:b} {:x} {:o} - binary, hexa, and octal
  {0} {1}        - order of arguments
  {foo} {bar}    - name of arguments
- {variable:padding alignment minimum.maximum}
  - no spaced ({:0^10})
  - can ommit variable name
  - alignment <>^ (left/right/middle)
** Strings
- Types of string
| type   | initialization                 | ownership | alloc? | speed   |
|--------+--------------------------------+-----------+--------+---------|
| &str   | let a = "hello";               | borrowed  | data?  | fastest |
| String | let a = String::from("hello"); | owned     | heap   | fast    |
- std::mem::size_of::<String>() = 24bytes
  std::mem::size_of::<i8>()     =  1bytes
  std::mem::size_of_val("abc")  =  3bytes
- ~format!()~ -- like print! but returns the value instead
** const and static
#+begin_src rust
const NUMBER_OF_MONTHS: u32 = 12;
static SEASONS: [&str; 4] = ["Spr", "Su", "F", "Win"];
#+end_src
- ~const~ , doesn't change
  ~static~, doesn't change, fixed memory location
- people use const more often
- CAPITALIZED
- outside main
** More on references
- Memory refences live by scope (function, block?)
  -  A function cannot return a reference that it created
- While you own *String*, you can't pass around ownership through &String
** Mutable references
- * ~dereferencing~ ("I dont't want the value...I want the value behind")
- &mut instead of &
  - defined both on referee and reference
- many immutable references allowed
  1    mutable reference allowed
- Cannot interwine mutable and immutable reference usages
#+begin_src rust
fn main() {
    let mut my_number = 8;
    let num_ref = &mut my_number; // is a mutable reference to an TYPE
    *num_ref += 10;
}
#+end_src
*** Shadowing Again
** Giving references to functions
- ~A value can only have one owner~
- Without passing a reference to a function, we pass the ownership along the value.
  - We don't get that back
  - Once we lost the ownership we can't use it or pass it back
  - If the new owner dies (exits) the data is *destroyed*
- A mutable reference, can be modified ofc
- A mutable value    , takes the ownership AND can modify it
** Copy types
- integers, floats, booleans and char
  - always passed a copy to a function (no ownership)
  - stack allocated
- String implements the trait ~Clone~
  - .clone()
  - effectively creates a copy of the String
  - using &String is preffered
- un-initialized variables
  - when we assign it on a sub block of code
** Collection Types
| Type   | init                     | signature   | access | size    | Types     |
|--------+--------------------------+-------------+--------+---------+-----------|
| array  | [1,2] ["A";10]           | [TYPE;SIZE] | a[0]   | fixed   | uniform   |
| vector | Vec::new() .push()       | Vec<TYPE>   | v[0]   | dynamic | uniform   |
|        | Vec<String> = Vec::new() |             |        |         |           |
|        | vec![1,2]                |             |        |         |           |
|        | Vec<_> = [1,2].into()    |             |        |         |           |
| tuples |                          | (T1, T2)    | t.0    | fixed?  | different |
- tuple, an empty one is () and means nothing
       , is used for ~destructuring
- vectors have a ~capacity~, automatically doubled when needed
  - let mut avector = Vec::with_capacity(100)
- array/vector slicing &a[1..2]
               has exclusive index slicing
** DONE Control flow
- both must return the same type
- if
  else if
  else
- match
  - mandatory to cover all, "else" with _
  - each line is called *arm*
    - => separate match and action
    - ,  comma between each line
    - ;  semicolon after the braces to return a value
  - support for guards (if)
  - support tuples, creating it on the argument or on the matches
  - @ can be used to name the match
** DONE Structs
#+begin_src rust
struct AUnit;         // "unit struct"
struct ATuple(i8,i8); // "tuple struct" or "unnamed struct"
struct ANamed {       // "named struct"
    size: u32,
    color: ATuple,
} // DO NOT add a semicolon after, "there is whole block of code after it"
#+end_src
** Enums
- let a = ThingsInsky::Sun; // Assign a *variant*
- each member gets a number from 0 to 10
  - can be given different numbers
#+begin_src rust
enum ThingsInSky {
    Sun,
    Stars,
}
enum ThingsInSky {
    Sun = 10,
    Stars = 100,
}
#+end_src
- can add content to each
#+begin_src rust
enum ThingsInSky {
    Sun(String),
    Stars(String),
}
let b = ThingsInSky::Stars("I can see the Sky");
#+end_src
- can destructure (on a match), the content of the enum
- can import (with ~use ENUMNAME::*~) the enum
  (in a function) to avoid writing the ENUMNAME
- each member can have different types
  - can be (mis?)used to return different types, while being that enum
** DONE Loops
- loop {break}
  loop {break RETURNVALUE;}
  'named_loop: loop {break 'named_loop}
- while 1==1 {}
- for n in 1..3 {}
** DONE Implementing (on) structs and enums
- impl
- #[] are attributes
- Methods
  - Regular: take &self(or &mut self), use .methoname() to call them
  - Associated/Static: do NOT take &self, use ::methodname() to cal them
- ~Self~ and ~self~ can be replaced with the literal StructName
   fn new() -> Self
   fn new() -> Animal
   fn change(&mut self)
   fn change(&mut Animal)
   fn change(&self)
   fn change(&Animal)
   #+begin_src rust
   #[derive(Debug)]
   struct Animal {
       age: u8,
       animal_type: AnimalType,
   }
   #[derive(Debug)]
   enum AnimalType {
       Cat,
       Dog,
   }
   impl Animal {
      new() -> Self {
          Self {
            age: 10,
            animal_type: AnimalType::Cat,
          }
      }
   }
   #+end_src
** DONE Destructuring
- a Struct can be destructure on a let
** DONE References and the dot operator
- ~*~ dereferencing happens automatically with the ~.~ operator in struct fields
  - from &i32 to i32
** DONE Generics
- We can make a function to take any type. Usually name T.
  #+begin_src rust
  fn afunction<T>(name: T) -> T {
     T
  }
  #+end_src
- We can also ensure certain traits on it.
  #+begin_src rust
  use std::fmt::Debug;
  fn afunction<T: Debug>(name: T) -> T {
     T
  }
  #+end_src
- We can have multiple types for multiple arguments, with different traits
   #+begin_src rust
   use std::fmt::Display;
   use std::cmp::PartialOrd;
   fn afunction<T: Display, U: Display + PartialOrd>(name: T, num_1: U) -> T {
      T
   }
   // Alternative format
   fn afunction<T,U>(name: T, num_1: U)
   where
       T: Display,
       U: Display + PartialOrd,
   {
       println!("WHAAAT")
   }
   #+end_src
** DONE Option and Result
- Make rust code safer
- ~Panic~ means that the program stopped before a problem happened.
  And the stack has been unwinded.
- ~.unwrap()~ returns the T of Some(T) or panics if None
- ~if let~ do something if matches
  ~while let~ loop while it matches
*** Option<T>
- Internal shape of Option
  #+begin_src rust
  enum Option<T> {
     None,
     Some(T),
  }
  #+end_src
- can use match to destructure with Some(_)
- .is_some()
  .is_none()
*** Result<T,E>
#+begin_src rust
enum Result<T, E> {
    Ok(T),
    Err(E),
}
#+end_src
- .is_ok(), Result<> to a bool
  .is_err()
** DONE Other Collections
   https://doc.rust-lang.org/beta/std/collections/
- all under
  use std::collections::
*** HashMap<T,T> (and BTreeMap)
- .entry() returns an *enum* called *Entry*
#+begin_src rust
enum Entry<K,V> {
    Occupied(OccupiedEntry<K,V>),
    Vacant(VacantEntry<K,V>),
}
#+end_src
- .or_insert(VALUE) inserts it if the Entry is Vacant,
   otherwise returns a *mut* of the entry
*** HashSet
- A HashMap with ONLY keys
- Used to check the existence of a key on a group.
*** BinaryHeap<T>
- .pop()
- A mostly unsorted collection where the front always has the bigger value
  - works with tuples
- Use case: priority queue
*** VecDeque
- A vector that is fast/good for removing things from both sides
- .pop_front() .pop_back()
  .push_front()
** DONE The ? Operator
- Unwraps if Ok otherwise, returns Error and ends (function)
- panic!()
  assert!()
  assert_eq!()
  assert_ne!()
- ~.expect()~ instead of using a lot of .unwrap() to explain the error
- ~.unwrap_or()~ to provide a default when a normal unwrap fails
** DONE Traits
- Traits about what a struct *can do*
- Once defined a *trait* you can *impl* for a type
  - On the *impl* you can redefine the default implementation
    - You cannot redefine with a new signature
- use std::fmt;
  impl fmt::Display for T {...}
- ~Trait bounds~, where neither the trait or the impl have method
  instead traits are used as *restrictions* for regular functions
- ~From<T>~
  - use std::convert::From
  - impl From<T> for S {
      fn from (a: T) -> Self {
         Self { a }
      }
    }
- ~AsRef~
  - We can use the trait Asref<str> + Display to accept both &str and String on a function
** DONE Chaining methods
- aka functional style
- let new_vec = (1..=10).collect::<Vec<i32>>()
  OR
  let new_vec: Vec<i32> = (1..=10).collect()
- .into_iter()
  .skip()
  .take()
  .collect()
** DONE Iterators
- .iter()      - iterator of references
  .iter_mut()  - iterator of mutable references (a for loop for example)
  .into_iter() - iterator of values (not references) as a result it destroys the values (ownage)
- .map()     - iters over each element and pass it on
  .for_each()- iters over each element
- An iterator in the backend are calling .next()
    which gives an Option.
- ~Associated Type~ means "a type that goes together"
    they might be required to define for impl (?)
  #+begin_src rust
  // Item is the Assoc. Type
  impl Iterator for T {
    type Item = S;
    fn next(&mut self) -> Option<i32> {
    }
  }
   #+end_src
** DONE Closures (and iterators)
- aka lambdas
- no argument:   ||       println!("This is a closure");
  typed arg:     |x: i32| println!("{}", x);
  unused arg:    |_|      println!("I dont use the argument")
  multiple line: ||       {}
- normal call: my_closure();
- *closures* vs *anonymous functions*: wheter ~||~ encloses external vars or not
  the later gets compiled to the same of a regular function
- Take a closure: .unwrap_or_else() .map() .for_each()
*** Iterators
- Iterators are ~lazy~, you have to collect() them to process them
  #+begin_src rust
  num_vec         //                Vec<i32>
    .iter()       //               Iter<i32>
    .enumerate()  //     Enumerate<Iter<i32>>
    .map()        // Map<Enumerate<Iter<i32>>>
  #+end_src
- There are times where *the type* of collect is NOT needed so these are the same:
  .collect::<HashMap<i32, &str>>();
  .collect::<HashMap<_, _>>();
  .collect();
|--------------------+----------------------------------------|
| .enumerate()       | vec![10,20,30] -> (0,10),(1,20),(2,30) |
| .char_indices()    | for strings                            |
| .match_indices()   | for strings, find substring            |
|--------------------+----------------------------------------|
| .filter()          | takes closure, returns bool            |
| .filter_map()      | takes closure, returns Option          |
|--------------------+----------------------------------------|
| .unwrap()          | Option<> to value if Some or panic!()  |
| .ok()              | Result<> into Option<>                 |
| .ok_or()           | Option<> into Result<>                 |
| .ok_or_else()      | Option<> into Result<>                 |
| .parse::<T>().ok() |                                        |
| .and_then()        | Option<> into Option<>, "safe" unwrap  |
| .and()             | ?????                                  |
| .any()             | Take a boolean closure                 |
| .all()             | Take a boolean closure                 |
|--------------------+----------------------------------------|
| .find()            | return and Option<>                    |
| .position()        | return and Option<>                    |
|--------------------+----------------------------------------|
| .rev()             | iterator inversed                      |
| .skip()            |                                        |
| .take()            |                                        |
|--------------------+----------------------------------------|
| .fold()            |                                        |
| .sum()             |                                        |
|--------------------+----------------------------------------|
| .cycle()           | makes and infinite iterator            |
| .chars()           | makes and iterator from a string       |
| .peekable()        | a .next() .peek() able iterator        |
|--------------------+----------------------------------------|
| .take_while()      |                                        |
| .skip_while()      |                                        |
| .map_whilte()      |                                        |
| .cloned()          | reference into value                   |
| .by_ref()          | reference into iterator                |
| .chunks()          |                                        |
| .windows()         |                                        |
** DONE The dbg! macro and .inspect
- dbg!() can print variables OR expressions
- .inspect() is like map (!?)
** DONE Types of &str
- Literals: they last the whole program, are ~&'static str~
- Borrowed: a String being referenced (&)
** DONE Lifetimes
- Can be provided on a struct or a field, as a requirement
  struct Name<'a> {
    name: &'a str,
  }
- &'static - if lives for the whole program
  &'a      - if lives as long as
  &'_      - anonymous lifetime, used by impl <'_>
             to indicate that a reference is being used
- avoid lifetimes by staying with "owned types", "cloning"m
- avoid &str in favor or String on structs
** DONE Interior Mutability
|                    | Define     | New               | Set                          |
|--------------------+------------+-------------------+------------------------------|
| std::cell::Cell    | Cell<T>    | Cell::new(VAL)    | .set(VAL)                    |
| std::cell::RefCell | RefCell<T> | RefCell::new(VAL) | .replace(VAL)                |
|                    |            |                   | .replace_with(CLOSURE)       |
| std::sync::Mutex   |            | Mutex::new(VAL)   | *mutex.lock().unwrap() = VAL |
| std::sync::RwLock  |            | RwLock::new(VAL)  | .write().unwrap();           |
|                    |            |                   | *writer = VAL;               |
*** RefCell
- .borrow()
  .borrow_mut()
- Checks borrows at *runtime* not compilation time
- Borrowing:
  1) Many borrows are fine
  2) 1 Mutable borrows is fine
  3) mutable AND immutable are not fine
*** Mutex (Mutual Exclusion)
- .try_lock()
- chan = mutex.lock().unwrap();
  *chan = VAL;
- Locks lasts until the scope is finished
- Unlock manually
  std::mem::drop(mutex_changer)
*** RwLock
- .try_read() .try_write()
- Unlock with std::mem::drop
- Adquires writers/readers same as RefCell
- .read().unwrap()
  let mut writer = .write().unwrap(); *writer = VAL; drop(writer);
** Cow (Clone On Write)
** DONE Type Aliases
- It does NOT create a new type.
  #+begin_src rust
  type CharacterVec = Vec<char>;
  use std::iter::{Take, Skip};
  use std::slice::Iter;
  type SkipFourTakeFive<'a> = Take<Skip<Iter<'a, char>>>
  #+end_src
- If you want the type to be *seen* by the compiler...
  An accepted hack is wrap it on a struct.
- Can use *as* to alias an import
** DONE The todo! macro
- same as ~unimplemented!()~
- Put it inside some function implementation, to silence compiler
** DONE Rc (Reference Counter)
use std::rc::Rc
Rc<T>
Rc::new(t)
Rc::clone(&t) or just t.clone()
Rc::strong_count(&t)
- Reminder: a variable can only have ONE owner
- With *Rc*, a variable can have more then 1(one) owner
- When you CANNOT .clone()
  - Too much data
  - Is inside a struct that can't be clone
- Weak references??!?!?!??!?!?! TODO
** DONE Multiple threads
- std::thread::spawn() -> JoinHandle<T>
  - we can .join() the JoinHandle to wait for the thread to finish
- Closures, by what type of argument they take...
  | FnOnce | the whole value     |
  | FnMut  | a mutable reference |
  | Fn     | a reference         |
- To use an external value in a closure, even by reference. We need to *move||* the closure.
  Since the variable can, for example die before the closure ends.
** DONE Closures in functions (...arguments)
- A closure is always a generic because every time it is a different type
  - We still need to define the "closure type" and what returns.
** DONE impl Trait
- Almost the same as *generics*
- Used in function arguments,
  Instead of:
    fn function<T: Display>(one: T)
  Is:
    fn function(T: impl std::fmt::Display)
- Or in return values, let us return closures (because their function signature are traits)
    fn function() -> impl FnMut(T1) -> T2
** DONE Arc (Atomic Reference Counter)
use std::sync::Arc
Arc<Mutex<T>>
Arc::new(Mutex::new(0))
Arc::clone()
- If you want a *Rc* for a thread, you need this
  - wrapping a *Mutex*
  - cloned
  - *move ||* it into the thread
- Tip: make a constructor
** DONE Channels
std::sync::mpsc || mpsc = Multiple Producer, Single Consumer
fn channel<T>() -> (Sender<T>, Receiver<T>)
.send(T) -> Result<(),SendError<i32>>
.recv()  -> Result<i32, RecvError>
.clone()
.try_recv()
- Can clone it and send/move it to other threads (like Arc)
** Reading Rust documentation
** DONE Attributes #[]
#[] is for the next line
#![] is for the whole file
#[allow(dead_code)]
#[allow(unused_variables)]
#[derive(Trait)]
#[cfg(test)]
#[cfg(target_os = "windows")]
#![no_std]
https://doc.rust-lang.org/reference/attributes.html
** DONE Box
- Box<T>, wraps a type
- Box::new(), creates the Box<T> instance
- AKA ~smart pointer~
  - Can use * operator with Box, just like with an &
  - *heap* stored, instead of the *stack*
- Has not Copy, you need to .clone() it
- Can be used to create *recursive structs* not allowed by default
** DONE Box around traits
- Box can be used to return Traits from functions
  Otherwise the compiler won't allow return something of size unknown.
  JustATrait
  to
  Box<dyn JustATrait>
- Seen often as
  Box<dyn Error>
- Creating an Error
#+begin_src rust
use std::error::Error;
use std::fmt;

#[derive(Debug)]
struct ErrorOne
impl Error for ErrorOne{} // ONE
impl fmt::Display for ErrorOne { // TWO
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "You got the first error!")
    }
}
fn returns_errors(input: u8) -> Result<String, Box<dyn Error>> {
    Err(Box::new(ErrorOne))
}
#+end_src
** DONE Default and the builder pattern
- impl Default for T {
     fn default() -> Self
  }
- let char = T::default();
- The so called *builder pattern* comes into picture with methods that take ownership
  impl Character {
      fn name(mut self, name: &str) -> Self {
          self.name = name.to_string();
          self
      }
  }
  Which can be called like
  let char = T::default().name("WILLY");
- Sanity validations can happen on a method, that is called last on the creation.
  By creating a boolean field on the struct and
    - TRUE on new() and build()
    - FALSE on any other builder method
  fn build(mut self) -> Result<Character, String>
** DONE Deref and DerefMut
- We can implement it for our struct, called "smart pointer"
  - In fact, only limit it to that use case
*** std::ops::Deref
Deref is a Trait that allows you to use *
 - implement deref()
   #+begin_src rust
   use std::ops::Deref;
   struct HoldsANumber(u8);
   impl Deref for HoldsANumber {
       type Target = u8;
       fn deref(&self) -> &Self::Target {
         &self.0
       }
   }
   #+end_src
 - We can also access the methods of:
   - the deferenced struct, without actually dereferencing
   - new methods you define for the struct
*** std::ops::DerefMut
DerefMut, allows to modify with *
  - requires to have implemented Deref
#+begin_src rust
impl DerefMut for HoldsANumber {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.0
    }
}
#+end_src
** DONE Crates and modules
- crate>mod
  std::collections::HashMap
       ^ module

- *fn* inside a *mod* are ~private~ by default
  - they can't be imported/use either
  - *pub* on fn, struct (on each item), enum, trait, mod

- Create module
  #+begin_src rust
  mod print_things {
    use std::fmt::Display;
    fn prints_one_thing<T: Display>(input: T) {
      println!("{}", input)
    }
  }
  #+end_src
- You can nest *mod* (a child mod), can *use* anything from the parent mod
  - When we are inside a module we can use *super* to bring in items from above.
** DONE Testing
- #[test] Anotate a function with this
  #[should_panic]
- assert_eq!()
- cargo test
- Usually on a separate module
  - under #[cfg(test)]
  - using super::* on the module
- test functions usually have a descriptive long names
- Writting "just enough" code for the tests to pass first is recommended
** DONE External Crates
- Cargo.toml on root dir
  - code into src/main.rs by default
  - cargo run
- *rand* to generate random numbers,
  within a range with .gen_range()
  use rand::{thread_rng, Rng}
- *rayon* (like cl-parallel),
  it provides parallel alternatives to .iter() methods, like:
  .par_iter()
  .par_iter_mut()
  .par_into_iter()
  .par_chars()
  use rayon::prelude::*;
- *serde*, to convert from/to JSON/YAML
  add Serialize and Deserialize traits to a struct #[]
  Then you can call methods to serialize the struct.
- *regex*
- *chrono* functions for time outside stdlib
** A Tour of the Standard Library
- Arrays:
  - don't have an iterator, but can be .iter() or borrowed (&)
  - Can be destructured
- Char
  - char::from(u8)
    char::try_from(u32)
- Integer
  - .checked_add() .checked_sub() .checked_mul() .checked_div()  
** Writing Macros
** DONE cargo
- cargo>crate
- cargo build/run/check/new/clean
- --release
  longer to compile
  runs faster
- generics take longer to compile, because it needs
  to figure them out, and make it concrete.
** DONE Taking user input
- use std::io
   bandcamp
io::stdin().read_line(&mut something).unwrap()
- .trim()
  .clear()
- std::env::args()
  can be turned into_iter() or just *for*
- std::env::vars()
  for environment variables
  - These do the same
    option_env!()
    env!()
** TODO Using Files
- ? needs to be used on a function that returns Result
- main can return result
  - Ok(())                   // on last time
  - Result<(),ParseIntError> // return value for main()
- special Result for files
  std::io::Result
  which is
  type Result<T> = Result<T,Error>
- std::fs // Where all the functions for files are at
  std::io::Write
- fs::File::create("myfile.txt")?
      .write_all(b"These are bytes written to the file")?
  - same functionality of
  std::fs::write
- std::fs::File::open()
  .read_to_string()
** cargo doc
** The end?
* Tutorial: Rust by Example
  https://doc.rust-lang.org/stable/rust-by-example/
** 8 Flow of Control
*** 8.5 Match
**** 8.5.1 Pointers/ref
- Dereferencing uses *
- Destructuring uses &, ref, and ref mut
#+begin_src rust
let reference = &4;
match reference {
  &val => println!("{:?}", val),
}
// Alternatively, you can dereference before matching
match *reference {
  val => println!("{:?}", val),
}
#+end_src
- ref modifies the assignment so that a reference is created for the element
#+begin_src rust
let ref _is_a_reference = 3;
match value {
  ref r => println!("{:?}", r),
}
match mut_value {
   ref mut m => {
     *m += 10; // gotta dereference before we can use it
     println!("{:?}", m);
   },
}
#+end_src
**** 8.5.2 Guards
    You must use the _ pattern at the end.
    As the compiler won't check aribitrary expressions for completeness.
**** 8.5.3 Binding @
     It can also be used with enum's like Option
     #+begin_src rust
fn age() -> u32 {
  15
}
fn main() {
  println!("Tell me what type of person you are");
  match age() {
    0 => println!("I haven't celebrated my birthday yet"),
    n @ 1 ..= 12 => println!("I'm a child of age {:?}", n),
    n @ 13 ..= 19 => println!("I'm a teen of age {:?}", n),
    n => println!("I'm an old person of age {:?}", n),
  }
}
}
#+end_src
*** 8.6 if let
    Also works with binding
    #+begin_src rust
    if let Foo::(value @ 100) = c {
      println!("c is one hundred");
    }
    #+end_src
    Also works with enums that don't implement PartialEq
    #+begin_src rust
    if let Foo::Bar == a {
      println!("a is foobar");
    }
    #+end_src
*** 8.7 while let
    Alternative to loop+match
    #+begin_src rust
    let mut optional = Some(0);
    while let Some(i) = optional {
      if i > 9 {
        println!("Greater than 9, quit!");
        optional = None;
      } else {
        println!("{}", i);
        optional = Some(i + 1);
      }
    }
    #+end_src
** 9 Functions
*** 9.1 Methods
   - Associated methods are called using ~::~ double colons
   - Methods are called using the ~.~ dot operator
   ~self~ is sugar for ~self: Self~
   ~&self~ is sugar for ~self: &Self~
   ~&mut self~ is sugar for ~self: &mut Self~
*** 9.2 Closures
    - I/O arguments type is infered, {} enclosure is optional
    - Capture the environment
      - (about ownership) They will do what the closure requires without anotation.
    - Can explicitly use ~move~ to take ownership of captured variables
      #+begin_src rust
      let haystack = vec![1, 2, 3];
      let contains = move |needle| haystack.contains(needle);
      println!("{}", contains(&1));
      println!("{}", contains(&4));
      #+end_src
    - They MUST be annotated when used as function arguments.
      Using generics and picking one of:
      * Fn     -     &T
      * FnMut  - &mut T
      * FnOnce -      T

** 10 Modules
*** 10.2 Structures
    - Can have Generic type fields
      #+begin_src rust
      mod my {
        pub struct OpenBox<T> {
          pub contents: T,
        }

        pub struct ClosedBox<T> {
          contents: T,
        }

        impl<T> ClosedBox<T> {
          pub fn new(contents: T) -> ClosedBox<T> {
            ClosedBox {
              contents: contents,
            }
          }
        }
      }
      #+end_src
* Book: Command-Line Rust (OReilly)
  source: https://github.com/kyclark/command-line-rust
** 1
   - cargo.toml, add test and benchark only dependencies
     [dev-dependencies]
     assert_cmd = "1"
   - .rs file in bin directory
     src/bin/true.rs
     cargo run --quiet --bin true
   - std::process::exit(1)
     std::process::abort()
* Book: Rust In Action (Manning)
** DONE 1 Introducing Rust
- Not all security bugs can be solved
  - Hearthbleed: buffer reutilization bug
  - goto fail: extra goto, variable initialized with success
- println!() exists as a macro since it does a bunch of type detection
- Integer overflow checks on debug mode
** DONE 2 Language Foundations
- Words: lifetime elision, hygienic macros, algebraic datatypes
  Crates: clap, for cli tools
- ->, "dagger" or "thin arrow"
- {:b} 0b11 {:x} 0xff {:o} 0o11
- floats have special values for:
  infinity
  negative infinity
  not a number
- fn add<T: Add<Output = T>>(i: T, j: T)
  - Type T should have the *trait* Add and the Output should be of type T
- ~lifetime elision~, happens when we explicitly provide the lifetime of some variables
  - The use of references is neccesary when using lifetimes, as lifetimes are not required for normal arguments
- u8.saturating_sub() is substraction that returns 0 on integer underflow
- String.lines()
        .contains()
        .truncate(0) // shrink back to 0
- cargo doc
  generates html documentation for all crates used by this project
- rustup doc
  opens local stdlib html doc
- .lines() iterator for files
- io::stdin()
  io::stdin().lock()
*** String vs str
  - str is not copied
    - Usually seen as &str, aka string slice
  - String is an owned type
*** Array, fixed size
  - Type: [T; 3]
  - Taking an reference of an Array, returns a slice (support iteration without .iter())
  - Stack allocated
*** Slices
  - Dynamic size: not specified at compile time
  - Type: [T]
  - Both slices and references to slices are called slices
  - Easier to implement Traits than Arrays
  - Made from two u8, an pointer and a length
*** Vector, dynamic size
  - Type: Vec<T>
  - Vec::with_capacity(N) size allocation hint

* Book: Rust Programming By Example (PACKT)
** 2 Starting with SDL
- You need to import a Trait to use his methods
- io::Result definition
  type Result<T> = Result<T, Error>;
- Ok(()) is the Rust equivalet to *void*
- Equivalent:
  - try!()
  - match of Ok() and Err()
  - ? operator
- collect() calls next()
** 3 Events and Basic Game Mechanisms
- Game:
  - Tetrimino: A tetris piece, all are 4 blocks
  - Grid: 16 height and 10 width
- match _ branch can use *unreachable!()* macro
- *static* variables, don't die when the scope dies
  - changing the value of it is an *unsafe{}* operation
- Tetramino: impl and traits
  #+begin_src rust
  struct Tetrimino {..}

  // trait, struct, impl..for
  trait TeGenerator {
    fn new() -> Tetrimino;
  }
  struct TeI;
  impl TeGenerator for TeI {
    fn new() -> Tetrimino {..}
  }

  // Random function
  fn create_random_tetrimino() -> Tetrimino {..}

  // Method
  impl Tetrimino {
    fn rotate(&mut self) {..}
  }
  #+end_src
- When you send a non-mutable reference over a vector
  Vec<T> is deferenced into a &[T]
- Tetris: impl and structs
  #+begin_src rust
  struct Tetris {..}
  impl Tetris {
    fn new() -> Tetris {..}
    fn check_lines(&mut self) {..}
    fn make_permanent(&mut self) {..}
  }
  #+end_src
- An example on *borrow* and *ownership*
  On: for line in self.game_map
  game_map is non-mutably borrowed by *for* and we cannot mutate it in the loop.
- ref sidetrack https://doc.rust-lang.org/rust-by-example/scope/borrow/ref.html
  - same on the left side of = as & on the right side
  - can be pared with *mut* to take mutable references *ref mut*
  - used on let or destruring
- Another example of *ownership*:
  if an element of a type(struct) is borrowed the parent is also borrowed
** Implementing the engine for the music player
- Trait bounds can be added to a type as well than as a generic param of a function
* Book: Practial Rust Projects (Apress)
** 5 Physical Computing in Rust
Crate: rust_gpiozero
*** Hardware
Raspberry Pi 3+
- /dev/gpiomem virtual memory mapping of pins
  You can call mmap() on that device you can map it to the designated virtual memory addresses
    ptr::write_volatile() or std::mem::transmute()
  You can also access it through /dev/mem (!) but that requires root
- /sys/class/gpio/* virtual fs mapping of pins
                 /export
                 /gpio2/direction
                 /gpio2/value
- Pins
  - Power supply (5v and 3V3)
  - GND
  - GPIO (on the BCM order) 3.3v
    - BCM: Broadcom SOC Channel, pinout order of the CPU
    - Some Configurable to work as PWM, SPI, I2C, Serial
- LED: Anode(+), Cathode(-)
*** rust_gpiozero
crate: rust_gpiozero (build on top of rppal crate)
- std::thread::sleep;
  std::time::Duration;  Duration::from_secs()
                                ::new(1,0)
  std::time::Instant;   Instant::now().elapsed()
**** Output
- let mut led LED::new(PIN);
          led.on();
             .off()
             .toggle()
             .blink(1.0,1.0)
             .wait()
  sleep(Duration::from_secs(1));
**** Input
- let mut button = Button::new(4) // pull-up
                // Button::new_with_pulldown(4)
          button.wait_for_press(TIMEOUT)
- By default input gpio voltage fluctuates between 0-3v
- Internal pull up/down resistors can be enabled
- Pull down resistor: default 0v
  Pull-up   resistor: default 3V3
- Input can be *debounced* by measuring how long has passed since the last click
  Instant::now().elapsed()
*** Cross-compile
- Install the rust target compiler:
  > rustup target add armv7-unkown-linux-gnueabihf
- install the gcc linker
  On debian is: gcc-5-multilib-arm-linux-gnuebihf
- Let cargo know the linker name
  On ~/.cargo/config
  #+begin_src
  [target.armv7-unknown-linux-gnueabihf]
  linker = "arm-linux-gnuebihf-gcc-5"
  #+end_src
- build against the target
  > cargo build --target=armv7-unknown-linux-gnuebihf
- execute
  On: target/armv7-unknown-linux-gnueabihf/debug/NAMEHERE

** 6 Artificial Intelligence and Machine Learning
Crate: rusty-machine (rulinalg)
- An example of AI can be an "expert system" when WE define all the rules.
    Like Prolog. But it cannot be called ML.
- Supervised vs Unsupervised learning (aka use of labeled vs unlabeled data)
  - Other: Reinforced Learning, Semi-supervised Learning
*** Unsupervised (K-Means)
**** K-Means
Used when categorization is needed aka *clustering*
Consists on keep updating nth "centroids" until they can't be moved
1) Randomly assign k points as the centroids
2) Assign each point to a nearest centroid
3) Update centroids, find the mean point of all points of the group
4) repeat 2 and 3 until 3 doesn't move the centroid (they *converge*)

**** K-Means++
Extra: https://www.youtube.com/watch?v=HatwtJSsj5Q
Randomly picking the initial centroids have issues:
- Too long to end the algorithm
- A poor result (aka local optimum)
Solved by picking far apart centrids.
1) Pick 1 random centroid
2) For each point, calculate the distance to his nearest centroid as D(x)
3) Pick a new centroid from all the other points, weighted random
   where the probability is D(x)^2
4) repeat 2 and 3 until we selected the amount of centroid we desire
Then, we will run K-Means

**** Generating (Fake) Data
Crates: rusty-machine, rand, rand_distr, csv
use rand::thread_rng                   function
use rand::distributions::Distribution  for using .sample()
use rand_distr::Normal                 ::new(floor, max)
- src/bin/some.rs
  > cargo run --bin some
let mut writer = csv::Writer::from_writer()
       writer.write_record()
             .serialize()
*** Supervised (Neural Network)
* Book: The Rust Programming Language (nostarch)
** 10 Generic Types, Traits, and lifetimes
impl Type
impl Trait for Type
*** Generics
Generics are abstract stand-ins for concrete types
- Generic arguments (trait restricted)
- Generics in struct/enums definitions
  #+begin_src rust
  struct Point<T> {
    x: T,
    y: T,
  }
  #+end_src
  - TIP: When you need a lot of generic types in your code,
         it could indicate that your code needs restructuring
         into smaller pieces.
- Generics in Method Definition (+struct)
  #+begin_src rust
  impl<T> Point<T> {
     fn x(&self) -> &T {
       &self.x
     }
  }
  #+end_src
Speed is guaranteed, as Rust compiler does "Monomorphization" of the code used
by generics to the concrete for the type.
*** Traits: Defining Shared Behavior
  #+begin_src rust
  pub trait Summary { // pub as it will be imported elsewhere
    fn summarize(&self) -> String;
  }
  #+end_src
- Similar to a feature often called *interfaces* in other languages.
  We can define a default implementation of the functions
  We can impl functions for a type with different trait requirements (on different impl blocks)
  We CANNOT implement external traits on external types (coherence property, aka orphan rule)
  We CANNOT call the default implementation if we override the default one
- Implementing for a Type
  #+begin_src rust
  impl Summary for Type {
    fn summarize(&self) -> String {
      format!("{}", self.fieldnamehere)
    }
  }
  impl Summary for OtherType {}; // If default implementation was provided
  impl<T: Display> ToString for T {..} // Conditionally create a trait
  #+end_src
- Traits as Parameters
  - Syntatic sugar way (allows for any type)
     #+begin_src rust
     pub fn notify(item: impl Summary) {
       println!("Breaking news! {}", item.summarize())
     }
     #+end_src
  - Using Trait Bounds (enforce type to be T)
    #+begin_src rust
    pub fn notify<T: Summary>(item: T) {
      println!("Breaking news! {}", item.summarize());
    }
    #+end_src
- Returning Types that implement a trait, ONLY if it is the same type
  #+begin_src rust
  fn returns_summarizable() -> impl Summary {
    Tweet { .. }
  }
  #+end_src

*** Lifetimes: Validating references with it
* Learn
- https://github.com/sger/RustBooks
- https://github.com/mre/idiomatic-rust
- https://rams3s.github.io/rust-ebookshelf/
- https://github.com/ctjhoa/rust-learning
- examples https://github.com/rust-lang/rust-by-example
           https://doc.rust-lang.org/stable/rust-by-example/
- examples https://github.com/rust-lang-nursery/rust-cookbook
** Medium
- https://doc.rust-lang.org/nightly/nomicon/
- https://rust-unofficial.github.io/too-many-lists/
- https://os.phil-opp.com/
- https://github.com/dtolnay/proc-macro-workshop
** Algorithms
- Common data structures and algorithms in Rust
  https://github.com/EbTech/rust-algorithms
- Small exercises to get you used to reading and writing Rust code!
  https://github.com/rust-lang/rustlings
- Implementing Rosetta Code problems in Rust.
  https://github.com/rust-rosetta/rust-rosetta
* youtube
- Jon Gjengset https://www.youtube.com/channel/UC_iD0xppBwwsrM9DegC5cQQ/
- Crazcalm's Tech Stack https://www.youtube.com/channel/UCfgXeSss8LaDtlK0ohwUX_w
