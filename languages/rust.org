- http://technosophos.com/2019/08/07/writing-a-kubernetes-controller-in-rust.html
- https://github.com/unknownue/vulkan-tutorial-rust
- https://hackernoon.com/programming-in-rust-the-good-the-bad-the-ugly-d06f8d8b7738
- Type on destructuring = instead of :

- https://github.com/bevyengine/bevy
- tut dns server https://github.com/EmilHernvall/dnsguide
- Implementing TCP in Rust (part 1) https://www.youtube.com/watch?v=bzja9fQWzdA
- 4k demo https://github.com/janiorca/sphere_dance
  https://www.codeslow.com/2020/07/writing-winning-4k-intro-in-rust.html
  https://www.youtube.com/watch?v=SIkkYRQ07tU
- https://research.mozilla.org/rust/
* Video: Build a cryptocurrency! - Blockchain in Rust #01: Blocks & Hashing
  https://www.youtube.com/watch?v=vJdT05zl6jk
#+begin_src rust
use supper:**; // import all files on project
pub struct Block {
  pub field1: u32,
}
[u8; 16]
[0; 16]
#+end_src
- Create      [u8; 16]
  Instantiate [0; 16]
- use supper:**;
* Video: 12 Things to Help You Learn Rust
  https://www.youtube.com/watch?v=a8abW3RlOn8
- println!
  - basic:      {}
  - alias(?:    {valx}
  - debug:      {:?}
  - positional: {0}
- ALL variables are immutable by default
- HOWEVER, shadowing of variables with the same name is possible with immutable vars
* Video: Considering Rust - Jon Gjengset
  https://www.youtube.com/watch?v=DnT-LUQgc7s
- Generics
  #+begin_src rust
  struct MyVect<T> {
  }
  impl<T> MyVect<T> {
    pub fn find<P>(&self, predicate: P) -> Option<&T>
     where P: Fn(&T) -> bool
    {
      for v in self {
        if predicate(v) {
          return Some(v);
        }
      }
      None
    }
  }
  #+end_src
- Algebraic data types: A type that contains other types
- Zero-cost abstraction
- ? "try operator" a error match, catch error
- FREE ffi calls, given there is no interpreter that needs to be noticed of an external call
- unsafe{} free compiler checks
- bindgen - generates rust code from C header
  cbindgen - generates a header file that you can use from other languages
- tools that work with rust: perf, gdb/lldb, valgrind, llvm sanitizers
* Video: Rust 101 - 2017 - E. Dunham
  https://www.youtube.com/watch?v=FMqydRampuo
- "Go is a SysAdmins programming language, Rust is language for system level programming."
- Compiler can output:
  - LLVM IR
  - ASM
- Macro syntax
  - "shorthand for funftions with variable number of arguments." ???????
  - end with "!", ex: println!
- Rust team compiles all public projects (?) and PR breaking changes on code in Stable to those projects.
* Video: Why would a python programmer learn rust when there are no jobs in it - 2019
  https://www.youtube.com/watch?v=IYLf8lUqR40
- C++ has no stable ABI
- Enumerated types can contain variables
- Structures+Traits VS Objects
- No exceptions
- Does NOT support inheritance
- Use the *has a* not the *is a* model
- OO - Binding a method to a structure
  #+begin_src rust
  struct Point {
    x: f64,
    y: f64,
  }
  // A freestanding function - Borrowed point to a string
  fn point_to_string(point: &Point) -> String { ... }
  // an "inherent impl"
  impl Point {
    // automatically borrows the Point
    fn to_string(&self) -> String { ... }
  }
  #+end_src
- OO - Traits: A common method to multiple types
  #+begin_src rust
  trait Hash {
    fn hash(&self) -> u64;
  }
  impl Hash for bool {
    fn hash(&self) -> u64 {
      if *self { 0 } else { 1 }
    }
  }
  impl Hash for i64 {
    fn hash(&self) -> u64 {
      *self as u64
    }
  }
  #+end_src
* Video: All about rust - 2019 - Microsoft Developer
  https://www.youtube.com/watch?v=FYGS2q1bljE
- "Cost on the compiler"
- linkerd "proxy" is written in Rust, the rest (cli, webservice) in Go
- Libraries:
  - Tokio: async run-time (similar to getty in Go)
  - Hyper: http library that uses Tokio
  - Tower: service framework
- Microsoft IOT does some rust: https://github.com/Azure/iotedge/
* Tutorial: EasyRust
  https://github.com/Dhghomon/easy_rust
** Comments
#+begin_src rust
// Comment
/* Comment */
let some_number  /*: i16*/ = 100;
#+end_src
** Types
*** Primitive types
- ~usize~, ~isize~, are architecture dependant i32 or i64
  - usize is used for indexing
- ~as~ used for casting
  - can be used twice
  - *casting* is like "pretend" a value is a type
- ~char~
  - use single quotes for char
  - 4 bytes
  - some characters are 1,2,3 or 4 bytes long
  - .len() gives the size in bytes
  - .chars().count()
** Type inference
#+begin_src rust
let a = 100_000; // default to i32
let b = 5.;      // default to f64 ... but depending of context used it might choose f32...
let c: u8 = 1;
let d = 1u8;     // uses type u8
#+end_src
*** Floats
- Can't add f32 and f64 directly
- Defaults to f64
- Rust compiler miiiight infer to use f32
** Printing 'hello, world!'
- ~macros~ have a ~!~ after them
- return and ~;~
  #+begin_src rust
  fn beta() -> i32 {
    8 // without a ; it can be used like this, otherwise it would return ()
    // return 8;  // Same but less idiomatic
    // 8;         // It will return ()
  }
  #+end_src
- ~->~ is called *skinny arrow*, shows the return type of a function
- {} *code blocks* can be def anywhere, and return values from it
** Display and debug
- {} and ~pretty printers~ {:?} {:#?}
- std::i8::MIN, std::i8::MAX
** Mutability
- let mut x = 10; - ~mutability~, when a variable can be changed
- let x = 2;      - ~shadowing~, if are the same type, although effectively are different variables
  let x = 10;
** The Stack, Head and Pointers
|       | Speed   | Size at compilation |
|-------+---------+---------------------|
| Stack | Fastest | yes                 |
| Heap  | Fast    | no                  |
- let x: isize = 3;
  let b = &x; // b is a ~reference~ to x, b ~borrows~ x
              // b has type &isize
** More about printing
- r#""raw"\tlines\n"#
- b"this string of ASCII bytes"
- \u{D589} - unicode printing
- {:p}           - pointer
  {:b} {:x} {:o} - binary, hexa, and octal
  {0} {1}        - order of arguments
  {foo} {bar}    - name of arguments
- {variable:padding alignment minimum.maximum}
  - no spaced ({:0^10})
  - can ommit variable name
  - alignment <>^ (left/right/middle)
** Strings
- Types of string
| type   | ownership | alloc? | initialization                 | speed   |
|--------+-----------+--------+--------------------------------+---------|
| &str   | borrowed  | data?  | let a = "hello";               | fastest |
| String | owned     | heap   | let a = String::from("hello"); | fast    |
- std::mem::size_of::<String>() = 24bytes
  std::mem::size_of::<i8>()     =  1bytes
  std::mem::size_of_val("abc")  =  3bytes
- ~format!()~ -- like print! but returns the value instead
** const and static
#+begin_src rust
const NUMBER_OF_MONTHS: u32 = 12;
static SEASONS: [&str; 4] = ["Spr", "Su", "F", "Win"];
#+end_src
- ~const~ , doesn't change
  ~static~, doesn't change, fixed memory location
- people use const more often
- CAPITALIZED
- outside main
** More on references
- Memory refences live by scope (function, block?)
  -  A function cannot return a reference that it created
- While you own *String*, you can't pass around ownership through &String
** Mutable references
- * ~dereferencing~ ("I dont't want the value...I want the value behind")
- &mut instead of &
  - defined both on referee and reference
- many immutable references allowed
  1    mutable reference allowed
- Cannot interwine mutable and immutable reference usages
#+begin_src rust
fn main() {
    let mut my_number = 8;
    let num_ref = &mut my_number; // is a mutable reference to an TYPE
    *num_ref += 10;
}
#+end_src
*** Shadowing Again
** Giving references to functions
- ~A value can only have one owner~
- Without passing a reference to a function, we pass the ownership along the value.
  - We don't get that back
  - Once we lost the ownership we can't use it or pass it back
  - If the new owner dies (exits) the data is *destroyed*
- A mutable reference, can be modified ofc
- A mutable value    , takes the ownership AND can modify it
** Copy types
- integers, floats, booleans and char
  - always passed a copy to a function (no ownership)
  - stack allocated
- String implements the trait ~Clone~
  - .clone()
  - effectively creates a copy of the String
  - using &String is preffered
- un-initialized variables
  - when we assign it on a sub block of code
** Collection Types
| Type   | init                     | signature   | access | size    | Types     |
|--------+--------------------------+-------------+--------+---------+-----------|
| array  | [1,2] ["A";10]           | [TYPE;SIZE] | a[0]   | fixed   | uniform   |
| vector | Vec::new() .push()       | Vec<TYPE>   | v[0]   | dynamic | uniform   |
|        | Vec<String> = Vec::new() |             |        |         |           |
|        | vec![1,2]                |             |        |         |           |
|        | Vec<_> = [1,2].into()    |             |        |         |           |
| tuples |                          | (T1, T2)    | t.0    | fixed?  | different |
- tuple, an empty one is () and means nothing
       , is used for ~destructuring
- vectors have a ~capacity~, automatically doubled when needed
  - let mut avector = Vec::with_capacity(100)
- array/vector slicing &a[1..2]
               has exclusive index slicing
** Control flow
- if
  - must return the same type
- match
  - mandatory "else" with _
  - support for guards
  - support tuples, creating it on the argument or on the matches
  - must return the same type
  - @ can be used to name the match
** Structs
- creates a type
- UpperCamelCased
#+begin_src rust
struct AUnit;         // "unit struct"
struct ATuple(i8,i8); // "tuple struct" or "unnamed struct"
struct ANamed {       // "named struct"
    size: u32,
    color: ATuple,
} // DO NOT add a semicolon after, "there is whole block of code after it"
#+end_src
** Enums
- UpperCamelCase
- can destructure (on a match) the content of the enum, if any
- can import (with ~use ENUMNAME::*~) the enum, in a function, to avoid writing the enum name
- each member gets a number from 0 to 10
- each member can have different types
#+begin_src rust
enum ThingsInSky {
    Sun,
    Stars,
}
let a = ThingsInsky::Sun;

enum ThingsInSky {
    Sun(String),
    Stars(String),
}
let b = ThingsInSky::Stars("I can see the Sky");
#+end_src
** Loops
- loop {break}
  loop {break RETURNVALUE}
  'namedloop: loop {break 'namedloop}
- while 1==1 {}
- for n in 1..3 {}
** Implementing structs and enums
- Methods
  - Regular: take &self(or &mut self), use .methoname() to call them
  - Associated/Static: do NOT take &self, use ::methodname() to cal them
- ~Self~ and ~self~ can be replaced with the literal StructName
- derived ~attributes~
#+begin_src rust
#[derive(Debug)]
struct Animal {
    age: u8,
    animal_type: AnimalType,
}
#[derive(Debug)]
enum AnimalType {
    Cat,
    Dog,
}
#+end_src
** Destructuring
- a Struct can be destructure on a let
** References and the dot operator
- ~*~ dereferencing happens automatically with the ~.~ operator in struct fields
- just reference the whole struct instead of the single field
** Generics
- We can make a function to take any type. Usually name T.
#+begin_src rust
fn afunction<T>(name: T) -> T {
   T
}
#+end_src
- We can also ensure certain traits on it.
#+begin_src rust
use std::fmt::Debug;
fn afunction<T: Debug>(name: T) -> T {
   T
}
#+end_src
- We can have multiple types for multiple arguments, with different traits
#+begin_src rust
use std::fmt::Display;
use std::cmp::PartialOrd;
fn afunction<T: Display, U: Display + PartialOrd>(name: T, num_1: U) -> T {
   T
}
// Alternative format
fn afunction<T,U>(name: T, num_1: U)
where
    T: Display,
    U: Display + PartialOrd,
{
    println!("WHAAAT")
}
#+end_src
** Option and Result
- ~Panic~ means that the program stopped before a problem happened
*** Option
#+begin_src rust
enum Option<T> {
   None,
   Some(T),
}
#+end_src
- """type wrapper""" to get either ~Some()~ or ~None~ from a type
- Used when we might or might not return anything
- eg: i32 to Option<i32>
- if it is Some it can be .unwrap()
  - None can't be unwrapped
- .is_some() and .is_none()
*** Result
#+begin_src rust
enum Result<T, E> {
    Ok(T),
    Err(E),
}
#+end_src
- .is_ok() and .is_err()
** Other Collections
** The ? Operator
** Traits
** Chaining methods
** The dbg! macro and .inspect
** Types of &str
** Lifetimes
** RefCell
** Mutex
** RwLock
** Cow
** The todo! macro
** Rc
** Multiple threads
** Closures in functions
** impl Trait
** Arc
** Channels
** Attributes
** Box
** Box around traits
** Default and the builder pattern
** Deref and DerefMut
** Crates and modules
* Learn
- https://github.com/sger/RustBooks
- https://github.com/mre/idiomatic-rust
- https://rams3s.github.io/rust-ebookshelf/
- https://github.com/ctjhoa/rust-learning
- examples https://github.com/rust-lang/rust-by-example
           https://doc.rust-lang.org/stable/rust-by-example/
- examples https://github.com/rust-lang-nursery/rust-cookbook
** Medium
- https://doc.rust-lang.org/nightly/nomicon/
- https://rust-unofficial.github.io/too-many-lists/
- https://os.phil-opp.com/
- https://github.com/dtolnay/proc-macro-workshop
** Algorithms
- Common data structures and algorithms in Rust
  https://github.com/EbTech/rust-algorithms
- Small exercises to get you used to reading and writing Rust code!
  https://github.com/rust-lang/rustlings
- Implementing Rosetta Code problems in Rust.
  https://github.com/rust-rosetta/rust-rosetta
* youtube
- Jon Gjengset https://www.youtube.com/channel/UC_iD0xppBwwsrM9DegC5cQQ/
- Crazcalm's Tech Stack https://www.youtube.com/channel/UCfgXeSss8LaDtlK0ohwUX_w
