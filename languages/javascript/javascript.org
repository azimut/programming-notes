https://twitter.com/goncy/status/1396093019246546947?s=20
https://github.com/30-seconds/30-seconds-of-interviews
- https://www.youtube.com/c/Codexpanse/videos
- https://www.solidjs.com/
- JavaScript function hoisting by example
  https://gist.github.com/maxogden/4bed247d9852de93c94c
- Formatter
  https://standardjs.com/
- Style Guide
  https://github.com/airbnb/javascript
  https://github.com/ryanmcdermott/clean-code-javascript
- Algorithms and Patterns
  https://github.com/shichuan/javascript-patterns
  https://github.com/TheAlgorithms/Javascript
  https://github.com/trekhleb/javascript-algorithms
  https://github.com/humanwhocodes/computer-science-in-javascript
- Questions
  https://github.com/sudheerj/angular-interview-questions
  https://github.com/sudheerj/javascript-interview-questions
  https://github.com/lydiahallie/javascript-questions
- Libraries
  https://github.com/sorrycc/awesome-javascript
- browserify: https://github.com/browserify/browserify-handbook
- http://callbackhell.com/
  - name lambdas OR use separate functions
  - use modules
  - catch errors as the first argument
- https://frontendmasters.com/
- https://rallycoding.com/
- https://javascript30.com/
* typescript
- https://github.com/type-challenges/type-challenges
- Store
  https://github.com/goncy/pency/
* TODO Video: Arindam Paul - JavaScript VM internals, EventLoop, Async and ScopeChains
  https://www.youtube.com/watch?v=QyUFheng6J0
  - There are 2 phases
    - Compilation
    - Execution
  - First compilation phase, parses functions as lambda's without looking inside AND allocates variables declared.
  - Nth, compilation phase happens inside functions. Allocates variables declared (var) and arguments.
  - 10:15
* DONE Article: 2019 - Functional JavaScript: How to use array reduce for more than just numbers
  https://jrsinclair.com/articles/2019/functional-js-do-more-with-reduce/
  - The great power of .reduce() comes from the fact that:
      the *accumulator* and *accumulatorElement*, don't have to be the same type.
  - For example, the accumulator can be a string, and the array (fromt where the elements come) contain numbers:
    NOTE: the same can be achieved with .map() and .join()
    #+begin_src js
    function fizzBuzzReducer(acc, element) {
      if (element % 15 == 0) return `${acc}Fizz Buzz\n`;
      if (element %  5 == 0) return `${acc}Fizz\n`;
      if (element %  3 == 0) return `${acc}Buzz\n`;
      return `${acc}${element}\n`;
    }
    const nums = [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15];
    console.log(nums.reduce(fizzBuzzReducer, ''));
    #+end_src
  - Things that can be done with .reduce()
    1) Convert an array to an object
       #+begin_src js
       function keyByUsernameReducer(acc, person) {
         return {...acc, [person.username]: person};
       }
       console.log(peopleArr.reduce(keyByUsernameReducer, {}));
        #+end_src
    2) Unfold to a larger array:
       Can be handy if you are reading data from a text file
       #+begin_src js
       function splitLineReducer(acc, line) {
         return acc.concat(line.split(/,/g));
       }
       fileLines.reduce(splitLineReducer, []);
       #+end_src
       This could have been done with a *flatmap*, or you could build your own flatmap.
       #+begin_src js
       function flatMap(f, arr) {
         const reducer = (acc, item) => acc.concat(f(item));
         return arr.reduce(reducer, []);
       }
       flatMap(x => x.split(','), fileLines);
       #+end_src
    3) Make two calculations in one traversal:
       in this case is the same, but if we were combining a .map() and .filter() might be...
       #+begin_src js
       const readings = [0.3, 1.2, 3.4, 0.2, 3.2, 5.5, 0.4];
       function minMaxReducer(acc, reading) {
         return {
           minReading: Math.min(acc.minReading, reading);
           maxReading: Math.max(acc.maxReading, reading);
         };
       }
       cont initMinMax = {
         minReading: Number.MAX_VALUE,
         maxReading: Number.MIN_VALUE,
       };
       const minMax = readings.reduce(minMaxReducer, initMinMax);
       #+end_src
    4) Combine mapping and filtering into one pass
       For example, if holding several arrays in memory is too expensive.
       #+begin_src js
       function notEmptyEmail(x) {
         return (x.email != null) && (x.email !== undefined);
       }
       function greater(a, b) {
         return (a > b) ? a : b;
       }
       function notEmptyMostRecent(currentRecent, person) {
          return (notEmpty(person))
            ? greater(currentRecent, person.lastSeen)
            : currentRecent;
       }
       peopleArr.reduce(notEmptyMostRecent, '')
       #+end_src
    5) Run asynchronous functions in sequence
       aka run Promises in sequence
       - might be to avoid an API rate limit
       - or if one depends on the another

