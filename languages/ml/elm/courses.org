* DONE 16 | Elm Beyond the Basics
code https://github.com/knowthen/elm-beyond-basics
uses (20) library not supported by 0.19 https://package.elm-lang.org/packages/rluiten/elm-date-extra/latest
**  4 The Elm Architecture Example

- use this pattern when you are positive you needed

- we use Html.map to convert
  - from a Msg of a SubModule.Msg type
  - to another type of type Main.Msg

#+begin_src elm

type Msg
    = ChangePage Page
    | LeaderBoardMsg LeaderBoard.Msg
    | LoginMsg Login.Msg

view : Model -> Html Msg
view model =
    let
        page =
            case model.page of
                LeaderBoardPage ->
                    Html.map LeaderBoardMsg
                        (LeaderBoard.view model.leaderBoard)
                LoginPage ->
                    Html.map LoginMsg
                        (Login.view model.login)
    in
        div []
            [ div []
                  [ a [ href "#" , onClick (ChangePage LeaderBoardPage)]
                      [ text "LeaderBoard" ]
                  , span [] [ text " | " ]
                  , a [ href "#" , onClick (ChangePage LoginPage)]
                      [ text "LoginPage" ]
                  , hr [] []
                  , page
                  ]
            ]
#+end_src

**  6 Effects Example, Chuck Norris App

Http.getString someURL
getString : String -> Request String

Http.send Joke aRequest
send : (Result Error a -> msg) -> Request a -> Cmd msg

type Msg
  = Joke (Result Http.Error String)

**  7 JSON decoding

*** long way, using a decoder on a string with "at" and "decodeString"

#+begin_src elm
json : String
json = "{}"

decoder : Decoder String
decoder = Decoder.at ["value","joke"] Decoder.string

jokeResult : Result String String
jokeResult =
   decodeString decoder json

main : Html msg
main =
    case jokeResult of
        Ok joke ->
            text joke
        Err err ->
            text err
#+end_src

*** short way, using "at" and "Http.get"

#+begin_src elm
decoder : Decode String
decoder = Decoder.at ["value","joke"] Decoder.string

get : String -> Decoder a -> Request a

Http.send Joke <|
    Http.get someUrl decoder
#+end_src

*** decode a record

#+begin_src elm
type alias Response =
    { id: Int
    , joke: String
    , categories : List String
    }

respondeDecoder : Decoder Response
responseDecoder =
    Http.map3 Response
        (Http.field "id" int)
        (Http.field "joke" string)
        (Http.field "categories" (list string))
        |> at ["value"]

#+end_src

*** json-decode-pipeline - better when fields are unconsistent or want to hardcode a default value
  https://github.com/NoRedInk/elm-json-decode-pipeline

#+begin_src elm
responseDecoder : Decoder Response
responseDecoder =
    decode Response
        |> required "id" int
        |> required "joke" string
        |> optional "categories" (list string) []
        |> at ["value"]
#+end_src

**  8 Websockets time streaming example

~the *subscriptions* functions gets called everytime the update function is called~

Websocket.listen : String -> (String -> msg) -> Sub msg
Websocket.send : String -> String -> Cmd msg

type Msg = Echo String

subscriptions model =
    if model.streamTime then
        listen "ws://echo.websocket.org" Echo
    else
        Sub.none

send "ws://echo.websocket.org" "Hello!"

**  9 Navigation SPA Routing

- the Navigation package has a =program= function that can be used in place of *Html.program*
  first argument function is called everytime the Location changes
  program : (Location -> msg)
          -> {init : Location -> (model Cmd msg), update: msg -> (model, Cmd msg), view : model -> Html msg, subscriptions : }
          -> Program Never model msg

- =Location= is a record with many fields
  href,host, hostname, protocol, origin, port_, pathname, search, hash, username, password

#+begin_src elm
hashToPage : String -> Page
hashToPage hash =
    case hash of
        ""       -> LeaderBoard
        "#add"   -> AddRunner
        "#login" -> Login
        _        -> NotFound

locationToMsg : Location -> Msg
locationToMsg location =
    location.hash
        |> hashToPage
        |> ChangePage

pageToHash : Page -> String
pageToHash page =
    case page of
        LeaderBoard -> "#"
        AddRunner   -> "#add"
        Login       -> "#login"
        NotFound    -> "#notfound"

update : Msg -> Model -> (Model, Cmd Msg)
update msg model =
    case msg of
        Navigate page ->
            ( model, Navigation.newUrl <| pageToHash page )
        ChangePage page ->
            ( { model | page = page }, Cmd.none )

init : Location -> (Model, Cmd Msg)
init location =
    let page = hashToPage location.hash in
    ( initModel page, Cmd.none )
#+end_src

** 10 Ports Firebase Waiting List

*** From ELM to JS

port module Main Exposing (..)
port addCustomer : Customer -> Cmd msg
app.ports.addCustomer.subscribe(cus => {
});

*** From JS to ELM

port customerAdded : (String -> msg) -> Sub msg
subscriptions model =
    customerAdded CustomerAdded -- send a msg when JS sends something

app.ports.customerAdded.send( id );

*** Firebase

port addCustomer : String -> Cmd msg -- outbound
port customerSaved : (String -> msg) -> Sub msg -- inbound
port newCUstomer : (Customer -> msg) -> Sub msg -- inbound

app.ports.addCustomer.subscribe(customerName => {
    addCustomer({name: customerName})
      .then(response => {
        console.log("Saved!")
        app.ports.customerSaved.send(response.key);
      }, err => console.log("error:",err))
});
var listener = customerLIstener();
listener.on("child_added", data => {
  var customer = Object.assign({id: data.key}, data.val())
  app.ports.newCustomer.send(customer);
});

** 14 Setting up LoginAuthentication

https://jwt.io/

- JWT - JSON Web Token
  Encoded string includes 3 parts
  1) header: aka metadata algorithm and token type
  2) payload: key value pairs, aka one or more "claims"
     - exp: expiration time
     - iat: issued at claims
  3) signature: generated by the server, using the header+payload and a server side secret

- Sibling modules communication, is possible, but it's messy and should be avoided
  - keep common state and first direct ancestor

- it is very important to reinitialize the model, once we got a jwt token
  otherwise the user/pass could been reused if logoff but the page wasn't closed

- we update the return value of =update= to return the token
  update : Msg -> Model -> (Model, Cmd Msg, Maybe String)

** 15 Saving Retrieving Login Token JWT

- in localStorage through flags

** 16 Logging out

#+begin_src elm
  port deleteToken : () -> Cmd msg
#+end_src

#+begin_src javascript
  app.ports.deleteToken.subscribe(() => {
      localStorage.removeItem('token');
  })
#+end_src

** 17 Access Control Locking Pages

- To restrict acessing pages directly, we have to modify =update=

#+begin_src elm
authForPage : Page -> Bool -> Bool
authForPage page loggedIn =
    loggedIn || not (List.member page authPages)

authRedirect : Page -> Bool -> (Page, Cmd Msg)
authRedirect page loggedIn =
    if authForPage page loggedIn
    then ( page, Cmd.none )
    else ( LoginPage, Navigation.modifyUrl <| pageToHash LoginPage)

-- on init
let
    page = hashToPage location.hash
    (updatePage, cmd) = authRedirect page (flags.token /= Nothing)

-- on update
LogOut -> -- add a new Cmd to move the user to the login page?
    ( {}
    , Cmd.batch
        [ deleteToken ()
        , Navigation.modifyUrl <| pageToHash LeaderBoardPage ])

ChangePage -> -- to ensure we can access this page or not
    let
        ( updatePage, cmd ) =
            authRedirect page model.loggedIn
    in
        ({ model | page = updatedPage }, cmd)
#+end_src

** 18 Adding Runners Http Post

#+begin_src elm
runnerEncoder : Model -> JE.Value
runner { name, location, age, bib } =
    let
        ageInt = age |> String.toInt |> Result.withDefault 0
        bibInt = bib |> String.toInt |> Result.withDefault 0
    in
        JE.object
            [ ( "name", JE.string name )
            , ( "location", JE.string location )
            , ( "age", JE.int ageInt )
            , ( "bib", JE.int bibInt )
            ]

save : String -> Model -> (Model, CMd Msg)
save token model =
    let
        headers =
            [ Http.header "AUthorization" ("Bearer " ++ token) ]
        body =
            Http.jsonBody <| runnerEncoder model
        decoder =
            field "_id" JD.string
        request =
            post url headers body decoder
        cmd =
            Http.send SaveResponse request
    in
        ( model, cmd )

post : String -> List Http.Header -> Http.Body -> JD.Decoder a -> Http.Request a
post url headers body decoder =
    Http.request
        { method = "POST"
        , headers = headers
        , url = url
        , body = body
        , expect = HTtp.expectJson decoder
        , timeout = Nothing
        , withCredentials = False
        }
#+end_src

* DONE 18 | Introduction to Elm v2 | Richard Feldman
|----------------------+----------------------------------------------------------------------|
| same webapp,         | https://github.com/gothinkster/realworld                             |
| build with different | https://www.realworld.how/                                           |
|----------------------+----------------------------------------------------------------------|
| backend/frontends    | https://github.com/jeko2000/tiny-routes-realworld-example-app        |
| css in elm           | https://github.com/rtfeldman/elm-css                                 |
| example spa codebase | https://github.com/rtfeldman/elm-spa-example/                        |
| some JS library      | https://github.com/localForage/localForage                           |
| onInput              | https://www.w3schools.com/jsref/event_oninput.asp                    |
| unsound typescript   | https://www.typescriptlang.org/docs/handbook/type-compatibility.html |
|----------------------+----------------------------------------------------------------------|
** 01 Course Introduction

- Elm compiles to JS
  - Main.elm -> elm.js

- Elm does the same thing that Babel/TS does

- Cons
  - fewer web APIs have first-class support, there is a period of lag

- Benefits
  - small bundle size
  - less exceptions, "no runtime exceptions", not zero
  - cohesive ecosystem solution, provides a good integration of these things needed for a webapp
    |-----------+----------------+--------------------------------------------------------------|
    |           |            <r> |                                                              |
    |           |         in Elm | other technologies                                           |
    |-----------+----------------+--------------------------------------------------------------|
    | dialect   |            Elm | js, ts, babel, flow                                          |
    | ui        |           view | angular, react, vue, ember.js                                |
    | state     |          model | redux, mobx, relay, observables?                             |
    | async     |         update | redux sagas, redux thunks, redux promises, redux observables |
    | utilities | core libraries | lodash, jquery, immutable.js, rambda                         |
    | packages  |    elm install | npm, yarn, dependable types, flow types, es6 modules         |
    |-----------+----------------+--------------------------------------------------------------|

- Most of benefits come with applications that are big and serious and have to be maintained for a long time.

- import into index.html for incremental adoption
  #+begin_src html
    <head>
      <link rel="stylesheet" href="main.css" />
      <script src="elm.js"></script>
      <script>
        Elm.Main.init({
        node: document.getElementById("app")
        });
      </script>
    </head>
  #+end_src

** 02 Elm Introduction

- UI Example: a "leaf" search. The text should say
  - "Your search returned 2 leaves" OR
  - "Your search returned 1 leaf"

- in js
  #+begin_src javascript
    let pluralize =
        (singular, plural, quantity) => {
          if (quantity === 1) {
            return singular;
          } else {
            return plural;
          }
        };

    console.log(pluralize("leaf", "leaves", 1));
  #+end_src

- problem with this is that OLD browsers don't know about *let* or *arrow functions*
  so babel will compile it to
  #+begin_src javascript
    var pluralize =
        function pluralize(singular, plural, quantity) {
          if (quantity === 1) {
            return singular;
          } else {
            return plural;
          };
        };
  #+end_src

- in elm
  #+begin_src haskell
    pluralize singular plural quantity =
      if quantity == 1
      then singular
      else plural -- required else

    main =
      text (pluralize "leaf" "leaves" 1) -- instead of console.log()
  #+end_src

- in plain JS if you make a typo and do "return" of an undefined variable on an if,
  it will be a ~runtime exception~

- Elm uses a VirtualDOM (DOM = Document Object Model)

- The DOM has a concept of a *text* node https://developer.mozilla.org/en-US/docs/Web/API/Text
  which represents the inner text/content of a html tag

- In Elm, we could represent a DOM, with functions, where their
  1st argument is their attributes
  2nd argument is their children

- In Elm code, it looks like a DSL

  #+begin_src elm
    ul [ class "languages" ]
        [ li [] [ text "Elm" ]
        , li [] [ text "JS" ]
        ]
  #+end_src

** 03 Manipulating Values

- let, String.fromInt, (++), List.map, String.toUpper

#+begin_src haskell
List.map (\s -> String.toUpper str ++ "!") [ "pow", "zap" ]
List.map (pluralize "leaf" "leaves") [ 0, 1, 2 ] -- partially applied
#+end_src

- Elm lists compile to an immutable linked list, not a JS Array.

- Elm mostly targets/compiles mostly to ES3

- you can move code into a ./src/ directory

** 04 Interaction

- records
  - no prototypes
  - no *this*
  - no mutating

|---------+-------------+---------------|
|         | iteration   | mixed entries |
|---------+-------------+---------------|
| lists   | =supported= | unsupported   |
| records | unsupported | =supported=   |
|---------+-------------+---------------|

- Model is the application state, it's a record

- To send a Msg, specify it on a onClick handler on view

  #+begin_src elm
    view model =
        button
            [
             onClick -- just another attribute, like "class"
                 { description = "ClickedTag"
                 , data = "elm"
                 } -- it will send this Msg to update
            ]
            [ text "elm" ]
  #+end_src

*** Exercise: Main.elm

- $ elm install elm/browser

#+begin_src elm
module Main exposing (main)

import Article
import Browser
import Html exposing (..)
import Html.Attributes exposing (..)
import Html.Events exposing (onClick)

init =
    { tags        = Article.tags
    , selectedTag = "elm"
    , allArticles = Article.feed
    }

update msg model =
  if msg.description == "ClickedTag"
  then { model | selectedTag = msg.data }
  else model

main =
  Browser.sandbox { init = init, view = view, update = update }
#+end_src

*** Exercise: Main.elm - view

#+name: view
#+begin_src elm
view model =
  let
    articles =
      List.filter (\article -> List.member model.selectedTag article.tags)
        model.allArticles
    feed =
      List.map viewArticle articles
  in
  div [ class "home-page" ]
      [ viewBanner
      , div [ class "container page" ]
            [ div [ class "row" ]
                  [ div [ class "col-md-9" ] feed
                  , div [ class "col-md-3" ]
                        [ div [class "sidebar" ]
                              [ p [] [ text "Popular Tags" ]
                              , viewTags model
                              ]
                        ]
                  ]
            ]
      ]

viewArticle article =
  div [ class "article-preview" ]
      [ h1   [] [ text article.title ]
      , p    [] [ text article.description ]
      , span [] [ text "Read more..." ]
      ]

viewbanner =
  div [ class "banner" ]
      [ div [ class "container" ]
            [ h1 [ class "logo-font" ] [ text "conduit" ]
            , p [] [ text "A place to share your knowledge" ]
            ]
      ]

viewTag selectedTagName tagName =
  let
    otherClass =
      if tagName == selectedTagName
      then "tag-selected"
      else "tag-default"
  in
  button
    [ class ("tag-pill " ++ otherClass)
    , onClick { description = "ClickedTag", data = tagName }
    ]
    [ text tagName ]

viewTags model =
  div [] (List.map (viewTag model.selectedTag) model)
#+end_src

*** Exercise: Article.elm

#+begin_src elm
module Article exposing (feed, tags)

tags =
     [ "elm"
     , "fun"
     , "programming"
     , "dragons"
     ]

feed =
     [ { title = "Elm is fun!", description = "Elm", body = "I've really" }
     , { title = "Who says undefined isn't a function anyway", description = "", body = "" }
     , { title = "This compiler is pretty neat", description = "Elm", body = "" }
     , { title = "Are dragons real?", description = "dragons", body = "" }
     ]
#+end_src

** 05 Type Annotations      | (:) , records (type alias)

- ~Type Annotations~ are done, like in Haskell, but with (:) instead of (::)

 #+begin_src elm
username : String
username = "Adam"

names : List String -- "List" is a parametrized type
names = ["Sam", "Casey", "Pat"]

String.length : String -> Int -- function
searchResult : { name : String, stars : Int } -- record
  #+end_src

- alias
  #+begin_src elm
    type alias Article =
      { title : String
      , tags : List String
      , body : String
      }
    type alias Model =
      { selectedTag : String
      , articles : List Article
      }
    type alias Msg =
        { description : String
        , data : String
        }
  #+end_src

- If you see on a function signature with >1 consecutive types that are the same
  it might be a signal that is something that you might get confused to:
  - pass instead 1 record

** 06 Custom Types          | union types (type)

- =Redux= is based on the Elm architecture
- =React= attribute *onChange* is called like that due devs didn't like the name *onInput*

- enumeration aka sum types, ~union types~, ADTs, descriminated unions

  #+begin_src elm
    type Tab = -- a brand NEW type
      YourFeed | GlobalFed | TagFeed -- variants
      -- no "deriving", but they can be compared
  #+end_src

- containers, aka type constructors

  #+begin_src elm
    type Tab
        = YourFeed
        | GlobalFeed
        | TagFeed String -- container
  #+end_src

- It is more common to use an ~union type~ instead of a record for *Msg*

  #+begin_src elm
    type Msg
        = ClickedTag String
        | ClickedPage Int
  #+end_src

** 07 Maybe                 | (|>)

- Pipeline style

#+begin_src elm
[ 2, 4, 6 ]
  |> List.filter (< 5)
  |> List.reverse
  |> List.map negate
  |> List.head
#+end_src

** 08 Decoding JSON         | Decode.Json

- In JS you get a ~NaN~ (Not a Number) value on some operations
  - eg: parseInt()

- https://www.typescriptlang.org/docs/handbook/type-compatibility.html
  TypeScript’s type system allows certain operations that can’t be
  known at compile-time to be safe.

  (For example when decoding json we say that a field will be of a certain type, when in reality we can't possible know for sure)

  When a type system has this property, it is said to NOT be “sound”.

- Decoding

  - decodeString : ? -> String -> Result ??
  - decodeString Json.Decode.int "42"

  - Example: to decode actual jsons you need to declare a =Decoder= that specifies the schema
    #+begin_src elm
      type alias User =
          { id : Int
          , name : Maybe String -- could have "null"
          , email : String
          }

      user : Decoder User
      user =
          Json.Decode.succeed User
              |> required "user_id" int
              |> required "first_name" (nullable string)
              |> optional "email" string "me@foo.com"

      users : Decoder (List User)
      users = list user
    #+end_src

  - You might prefer, to have an intermediate record type alias
    that will be "pessimistic" in considering all fields "nullable"
    and then solve those.

** 09 Talking to Servers    | Cmd, Http
*** Elm functions

- are pure
- have no side-effects
- have ~managed effects~, any side-effect has to be done through commands
  - through "Cmd Msg" sent by *update*

*** HTTP

- GET - we need to get a Request and then convert it to a Cmd
  #+begin_src elm
    -- CompletedLoadFeed (Result Error String)
    Http.getString "/feed?tag=happiness" -- build a Request
         |> Http.send CompletedLoadFeed -- send Request and use custom Msg to receive response

    -- CompletedLoadFeed (Result Error (List Article))
    Http.get articlesDecoder url
  #+end_src

- POST
  #+begin_src elm
    let
        requestBody : Http.Body
        requestBody =
            encodeJsonBody model.form

        responseDecoder : Decoder Viewer
        responseDecoder =
            Decode.field "user" Viewer.decoder

        request : Http.Request Viewer
        request =
            Http.post "/api/users" requestBody responseDecoder

        cmd : Cmd Msg
        cmd =
            Http.send CompletedRegister request
    in
        ({ model | problems = [] }, cmd)
  #+end_src

** 10 Talking to Javascript | Sub, on, port

- ~on~ is the general, more flexible version of onClick/onInput/...
  the decoder argument, decodes an event object from JS
  you can use the same JSON decoder interface
  #+begin_src elm
    div [ on "mousemove" mousePointDecoder ] []
  #+end_src

- Subscriptions:
  - are another way to send messages from the *Elm Runtime* to *update*
  - are essentially event listeners, that are global.
    Eg: mouse move, based on a timer, or on a websocket.
  - It allows us to not flood *update* with Msg's we don't care about
    Sub.none
  - Example
    #+begin_src elm
      -- Sub stands for "subscription"
      Browser.onMouseMove : Decoder msg -> Sub msg
    #+end_src

- Guarantees
  - we keep our guarantees of purity and no side-effects
    while communicating with JS
    by using a client/server communication model, like with Cmd/Sub

- [] is an "List a", with an ~unbound~ type variable

#+begin_src elm
div [ onClick Toggle ] [] : Html Msg

-- doesn' do event handling
-- doesn't produce anything o user input
img [ src "logo.png" ] [] : Html msg
#+end_src

- Sending data to JS - "fire and forget"
  - *port* they keyword to talk to javascript
    Written before *module* and before any function signature we want Elm to generate for us.
    We don't write the definition of the function defined with it.
    Elm will write it for us.
    We only write the signature.
    #+begin_src elm
      -- Maybe because JS can receive a null
      port storeSession : Maybe String -> Cmd msg
    #+end_src

- Receiving data from JS
  Elm also writes the implementation for us.
  We get a String from Javascript, that we are going to convert to *msg*
  #+begin_src elm
    port onSessionChange : (String -> msg) -> Sub msg
  #+end_src

- It is really important design our app to have only
  1 *source of truth* for the data (aka 1 owner of the state)

*** Example: using JS library localForage

- source https://github.com/localForage/localForage

- general usage
  #+begin_src javascript
    localForage.getItem("key", function(val) {/*...*/});
    localForage.setItem("key", "val", function() {/*...*/});
  #+end_src

- index.html more detailed
  #+begin_src javascript
    localforage.getItem("session", function(err, session) {
      var app = Elm.Main.init({flags: session}); // initial session value
      app.ports.storedSession.subscribe(function(newSession) { // storedSession = name on Elm
        localforage.setItem("session", newSessin, function() {
          app.ports.onSessionChange.send(newSession); // onSessionChange = name on Elm
        });
      });
    });
  #+end_src

#+begin_src elm
port storeSession : Maybe String -> Cmd msg

sendSessionToJavascript : Maybe String -> Cmd msg
sendSessionToJavascript maybeAuthenticationToken =
    storeSession maybeAuthenticationToken
#+end_src

#+begin_src elm
port onSessionChange : (Value -> msg) Sub msg
-- value is a JSON value, a JS object
receiveSessionFromJavascript : (Value -> msg) -> Sub msg
receiveSessionFromJavascript toMsg =
    onSessionChange toMsg
#+end_src

** 11 Wrapping Up
* TODO 18 | Advanced Elm           | Richard Feldman

|------------------------------+----------------------------------------------------------------------------------|
| opaque data types            | https://en.wikipedia.org/wiki/Opaque_data_type                                   |
| extensible custom types      | https://allanderek.prose.sh/extensible-custom-types                              |
| extensible custom types WASM | https://dev.to/briancarroll/elm-in-wasm-custom-types-and-extensible-records-15m0 |
| mars climate orbiter bug     | https://en.wikipedia.org/wiki/Mars_Climate_Orbiter#Cause_of_failure              |
| library                      | https://github.com/tesk9/accessible-html                                         |
| talk                         | https://www.youtube.com/watch?v=tyFe9Pw6TVE                                      |
| talk                         | https://www.youtube.com/watch?v=XpDsk374LDE                                      |
|------------------------------+----------------------------------------------------------------------------------|

** 01 Overview

- Goals
  * manage ~external data~
  * ~reuse~ parts of an UI
  * rule out problems at ~compile time~
  * ~organize~ and scale Elm applications

** 02 Opaque Types (module exposing)

- it is common to just return, when we don't want to return anything on a case
  text ""

*** Module Boundaries / Opaque Types

- by using encapsulation to _enforce invariants_
  - aka _NOT exposing constructors_ of variants

- instead, you can export things that will keep the invariant
  #+begin_src elm
    module Email exposing (Email, fromString, toString)

    type Email =
        ValidEmail String

    fromString : String -> Result String Email
    toString : Email -> String
  #+end_src

- =Opaque Types=
  - means that other modules can't see what's inside the types by themselves
  - the _implementation details_ are hidden
  - eg: Decoder, Html, Random.Generator

- we can resort to defining a type, ~even when it doesn't have any data~
  just to enforce the invariant
  #+begin_src elm
    type Email = Email
  #+end_src


*** Example: Validated data (rtfeldman/elm-validate)

- Or this that the only way to *submitForm* is with a *Valid* type
  Which the only way to get it is with a call to *validate*
  Make the *invariant* enforceable by the types and the compiler

  #+begin_src elm
    submitForm : Valid Form -> Http.Request User
  #+end_src

- Snippet rtfeldman/elm-validate code

#+begin_src elm
module Validate exposing (Validator, Valid,...)

type Valid a = Valid a

fromValid
    : Valid a
    -> a

validate
    : Validator error subject
    -> subject
    -> Result (List error) (Valid subject)
#+end_src

*** Example: Credentials (elm-spa-example)

- if you have a *Cred* that means you are logged in.
- Since is the only way to expose a way to get those values.

    #+begin_src elm
module Credentials exposing (Cred, login)

type Cred = ...

login    : LoginInfo -> http.Request Cred     -- if I have a Cred, it means a user must have logged in
    #+end_src

- at the same time, you can build the rest of your code like this

#+begin_src elm
follow   :         Bool -> Author -> Html Msg -- without Cred, it wouldn't make sense to follow someone without being logged in

follow   : Cred -> Bool -> Author -> Html Msg -- Bool, could bring confusion later

follow   : Cred         -> Author -> Html Msg -- broke down into separate functions
unfollow : Cred         -> Author -> Html Msg
#+end_src


*** When NOT to go Opaque

Example:

- when I am rendering an author, there are 3 possible states
- The only way to render a follow button is to handle 3 states.
- By exposing the variants allows us to pattern match outside the module,
  while still keeping the invariant, since we need an opaque argument to construct one of those


  #+begin_src elm
module Author exposing
    ( Author(..) -- non-opaque, exposing all variants
    , FollowedAuthor -- has opaque argument, the only way to get one of them is by using follow/unfollow/requestFollow/requestUnfollow
    , UnfollowedAuthor -- has opaque argument, the only way to get one of them is by using follow/unfollow/requestFollow/requestUnfollow
    )
type Author
    = IsFollowing FollowedAuthor
    | IsNotFollowing UnfollowedAuthor
    | IsViewer Cred Profile -- non-opaque, currently logged user

type FollowedAuthor
    = FollowedAuthor Username Profile

type UnfollowedAuthor
    = UnfollowedAuthor Username Profile

follow : UnfollowedAuthor -> FollowedAuthor
follow (UnfollowedAuthor uname prof) =
    FollowedAuthor uname prof

unfollow : FollowedAuthor -> UnfollowedAuthor
unfolow (FollowedAuthor uname prof) =
    UnfollowedAuthor uname prof

requestFollow : UnfollowedAuthor -> Cred -> Http.Request Author
requestFollow (UnfollowedAuthor uname _) cred =
    requestHelp HttpBuilder.post uname cred

requestUnfollow : FollowedAuthor -> Cred -> http.Request Author
requestUnfollow (FollowedAuthor uname _) cred =
    requestHelp HttpBuilder.delete uname cred
  #+end_src


*** Exercise

#+begin_src elm
  -- from
  type alias Cred =
        { username : Username
        , token : String
        }
  -- to, we make it opaque, could have kept the record
  type Cred = Cred Username String
#+end_src

** 03 Extensible Data (open records)

*** Constraint Unification

- the process that the compiler uses to type check everything
  1) from known facts (eg: types of literals)
  2) inferred facts (eg: derived from ops on other known facts)
  3) finds contradictory facts (type missmatch)

- Elm special ~constraint type variables~, that have special constraints. Must begin with:
  * number
  * appendable
  * comparable

*** =Open= and =Closed= Record

 |--------+---------------------------------|
 |    <r> |                                 |
 | closed | type alias Model = { ... }      |
 |   open | type alias Model r = { r ¦ ...} |
 |--------+---------------------------------|

- Related to Constraint Unification
- You CANNOT create an open record

- The only ways to get an open record type are:
  1) a ".function"
     #+begin_src elm
       rec.username -- { r | username : a } -> a
     #+end_src
  2) modify a record
     #+begin_src elm
       (\record -> { record | name = "Li" })
       -- { r | name : String } -> { r | name : String }
     #+end_src

*** Why =Open Recods= exists?

1) type inference
   #+begin_src elm
getName : { a | name : String } -> String
getname record = record.name
   #+end_src

2) to write functions that take an ~open record~
   - which means it take ANY record that has:
   - email, firstName, and lastName

   #+begin_src elm
validate : { r | email : String, firstName : String, lastName : String } -> Blah
validate { email, firstName, lastName } = -- ...
   #+end_src

3) to model data
   - Example: a record representing an Article, that can take different shapes
     - it could have a body, like when reading it
     - or a don't have a body, on the homepage listing of articles

   #+begin_src elm
 -- with open records
 type alias Article a =
     { a | title : String
     , tags : List String
     }
 -- can later add instantiate the missing field,
 -- but is less recommended than in function inputs
 type alias Point a = { a | x : Int, y : Int }
 type alias Point3D = Point { z : Int }
 -- with a type parameter
 type alias Article a =
 { title : String
 , tags : List String
 , extraInfo : a -- !!
 }
  #+end_src

*** Extensible =Custom Types= (usecase of O.R.)

- There were talks of removing *Open Records*
  due their issues while compiling to WASM

- Using it as a Custom Type

  #+begin_src elm
type Preview = Preview -- no extraInfo
type Full = Full Body
type Article extraInfo =
    Article
        { title : String
        , tags  : List String
        }
        extraInfo

-- still can write function that access it
title : Article a -> String
body : Article Full -> Body -- or restrict it to Full

-- examples used on type signatures
Decoder (Article Preview)
Decoder (Article Full)
  #+end_src

** 04 Creating Constraints (phantom types, Never)

*** Units of Measure

Say we have units of measure
#+begin_src elm
  type Cm = Cm type In = In

  cm     : Float -> Length Cm
  inches : Float -> Length In
#+end_src

- Phantom Type:
  - we have a type variable, but we don't use it on the variant
  - we use it as a constraint on the type annotations
  - otherwise there is no constraint by default
  - trade-off on flexibility and performance

- We could define an add operation, without a phantom type
  #+begin_src elm
    type Length units
        = Length Float units

    add : Length units -> Length units -> Length units
    add (Length num1 units) (Length num2 units2) =
        Length (num1 + num2) units1
  #+end_src

- we could define an add operation, with a =phantom type=
  #+begin_src elm
    type Length units
        = Length Float

    add : Length units -> Length units -> Length units
    add (Length num1) (Length num2) =
        Length (num1 + num2)
  #+end_src

*** Type Parameter Design

- 3 different forms, to take a list of attributes

|------------------------+------------------------------------------|
| List (Attribute msg)   | accept any attribute                     |
| List (Attribute Msg)   | accept only Msg                          |
| List (Attribute Never) | accept only a list of unbound attributes |
|------------------------+------------------------------------------|

*** Accessible HTML

- =accessible-html= https://github.com/tesk9/accessible-html

- drop-in replacement library of native Html module

- provides more restricture function signatures,
  aiming to dissallow non-semantically correct code
  #+begin_src elm
-- Html
p : List (Attribute msg)   -> List (Html msg) -> Html msg
{- accessible-html, a concrete type that isn't Msg -}
p : List (Attribute Never) -> List (Html msg) -> Html msg
   #+end_src

- in order to avoid, code like this which uses Onclick
  #+begin_src elm
    -- Html Msg
    p [ onClick Something ] -- msg -> Attribute msg -- BOUND to the msg attribute it receives
      [ text "Hi" ]         -- Html msg
  #+end_src

- while still allowing this, due class returns UNBOUND attributes
  #+begin_src elm
    p [ class "neato" ] -- String -> Attribute msg -- msg is an UNBOUND type
      [ text "Hi" ]
  #+end_src

*** The =Never= Type

- Used when you want say "please provide me with something that is STILL unbound"

#+begin_src elm
  type Never = OneMore Never -- even in the module where is defined, you cannot make one
#+end_src

- Example:

  - tasks in Elm are the idea of chainable commands
  - perform some sort of effect
  - Task like Result have a /success type/ and a /fail type/
  #+begin_src elm
    Task.perform
        : (a -> msg)
        -> Task Never a -- a task not capable of producing errors
        -> Cmd msg
  #+end_src

- Example: getViewport

  - gets the current dimensions
  - it can never fail
  - but it can return different values, so is a Task
  #+begin_src elm
-- getViewPort : Task x Viewport -- error type unbound
type Msg = ViewportChanged Viewport
Task.perform ViewportChanged getViewport
  #+end_src

** 05 Scaling

- order of function arguments
  - think on how ~partial application~ would affect it
  - the most important argument first,
  - aka the less likely to change

- What fits in our heads

  - Split into modules

- Narrowing types, help on debugging

  - You focus your attention on functions that touch/modify the thing you have BUG with
  - If it is a an issue with the *Model*
    - can rule out view functions, if it an isue with data
  - If it is a particular part of the *Model*
    - can rule out functions that deal with unreleated part of it

- Enforcement arguments, adding arguments to show business dependencies logic

  #+begin_src elm
     type Author
         = IsFollowing FollowedAuthor
         | IsNotFollowing UnfollowedAuthor
         | IsViewer Cred Profile -- Cred is the enforcement

    followButton :
        (Cred -> UnfollowedAuthor -> msg)
        -> Cred
        -> UnfollowedAuthor
        -> Html msg
  #+end_src

- Using modules for modularity

  - The primary purpose of a module is to hide things, hide implementation details

  - Nobody else should be messing with the Model of a page,
    you should not be exposing it

  - dividing into smaler files without a clear objective
    leads to over-exposing things, just to have the other module to have access

** TODO 06 Reuse

- Helper functions
  - when things are quite similar with just a minor thing differing
  - example, updating a form on a model
    #+begin_src elm
      -- Enteredemail email ->
      --     updateform (\form -> {form | email = email}) model
      updateForm : (Form -> Form) -> Model -> (Model, Cmd Msg)
      updateForm transform model =
          ({ model | form = transform model.form }
          , Cmd.none)
    #+end_src

- Similar vs the same
- Html msg
- Html.map
- Cmd.map

** 07 Sources of Truth

*** Impossible States

1) agreement where some piece of data lives
   eg: some nested data that represents exactly the same that some other data nested elsewhere
   #+begin_src elm
     type alias Model =
         { selectedTag : String
         , theSelectedTag : String
         , ...
         }
   #+end_src

2) agreement where some piece of data lives
   a list of "tabs" records that have a bool field "active" true in multiple
   #+begin_src elm
     -- bad
     type alias Tab =
         { name : String
         , active : Bool
         }
     -- better
     type Tab
         = YourFeed
         | GlobalFeed
         | TagFeed Tag
   #+end_src

*** Derived Data

Database Timestamp
> ISO-8601 string
> Time.posix
> String
> Html msg

- Some derived data might be stored and need to be expired/revalidated
- Some others might just be "intermediate representations",
  and you should NOT store them, to avoid multiple sources of truth

*** Authentication

- caching authentication tokens
- in localstorage, where localstorage is the only source of truth

#+begin_src javascript
  var app = Elm.Main.init({
    flags: localStorage.session || null
  });

  app.ports.storeSession.subscribe(
    function(session) {
      localStorage.session = session;
      setTimeout(() => app.ports.onSessionChange.send(session), 0);
    }
  );

  // when a different tab modifies localstorage for the same domain (eg: logout)
  window.addEventListener(
    "storage",
    function(event) {
      if (event.storageArea === localStorage && event.key === "session") {
        app.ports.onSessionChange.send(event.newValue);
      }},
    false
  );
#+end_src

*** Javascript

- in practice, the source of truth should be kept on JS

** 08 Decoding

*** Pipeline types (map3, succeed)

#+begin_src elm
Decode.map3 Instructor
    (field "name" string)
    (field "courses" int)
    (field "active" bool) -- Decoder Instructor

-- Decode.succeed : a -> Decoder a
-- each "required" partially applies one argument
Decode.succeed Instructor
    |> required "name" string
    |> required "courses" int
    |> required "active" bool
#+end_src

*** Decode.andThen (map, andThen)

- with map we "stay on the happy path"
- with andThen we can potentially fail

#+begin_src elm
Decode.map     : (a -> b)         -> Decoder a -> Decoder b
Decode.andThen : (a -> Decoder b) -> Decoder a -> Decoder b
#+end_src

*** Decoderizing (string, andThen)

#+begin_src elm
iso8601Decoder : Decoder Time.Posix
iso8601Decoder =
    Decode.string
        |> Decode.andThen fromString

fromString : String -> Decoder Time.Posix
fromString str =
    case Iso8601.toTime str of
        Ok successValue ->
            succeed successValue
        Err _ ->
            fail ("Invalid date: " ++ str)
#+end_src

*** Intermediate representations

- Making a type opaque while still getting access to the fields on the file
- As types with only 1(one) variant, they will get "unboxed" by the compiler.

#+begin_src elm
type Comment
    = Comment Internals

type alias Internals =
    { id : CommentId
    , body : String
    , createdAt : Time.Posix
    , author : Author
    }
#+end_src

** TODO 09 SPAs
