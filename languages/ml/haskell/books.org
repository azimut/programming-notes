- https://kowainik.github.io/books/do-pure-haskell-interview
- Abstractions in Context lihttps://williamyaoh.gumroad.com/l/CLyzT
- Book:
  - https://atypeofprogramming.com/
  - https://x.com/atopbook
- Book: Retrocomputing with Clash: Haskell for FPGA Hardware Design
  https://unsafeperform.io/retroclash/
- https://lokathor.gitbooks.io/using-haskell/content/
- https://lotz84.github.io/haskellbyexample/
- https://leanpub.com/simple-haskell-book/read - build a CI
  official source https://github.com/alpacaaa/quad-ci
  unofficial source https://github.com/jturner/quad-ci
- https://leanpub.com/production-haskell/read
- https://leanpub.com/haskell-cookbook/read
- https://leanpub.com/haskell-stdlibs

* ?? | Learn You a Haskell
** DONE 10 Functionally Solving Problems
*** Reverse Polish Notation Calculator

- Alternatives to =read= that are more fault tolerant
  - Text.Read.readMaybe
  - reads, intended for ambiguous parses, a Maybe masquerading as a []

#+begin_src haskell
  solveRPN :: (Num a, Read a) => String -> a
  solveRPN = head . foldl foldingFunction [] . words
    where foldingFunction (x:y:ys) "*" = (x*y) : ys
          foldingFunction (x:y:ys) "+" = (x+y) : ys
          foldingFunction (x:y:ys) "-" = (y-x) : ys
          foldingFunction xs numberString = read numberString : xs
#+end_src

*** Heatrow to London

#+begin_src haskell
  data Node = Node Road Road | EndNode Road -- OR
  data Node = Node Road (Maybe Road)
  data Road = Road Int Node
#+end_src

Attempt 3: custom data type
- fits perfect with our problem description
- won't use a tuple because you can mixup elements

#+begin_src haskell
  data Section = Section { getA :: Int, getB :: Int, getC :: Int } deriving (Show)
  data RoadSystem = [Section]

  heathrowToLondon :: RoadSystem
  heathrowToLondon = [Section 50 10 30, Section 5 90 20, Section 40 2 25, Section 10 8 0]
#+end_src

Our solution, will take a *RoadSystem* and will generate a *Path* of the solution

#+begin_src haskell
  data Label = A | B | C deriving (Show)
  type Path = [(Label, Int)]
#+end_src

We use *fold* to reduce the *RoadSytem*

#+begin_src haskell
  roadStep :: (Path, Path) -> Section -> (Path, Path)
  roadStep (pathA, PathB) (Section a b c) =
    let priceA = sum $ map snd pathA
        priceB = sum $ map snd pathB
        forwardPriceToA = priceA + a
        crossPriceToA   = priceB + b + c
        forwardPriceToB = priceB + b
        crossPriceToB   = priceA + a + c
        newPathToA      = if forwardPriceToA <= crossPRiceToA
                          then (A,a):pathA
                          else (C,c):(B,b):pathB
        newPathToB      = if forwardPriceToB <= crossPriceToB
                          then (B,b):pathB
                          else (C,c):(A,a):pathA
    in
      (newPathToA, newPathToB)
#+end_src

#+begin_src haskell
  optimalPath :: RoadSystem -> Path
  optimalPath roadSystem =
    let (bestAPath, bestBPath) = foldl roadStep ([],[]) roadSystem
    in
      if sum (map snd bestAPath) <= sum (map snd bestBPath) -- check what is the cheapest
      then reverse bestAPath
      else reverse bestBPath
#+end_src

#+begin_src haskell
  groupsOf :: Int -> [a] -> [[a]]
  groupsOf 0 _  = undefined
  groupsOf _ [] = []
  groupsOf n xs = take n xs : groupsOf n (drop n xs) -- take throws!!
#+end_src

#+begin_src haskell
  import Data.List
  main = do
    contents <- getContents
    let threes = groupsOf 3 (map read $ lines contents)
        roadSystem = map (\[a,b,c] -> Section a b c) threes -- throws if not grouped in 3
        path = optimalPath roadSystem
        pathString = concat $ map (show . fst) path
        pathPrice = sum $ map snd path
    in
      putStrLn $ "The best path to take is: " ++ pathString
      putStrLn $ "The price is: " ++ show pathPrice
#+end_src
** TODO 11 Applicative Functors

- "We don't need to think about types belonging to a big hierarchy."

- "Typeclasses are open, which means that we can define our own data type...and connect it with the type classes that define its behaviors."

- Functors
  - definition: things that can be mapped over, aka values with added =context=
  - *fmap* applies a function to a value while preserving its =context=
  - it must have kind of "* -> *" (aka it takes exactly one concrete type parameter)

***   Functor applied to IO

- The action that a =do= block produces will always yield the result value of its last action.
#+begin_src haskell
  instance Functor IO where
    fmap f action =
      result <- action
      return (f result)
#+end_src

***   Functions as Functors

- It bends our minds a bit and lets us see how things that act more like computations than boxes (IO and "(->) r") can be functors.

- "(->) r" is another instance of Functor
  - aka the partial application of
    - "r -> a"
- "->" is just a type constructor that takes 2 type parameters, like Either

- How? Implemented in =Control.Monad.Instances=
  #+begin_src haskell
    instance Functor ((->) r) where
      fmap f g = (\x -> f (g x))
    instance Functor ((->) r) where
      fmap = (.)
  #+end_src
  - mapping a over a function must produce a function,
    aka =function composition=
    fmap :: (a -> b) -> ((->) r a) -> ((->) r b)
    fmap :: (a -> b) -> (r -> a)   -> (r -> b)

- You can think of =fmap= in 2 ways
  1) as a function that takes a function and a functor value and then maps that function over the functor value
  2) as a function that takes a function and ~lifts~ that function so it operates on functor values

#+begin_src haskell
  fmap (replicate 3) [1,2]          -- [[1,1,1],[2,2,2]]
  fmap (replicate 3) (Just 4)       -- Just [4,4,4]
  fmap (replicate 3) (Right "blah") -- Right ["blah","blah","blah"]
  fmap (replicate 3)  Nothing       -- Nothing
  fmap (replicate 3) (Left "foo")   -- Left "foo"
#+end_src

***   Functor Laws

- Not enforced by the compiler. Ensure the common behavior of the functor when mapping.
  1) fmap id = id
  2) fmap (f . g) = fmap f . fmap g

Example: Breaking the Law

#+begin_src haskell
  data CMaybe a = CNothing | CJust Int a
                deriving (Show)

  instance Functor CMaybe where
    fmap f CNothing = CNothing
    fmap f (CJust counter x) = CJust (counter+1) (f x)
#+end_src

Fails the 1st law.

#+begin_src haskell
  fmap id (CJust 0 "haha") -- CJust 1 "haha"
       id (CJust 0 "haha") -- CJust 0 "haha"
#+end_src

*** Using Applicative Functors

- If we fmap with a function that takes 2 parameters over a Functor.
  We get a function partially applied into the Functor. (aka Functor values that contain functions inside them)

  #+begin_src haskell
    fmap (*) (Just 3) -- Just ((*) 3)
    :t fmap (++) (Just "hey")               -- :: Maybe ([Char] -> [Char])
    :t fmap compare (Just 'a')              -- :: Maybe (Char -> Ordering)
    :t fmap compare "A LIST OF CHARS"       -- :: [Char -> Ordering]
    :t fmap (\x y z -> x + y / z) [3,4,5,6] -- :: (Fractional a) => [a -> a -> a]
  #+end_src

- We could then use that and fmap over that Functor
  #+begin_src haskell
    let a = fmap (*) [1,2,3,4]
      in fmap (\f -> f 9) a -- [9,18,27,36]
  #+end_src

- But we CANNOT easily operate with both "kind" of functors at the same time
  eg: with "Just 9" and "Just (3 *)"

- <*> in an =Applicative= is similar to fmap but,
  takes a functor value that has a function in it AND another functor
  extracts the function from the 1st and maps it over the 2nd

* 00 | The Haskell School of Expressive Language |          | Paul Hudak
** 3 Simple Graphics
*** 3.1 Basic Input/Output
- ~Standard Prelude~ and ~Standard Libraries~
- () is called ~unit type~, ans has only () as value
- IO
  There is a special kind of ~value~ called ~action~.
  It won't try to display it but it will take action.
  Ex: writing to a file or reading from keyboard.
  ~expressions~ or functions that evaluate to an action are called ~commands~
- IO () is often called a ~noop~, it is an action that returns ()
- putStr, putChar, writeFile, readFile, do, getLine
- ??? you can put actions on a list, but won't "do" anything unless on a do or a main ???
- sequence applied to IO has this signature
  sequence :: [IO a] -> IO ()

*** 3.2 Graphics Windows
- sierpinsky
#+begin_src haskell
fillTri :: Window -> Int -> Int -> Int -> IO ()
fillTri w x y size =
  drawInWindow w
  $ withColor Green
  $ polygon [(x,y), (x + size, y), (x, y - size), (x,y)]

minSize :: Int
minSize = 8

sierpinskiTri :: Window -> Int -> Int -> Int -> IO ()
sierpinskiTri w x y size
  | size <= minSize = fillTri w x y size
  | otherwise       = let size2 = size `div` 2
                      in do sierpinskiTri w x y size2
                            sierpinskiTri w x (y - size2) size2
                            sierpinskiTri w (x + size2) y size2
#+end_src
- david star:
  1) draw a equilateral triangle
  2) draw a new one rotated 180
  3) do 1 and 2 for each corner, but with 1/3 of a triangle size
** 4 Shapes II: Drawing shapes
- Many indirect graphics functions, to:
  1) being able to work with each shape properties
** 5 Polymorphic and High-order Funtions
* 08 | Real World Haskell                        | O'Reilly | Bryan O'Sullivan
- Updated code version https://github.com/tssm/up-to-date-real-world-haskell/
- Real World Haskell outdated parts https://stackoverflow.com/questions/23727768/which-parts-of-real-world-haskell-are-now-obsolete-or-considered-bad-practice
- Online http://book.realworldhaskell.org/read/

System.Cmd -> System.Process
System.Time -> Data.Time (Calendar/Clock/Format/LocalTime)

** 6 Using Typeclasses
*** Defining
- Different implementation depending on the type of data given.
- Defining a new ~Typeclass~ named "BasicEq3".
  We can provide *default implementations* for Typeclasses, and make one depend on the other.
#+begin_src haskell
class BasicEq3 a where
  isEqual3 :: a -> a -> Bool
  isEqual3 x y = not (isNotEqual3 x y)

  isNotEqual3 :: a -> a -> Bool
  isNotEqual3 x y = not (isEqual3 x y)
#+end_src
- An ~Instance Type~ of this typeclass, is any type that implements the functions defined in it.
- isEqual :: BasicEq a => a -> a -> Bool
  Reads:
  "For all types of *a*,
   so long as *a* is an instance of BasicEq,
   isEqual takes two parameters of type *a* and returns Bool""
*** Type Instancing
#+begin_src haskell
instance BasicEq3 Color where
  isEqual3 Red   Red   = True
  isEqual3 Green Green = True
  isEqual3 Blue  Blue  = True
  isEqual3 _     _     = False
#+end_src
*** Build-in
- Show, and the function show which returns a string from something showable
  show :: (Show a) => a -> String
  (you can derive it or explicitly Type Instance it)
  - To define your own show redefine ~show~
- Read, and the function read which takes a string and returns something readable
  read :: (Read a) => String -> a
  e.g. (read readVar)::Double
  - To define your own parser redefine ~readsPrec~
** 7
- ~Type classes~ provide ad-hoc polymorphism
  - Can define default "implementations" for the class
- ~Types~ are made instances of a particular type class
- Typeclasses
  - Show: Used to display your custom types. ghci repl uses it.

    #+begin_src haskell
data Color = Red | Green | Blue

instance Show Color where
  show Red = "rojo"
  show Green = "verde"
  show Blue = "azul"
    #+end_src
** TODO 20 Systems Programming in Haskell

ME: backticks allows us to "flip" notElem
#+begin_src haskell
> SD.getDirectoryContents  "/" >>= return . filter (`notElem` [".",".."])
["sys","sbin","tmp","mnt","srv","opt","var","home","dev","lib64","media","lib32","libx32","bin","usr","snap","run","etc","proc","root","cdrom","boot","lib"]
#+end_src

Piping...

** TODO 24 Concurrent and MultiCore Programming

- Concurrent
  - possible unrelated tasks
  - at the same time
  - IO interactions are common

- Parallel
  - same task/problem
  - IO interactions are rare

- Threads are nondeterministic

- =MVar= is a _synchronization variable_
  - his state is either *full* or *empty*
  - thread is put to _sleep_ if either
    1) put into a full MVar
    2) take from an empty MVar
  - in lue of the lack of a way for a thread to know the state of another thread. That would have made Haskell threads heavier.
  - examples: a notification, or provide mutual exclusion (semaphore?)

*** Example: compressing on a thread AND handling input at the same time (forkIO, readline, zlib)

#+begin_src haskell
  import Control.Concurrent (forkIO)
  import Control.Exception (handle)
  import Control.Monad (forever)
  import qualified Data.ByteString.Lazy as L
  import Sytem.Console.ReadLine (readline)  -- readline package
  import Codec.Compression.GZip (compress) -- zlib package

  main :: IO ()
  main = do
    maybeLine <- readLine "Enter a file to compress> "
    case maybeLine of
         Nothing -> return ()
         Just "" -> return ()
         Just name -> do
           handle print $ do
             content <- L.readFile name -- open file
             forkIO (compressFile name content) -- reading/compression happens on the thread
             return ()
           main
    where
      compressfile path = L.writeFile (path ++ ".gz") . compress
#+end_src

*** TODO Example: a library to wait for child treads to complete (MVar, containers)

#+begin_src haskell
import Control.Concurrent
import Control.Exception (Exception, try)
import qualified Data.Map as M -- from containers package

newtype ThreadManager
  = Mgr (MVar (M.map ThreadId (MVar ThreadStatus)))
  deriving (Eq)

data ThreadStatus
  = Running
  | Finished -- terminated normally
  | Threw Exception -- killed by an uncaugh exception
  deriving (Eq, Show)
#+end_src

#+begin_src  haskell
forkManaged :: ThreadManager -> IO () -> IO ThreadId
forkManaged (Mgr mgr) body =
  modifyMVar mgr $ \m -> do
    state <- newEmptyVar
    tid <- forkIO $ do
      result <- try body
      putMVar state (either Threw (const Finished) result)
    return (M.insert tid state, tid) -- (newvalue, returnvalue)

getStatus :: ThreadManager -> ThreadId -> IO (Maybe ThreadStatus)
getStatus (Mgr mgr) tid =
  modifyMVar mgr $ \m -> case M.lookup tid m of
                           Nothing -> return (m, Nothing) -- no managed, immediately returns
                           Just st -> tryTakeMVar st >>= \mst -> case mst of -- managed
                                                                   Nothing -> return (m, Just Running) -- no blocking
                                                                   Just sth -> return (M.delete tid m, Just sth)
#+end_src

#+begin_src haskell
  waitFor :: ThreadManager -> ThreadId -> IO (Maybe ThreadStatus) -- block on id
  waitFor (Mgr mgr) tid = do
    maybeDone <- modifyMVar mgr $ \m ->
                                    return $ case M.updateLookupWithKey (\_ _ -> Nothing) tid m of
                                                  (Nothing, _) -> (m, Nothing)
                                                  (done, m') -> (m', done)
    case maybeDone of
      Nothing -> return Nothing
      Just st -> Just `fmap` takeMVar st
#+end_src

#+begin_src haskell
newManager  :: IO ThreadManager
waitAll     :: ThreadManager -> IO () -- block on all
#+end_src

*** Example: how modifyMVar code looks like

#+begin_src haskell
  import Control.Concurrent (MVar, putMVar, takeMVar)
  import Control.Exception (block, catch, throw, unblock)
  import Prelude hiding (catch)
  modifyMVar :: MVar a -> (a -> IO (a,b)) -> IO b
  modifyMVar m io =
    block $ do
      a <- takeMVar m
      (b,r) <- unblock (io a) `catch` \e -> putMVar m a >> throw e
      putMVar m b
      return r
#+end_src

*** Example:
- reads block until there is a value to read
- writes never block
#+begin_src haskell
  import Control.Concurrent
  import Control.Concurrent.Chan
  chanExample = do
    ch <- newChan
    forkIO $ do
      writeChan ch "hello world"
      writeChan ch "now i quit"
    readChan ch
    readChan ch
#+end_src

** TODO 28 STM Software Transactional Memory

|-----------------+----------------------------|
|             <r> |                            |
|   MVar problems | due...                     |
|-----------------+----------------------------|
| race conditions | forgotten locks            |
|       deadlocks | inconsistent lock ordering |
|      corruption | uncaught exceptions        |
|    lost wakeups | ommited notifications      |
|-----------------+----------------------------|

With STM we executa a block of actions as a transaction using the =atomically= combinator.
Automatically restarting the transactin on failure.

*** Example: mmorpg

#+begin_src haskell
  {-# LANGUAGE GeneralizedNewtypeDeriving #-}
  import Control.Concurrent.STM
  import Control.Monad

  data Item
    = Scroll
    | Wand
    | Banjo deriving (Eq, Ord, Show)

  newtype Gold = Gold Int
    deriving (Eq, Ord, Show, Num)
  newtype HitPoint = HitPoint Int
    deriving (Eq, Ord, Show, Num)

  type Inventory = TVar [Item]
  type Health = TVar HitPoint
  type Balance = TVar Gold

  data Player = Player {
    balance :: Balance,
    health :: Health,
    inventory :: Inventory
    }
#+end_src

#+begin_src haskell
basicTransfer :: Gold -> Balance -> Balance -> STM ()
basicTransfer qty fromBal toBal =
  fromQty <- readTVar fromBal
  toQty   <- readTVar toBal
  writeTVar fromBal (fromQty - qty)
  writeTVar   toBal (  toQty + qty)

transferTest :: STM (Gold,Gold)
transferTest = do
  alice <- newTVar 12
  bob   <- newTVar 4
  basicTransfer 3 alice bob
  liftM2 (,) (readTVar alice) (readTVar bob)
#+end_src

> atomically transferTest

* 10 | Seven Languages in 7 weeks                | PragProg | Bruce A. Tate

- "In Haskell, indentation is significant." (?
- on Haskell, ~if~ is a function, NOT a control structure, it returns a value.
- "." for function composition
  second = head . tail
- On ghci console
  > :set +t
- A partial applied function is called ~section~
- ~where~ on function definition can define local functions too
- ~every~ function does have 1(one) parameter
  - the process of reducing a function of N parameters to N of 1 param is ~currying~

#+NAME: single-line vs multi-line pattern-matching vs guards
#+begin_src haskell
fact x = if x == 0 then 1 else fact (x - 1) * x

factorial :: Integer -> Integer
factorial 0 = 1
factorial x = x * factorial (x - 1)

factorio :: Integer -> Integer
factorio x
  | x > 1     = x * factorio (x - 1)
  | otherwise = 1
#+end_src

* 18 | Haskell School of Music                   |          | Donya Quick
** 1 Computer Music, Euterpea, and Haskell
*** 1.1 The Note versus Signal Dichotomy
- High/Low    level music concepts a.k.a.
  Note/Signal level music concepts
- Note: pitch and volume
- Bit depth: storage size of a single sample.
  Typically 16bits (2bytes) or 32bits (4bytes)
*** 1.2 Basic Principles of Programming
- Measures of success: correctness, efficiency, clarity
- Code often represents the author's thought process...A conventional
  musical score does not.
*** 1.3 Computation by Calculation
- In general, it is best to search first for an elegant (and correct!) solution to a problem, and later refine it for better performance.
  “Get it right first!”
- ~unfolding~ a function, is when we replace the arguments in the definition
  simple x y z = x * (y + z)
  simple 3 9 5
  > 3 * (9 + 5)
  > 42
- "simple 3 9 5 ~evaluates~ to 42"
*** 1.4 Expressions and Values
- note names are called pitch classes
- ~expressions~ entities that can be evaluated
- ~value~ are expressions that cannot be further evaluated.
  ex: 1,[1,2],(3,3),'C',"hello"
- ~diverging~ expressions are those that do not have an end
  ex: f x = f (x - 1)
  evaluate to "Bottom" value _|_
*** 1.5 Types
- Atomic or Structured
- Type Signature
  'D' :: Char
      :: reads as "has type"
   D  :: PitchClass
- Elements on a List are the same Type
- Elements on a Tuple could be different Types
*** 1.6 Function Types and Type Signatures
#+begin_src haskell
simple :: Int -> Int -> Int -> Int
simple x y z = x * (y + z)
#+end_src
- "it is a good habit to first write down the type of each function you
   are planning to define, as a first approximation to its full specification"
- f :: T1 -> T2 -- In mathematics T1 is the ~domain~ and T2 is the ~range~
- ~function application~ aka calling the funtion, has always higher precedence on application
- symbol based functions are usually called ~operators~ and are ~infix~
  - Are defined between parentheses
  - (+) :: Integer -> Integer -> Integer
- ' is a valid alphanumeric value, so f' and f'' are valid function names
*** 1.7 Abstraction, Abstraction, Abstraction
- “What are the three most important ideas in programming?" (see title)
**** 1.7.1 Naming
#+begin_src haskell
pi :: Double
pi = 3.1415
-- two definitions in one
concertA,a440 :: (PitchClass, Octave)
concertA = (A,4)
a440     = (A,4)
-- Vars
c = 42 -- is called a ~binding~
x    = let area = pi * r ** 2
       in f area + g area
#+end_src
- A4 is usually called "concert A" (because it is often used as a the note to which an orchestra
  tunes its intruments or "A440")
- {- MULTILINE COMMENT IN HASKELL -}
**** 1.7.2 Functional Abstraction
#+begin_src haskell
x = let areaF r = pi * r ** 2
    in f (areaF r1) + g (areaF r2)
note :: Dur -> Pitch -> Music Pitch
rest :: Dur -> Music Pitch
(:+:) Music Pitch -> Music Pitch -> Music Pitch -- Sequentially
(:=:) Music Pitch -> Music Pitch -> Music Pitch -- Simultanious
trans :: Int -> Pitch -> Pitch
-- Harmonizing each pN note with a third
qn = 1/4
mel = (note qn p1 :=: note qn (trans (-3) p1)) :+:
      (note qn p2 :=: note qn (trans (-3) p2)) :+:
      (note qn p3 :=: note qn (trans (-3) p3))
-- In a function
hNote :: Dur -> Pitch -> Music Pitch
hNote d p = note d p :=: note d (trans (-3) p)
-- applied
mel :: Music Pitch
mel = hNote qn p1 :+: hNote qn p2 :+: hNote qn p3
#+end_src
**** 1.7.3 Data Abstraction
- The order of ~associativity~ can be defined, either left, right or none.
- (:) operator has right associativity
#+begin_src haskell
hList          :: Dur -> [Pitch] -> Music Pitch
hList d []     = rest 0
hList d (p:ps) = hNote d p :+: hList d ps
--
mel = hList qn [p1,p2,p3]
#+end_src
*** 1.8 Haskell Equality versus Musical Equality
- 2 different melodies can be musically equivalent while being not equal by the language
- A melody can be interpreted either by his
  ~polyphonic~: grouping notes playing at the same time
  ~contrapuntal~: grouping by each voice
*** 1.9 Code Reuse and Modularity
- being able to re-use code is called ~modularity~
*** 1.10 [Advanced] Programming with Numbers 1
- Int data type is of size word (architecture dependent, 32 or 64 bits) (use Integer instead)
- In mathemathics, ~numerical analisys~ is concerned with numerical incongrueties
- If real-number acuraccy is important, be wary of floats
#+begin_src haskell
5 ∗ (−0.123456 + 0.123457)       :: Float ⇒ 4.991889e−6
5 ∗ (−0.123456) + 5 ∗ (0.123457) :: Float ⇒ 5.00679e−6
#+end_src
** 2 Simple Music
*** 2.1 Preliminaries
#+begin_src haskell
-- Type Synonyms
type Octave = Int
type Pitch  = (PitchClass, Octave)
type Dur    = Rational
-- Algebraic data type
data PitchClass = Cff | Cf | C | Dff | Cs | Df | Css | D | Eff | Ds
                | Ef | Fff | Dss | E | Ff | Es | F | Gff | Ess | Fs
                | Gf | Fss | G | Aff | Gs | Af | Gss | A | Bff | As
                | Bf | Ass | B | Bs | Bss
qn :: Dur
qn = 1/4
#+end_src
- data NAME = CONSTRUCTORS
  data Bool = False | True
*** 2.2 Notes, Music, and Polymorphism
#+begin_src haskell
-- (Value) Constructor
data Primitive = Note Dur Pitch |
                 Rest Dur
-- Type Constructor: more generic, polymorphic
data Primitive a = Note Dur a |
                   Rest Dur
-- Note :: Dur -> a -> Primitive a
-- Rest :: Dur ->      Primitive a
--
-- Another ~type constructor~, this time also recursive (aka inductive data type)
data Music a =
    Prim (Primitive a)
  | Music a :+: Music a
  | Music a :=: Music a
  | Modify Control (Music a)
-- Prim   :: Primitive a        -> Music a
-- (:+:)  :: Music a -> Music a -> Music a
-- (:=:)  :: Music a -> Music a -> Music a
-- Modify :: Control -> Music a -> Music a
#+end_src
- ~fixity declaration~
  infixr 5 :+:,:=:
- Data constructors
  - are still functions and have a type
  - are an example of polymorphic functions ~type abstraction~
#+begin_src haskell
data Control =
    Tempo      Rational          -- scale the tempo
  | Transpose  AbsPitch          -- transposition
  | Instrument InstrumentName    -- instrument label
  | Phrase     [PhraseAttribute] -- phrase attributes
  | KeySig     PitchClass Mode   -- key signature and mode
  | Custom     String            -- custom label
data Mode = Major | Minor | Ionian | Dorian | Phrygian | Lydian
             | Mixolydian | Aeolian | Locrian
             | CustomMode String
data InstrumentName = AcousticGrandPiano | BrightAcousticPiano ...
#+end_src
*** 2.3 Convenient Auxiliary Functions

*** 2.4 Absolute Pitches
- LIST !! N
  [C,D,E] !! 1 => D
** 3 Polymorphic and high order functions
- head, tail, length (examples of simple polymorphic types)
- map
- append (++)
- fold
  foldr, foldl: only difference is from which side is applied the operator, sometimes might be more performant from one side over the other
  foldr1, foldl1: versions that error on empty lists, so no init value needed
- `` functions into operator with backquotes
- () operator into a function with parentheses
- reverse, (algorithm with foldl)
- ~currying~
- currying simplification
  f x = g x
  f   = g
** 4
*** 4.2 Modules
- Module names are capitalized
  Can be hierachical
  import LIBRARY.FOLDER.MODULE
- module MODULE where
  module MODULE (EXPORT,EXPORT) where
*** 4.3 Transcribing a More Complex Score
**** 4.3.1 Auxiliary Functions
- Haskell does not permit pattern-matching against function applications.
  myFunction (Prim (Note d p)) = -- OK
  myFunction (note d p)        = -- FAIL
- times :: Int -> Music a -> Music a -- repeats
  addDur
  graceNote
- The only special cases that will not be handled using auxiliary functions are:
  1) the single staccato on note four of bar fifteen
  2) the single portamento on note three of bar sixteen.
  These situations will be addressed differently in a later chapter.
*** 4.4 Simple Algorithmic Composition
* 20 | Finding Success and Failure               | JoyH     | Julie Moronuki

ERRATA:
- solutions, page 188, exercise 28, "remove brackets from cleanWhitespace"

** Preface

- Most programming languages have, in some form or other, a way of dealing with failure.
  A way to *combine* multiple smaller programs /that might fail/
  into a larger program /that might fail/
- Halting on error (like on imperative code)
  - Doesn't always provide us with as much information as we might like
    Can only give us information about the *first* problem that was encounterd.
- the ~Monad~ class is our tool for generalizing the notion of /program/
  beyond "run a series of subprograms until one fails".
- The book teaches about ~Monad~ and ~Applicative~
  - how they are similiar
  - how they differ
  - and how to use types to rethink our solutions to problems

** 1 Case Expression in Practice

- *case* expression,
  - serve similiar branching role as *if/then/else* but with much more generality.
  - allow behavior to branch on values other than booleans
  - order of the *case/of* expression matter only when patterns are *overlapping*

- functions
  - ~polymorphic~ has a type variable, it can take many types.
  - ~monomorphic~ has NO type variables.
  - ~partial functions~ do NOT handle all their /constructors/
  - ~total functions~ handle all /constructors/

- ~sum types~ is having more than 1(one) constructor
  (aka: disjuntion, disjoint union, tagged union)

- =Bool= type, is a ~concrete type~
  #+begin_src haskell
    data Bool = True | False -- 2 constructors
  #+end_src

- =Maybe= type, is a ~parametrized type~ aka *type constructor*
  #+begin_src haskell
    data Maybe a = Nothing | Just a
  #+end_src

** 2 Case Expression Practice

- Example: checks two strings inputs to determine whether they are anagrams of one another.
- we use the idiom (xy, ys) to indicate variables that are lists or strings

*** Example: pattern matching on ~Bool~ to return ~Maybe~

  #+begin_src haskell
    isWord :: String -> Maybe String
    isWord word =
      case null word of
        True  -> Nothing
        False ->
          case (all isAlpha word) of
            False -> Nothing
            True  -> Just word

    checkAnagram :: String -> String -> String
    checkAnagram word1 word2 =
      case (isWord word1) of
        Nothing    -> "The first word is invalid"
        Just word1 ->
          case (isWord word2) of
            Nothing    -> "The second word is invalid"
            Just word2 ->
              case (isAnagram word1 word2) of
                False -> "These words are not anagrams."
                True  -> "These words are anagrams."
  #+end_src

** 3 Validating Functions

- The module name is *Main* because an /executable/ must always be named *Main*

** 4 The =Maybe= Monad

- Solution in this capter
  - will use the bind operator (>>=)
  - it WON'T tell you which of the validation rules failed

- INTERNET: https://stackoverflow.com/questions/62018158/string-concatenation-via-or
  - when concatenating strings you can use (++) or (<>)
  - but (<>) is preferable because it works with ~Text~ types other than ~Prelude.String~
  - but it might become ambiguous due polymorphism and when using *-XOverloadedStrings*

- ~infix operators~
  - the reader has to know the /associativity/ of the operator.
  - associativity matters also when thinking on performance

- the (.) operator might help to only work with 1(one) list
  #+begin_src haskell
f  x =  drop 2  (map toUpper  (reverse x))
f' x = (drop 2 . map toUpper . reverse) x
  #+end_src

*** Enter the monad

- The bind operator
  #+begin_src haskell
    (>>=) :: Monad m => m a -> (a -> m b) -> m b
  #+end_src

- validatePassword without using case/of
  #+begin_src haskell
validatePassword' :: String -> Maybe String
validatePassword' password =
  cleanWhitespace password
    >>= requireAlphaNum
    >>= checkPasswordLength''
  #+end_src

*** Classes and instances

- Monad is a *typeclass*
- A *typeclass* defines a set of /generic functions/ that work with a set of types.

- A =class= declaration
  - gives only the type signatures in their most polymorphic forms.
- An =instance= declaration
  - gives a /concrete implementation/ of the generic function of that *class* for a given concrete type.

- TIP: thinking about types as instances of a certain typeclass.
  Allows you to focus on the similarities between the types.

*** ~TypeApplications~ (a language extension)

- Allows you to specify
  - what type you will apply a polymorphic function to
  - and see the resulting type.

- aka querying the type signature

#+begin_src haskell
  >>> :set -XTypeApplications

  >>> :type (>>=) @Maybe
  (>>=) @Maybe
    :: Maybe a -> (a -> Maybe b) -> Maybe b

  >>> :type (>>=) @Maybe @String
  (>>=) @Maybe @String
    :: Maybe String -> (String -> Maybe b) -> Maybe b

  >>> :type (>>=) @Maybe @String @String
  (>>=) @Maybe @String @String
    :: Maybe String -> (String -> Maybe String) -> Maybe String
#+end_src

*** Case and binds

- A type can have _at most_ ONE instance of a typeclass.

- Using ~bind(>>=)~ and ~Maybe~ here means we lost the ability to tell which *Nothing* we returned and, thus, what our error is.

- Haskell's =do= syntax is intended to allow something like imperative-style programming that ignores the monadic underpinnings.

- Example: main from _do_ to bind
  #+begin_src haskell
main :: IO ()
main = getLine >>= \password ->
                     print (cleanWhitespace password)
  #+end_src

- Example: main from _do_ to bind, without explicit argument passing
  #+begin_src haskell
    main :: IO ()
    main = getLine >>= (print . cleanWhitespace)
  #+end_src

** 5 Refactoring with =Either=
*** Adding error messages

- We can have ~validatePassword~ return a =String= with an error message if it fails. It becomes again a sequence of case/of
  #+begin_src haskell
    validatePassword :: String -> String
  #+end_src

*** Introducing =Either=

#+begin_src haskell
  data Either a b = Left a | Right b
#+end_src

- ~Right b~ is similar to ~Just a~ from =Maybe=
- ~Left a~ can carry data unlike ~Nothing~ from =Maybe=

*** The =Either= Monad

#+begin_src haskell
  instance Monad Maybe
    where
      Nothing >>= _ = Nothing
      Just x  >>= f = f x

  instance Monad (Either e) -- leftmost type parameter is fixed, whatever type it is, it CANNOT be transformed
    where
      Left  l >>= _ = Left l
      Right r >>= f = f r
#+end_src

- In Haskell, a ~Monad~ must be a unary *type constructor*.
- In order to use bind(>>=) you need to partially apply ~Either~ to its leftmost parameter.

#+CAPTION: Showing it with *TypeApplications*, with String or _
#+begin_src haskell
  > :type (>>=) @(Either String)
  (>>=) @(Either String) ::
      Either String a -> (a -> Either String b) ->
      Either String b

  > :type (>>=) @(Either_)
  (>>=) @(Either String) ::
      Either w a -> (a -> Either w b) ->
      Either w b
#+end_src

*** Using =Either=

- the final ~validatePassword~ function using =Either= will be the exact same as the one using =Maybe=

*** Kinds

- In haskell, we use a notation called ~kinds~ to talk about the /arity of a type constructor/.
- Kinds are sometimes also defined as "the types of types"

|--------------------+-------------------+---------------------------|
| :kind Bool         | Bool :: *         |                           |
| :kind Maybe        | Maybe :: * -> *   | all monads have this kind |
| :kind Maybe String | Maybe String :: * |                           |
|--------------------+-------------------+---------------------------|

- Kinds of different types
 |------------------------+-------------+--------------------|
 |                    <r> |             |                    |
 |------------------------+-------------+--------------------|
 |                 String | *           |                    |
 |                     [] | * -> *      | *could* be a monad |
 |                    (,) | * -> * -> * |                    |
 |                (,) Int | * -> *      | *could* be a monad |
 | data Pair a = Pair a a | * -> *      | *could* be a monad |
 |------------------------+-------------+--------------------|

** 6 Working with =newtype=
*** Introducing

- ~type aliases~ do NOT offer *safety*, it only gives you another name for the same type.
  - Example: We could accidentally provide a =Password= to a function that expects a =Username=
    #+begin_src haskell
      type Password = String
      type Username = String
    #+end_src

- ~newtype~ has a *data constructor* that is named differently from the underlying typed constructor
  #+begin_src haskell
    newtype Password = Password String
      deriving Show
  #+end_src

- differences of ~newtype~ with ~data~
  1. /newtype/ may only have a _ONE unary constructor_
  2. /newtype/ has optimizations due 1)
  3. /newtype/ offers a cheap coercion, between the /newtype/ and the underlying type, /data/ does NOT
  4. ~GeneralizedNewtypeDeriving~ language extension (?)
  5. /newtype/ and /data/ have different behavior on non-strictness

*** Declaring

#+begin_src haskell
  newtype Password = Password String
    deriving (Show)

  newtype Error = Error String
    deriving (Show)

  newtype Username = Username String
    deriving (Show)
#+end_src

*** Using

#+begin_src haskell
  requireAlphaNum :: String -> Either Error String
  requireAlphaNum xs =
    case (all isAlphaNum xs) of
      False -> Left (Error "Invalid password")
      True  -> Right xs

  checkPasswordLength :: String -> Either Error Password
  checkPasswordLength password =
    case (length password > 20) of
      True  -> Left (Error "Password is too long.")
      False -> Right (Password password)

  validatePassword :: Password -> Either Error Password
  validatePassword (Password password) =
    cleanWhitespace password
      >>= requireAlphaNum
      >>= checkPasswordLength
  --------------------------------
  checkUsernameLength :: String -> Either Error Username
  checkUsernameLength name =
    case (length name > 20) of
      True  -> Left (Error "Password is too long.")
      False -> Right (Username name)

  cleanWhitespace :: String -> Either Error String
  cleanWhitespace "" = Left (Error "String is empty")
  cleanWhitespace (x : xs) =
    case (isSpace x) of
      True  -> cleanWhitespace xs
      False -> Right (x : xs)
#+end_src

*** Revising main

- naive, introducing a new let
  #+begin_src haskell
    main :: IO ()
    main =
      do
        putStr "Please enter a password\n> "
        password <- getLine
        let password' = Password password
        print (validatePassword password')
  #+end_src

- naive, without let
  #+begin_src haskell
    main :: IO ()
    main =
      do
        putStr "Please enter a password\n> "
        password <- getLine
        print (validatePassword (Password password))
  #+end_src

- fmap(<$>), will apply the =Password= constructor *inside* the IO, changing from an ~IO String~ to an ~IO Password~
  #+begin_src haskell
    main :: IO ()
    main =
      do
        putStr "Please enter a password\n> "
        password <- Password <$> getLine
        print (validatePassword password)
  #+end_src

*** Exercises

#+begin_src haskell
  (>>=) @IO :: IO a -> (a -> IO b) -> IO b
  (>>)  @IO :: IO a ->       IO b  -> IO b
#+end_src

- from using *do*
  #+begin_src haskell
    main =
      do
        putStr "Please enter a password\n> "
        password <- Password <$> getLine
        print (validatePassword password)
  #+end_src

- to using (>>=)
  #+begin_src haskell
    main =
      putStr "Please enter a password\n> "
        >> (Password <$> getLine)
        >>= (print . validatePassword)
  #+end_src

*** Notes on monadic style

- When to use (>>=) and when use do?
  1) if it seems like you're writing way *Too Many Lambdas* use ~do~
  2) *Too many variables* that get introduced on one line, only to get used on the next, use (>>=)
  3) Or use both
     #+begin_src haskell
       do
         x1 <- a1 >>= f1 >>= f2
         x2 <- a2 >>= f3 >>= f4
         f5 x1 x2
     #+end_src

** 7 Introducing =Applicative=

- A ~product type~ is the conjuction (aka "and") of two or more types.
  - ~tuples~ are the canonical product types, sometimes called /anonymous products/
  #+begin_src haskell
    data User = User Username Password
      deriving (Show)
  #+end_src

- =Applicative= typeclass operator (<*>), aka ~tie-fighter~ or ~apply~ or ~app~
  - Allows for /function application/ in the presence of some outer type structure (aka context)
  - Unlike "bind" there is NOTHING that would force us to "short-circuit" on an error value.
  #+begin_src haskell
    (<*>) :: Applicative f => f (a -> b) -> f a -> f b
  #+end_src

*** Constructors are functions

- We are constructing a functions *inside* an Applicative type ~Either~
- Right is the function that we needs to be passed to <*>

#+begin_src haskell
  validateUsername :: Username -> Either Error Username
  validateUsername (Username username) =
    cleanWhitespace username
    >>= requireAlphanum
    >>= checkUsernameLength

  > :type (validateUsername (Username "name"))
    :: Either Error Username
  > :type (User <$> (validateUsername (Username "name")))
    :: Either Error (Password -> User)
#+end_src

*** Using Applicative (makeUser)

=makeUser= unlike =User=, has the possibility of failure

#+begin_src haskell
  -- validateUsername :: Username -> Either Error Username
  -- validatePassword :: Password -> Either Error Password
  --  User :: Username -> Password -> User
  makeUser :: Username -> Password -> Either Error User
  makeUser name password =
    User <$> validateUsername name
         <*> validatePassword password
#+end_src

*** Example: Using Applicative with checkAnagram

#+begin_src haskell
  checkAnagram :: String -> String -> String

  promptWord1 :: IO String
  promptWord1 =
    do
      putStr "Please enter a word.\n> "
      getLine

  promptWord2 :: IO String
  promptWord2 =
    do
      putStr "Please enter a second word.\n> "
      getLine

  main :: IO ()
  main =
    do
      result <- checkAnagram <$> promptWord1
                             <*> promptWord2
      print result
#+end_src

** 8 Refactorign with =Validation=

- refactor from =Either= to =Validation=
  - from the package https://github.com/system-f/validation
  - both types are ~isomorphic~, we can convert back and forth between them
  - their =Applicative= instances are different
    - on =Validation= we can accumulate errores on the ~Left1~
  - uses the typeclass =Semigruop=
  - depends on *lens* library

*** Introducing validation

> stack repl --package validation
> cabal repl --build-depends validation

- Has one module, =Data.Validation=
  #+begin_src haskell
    data Validation err a
       = Failure err
       | Success a
  #+end_src

- Validation is NOT a =Monad=
  - if it were, it would have to "short circuit" and lose the accumulation on the left values.
  - reminder: Monads are Applicatives

- Since functions chained together with *applicative* (<*>) can be evaluated independently:
  1) we can /accumulate/ the errors from several function applications.
  2) /concatenate/ them using the underlying =Semigroup=
  3) and /return/ as many errors as there are.

- err type parameter NEEDS a =Semigroup= constraint
  #+begin_src haskell
    instance Semigroup err => Applicative (Validation err)
  #+end_src

- We will still use =Error= we created before,
  - while it is a *newtype* from =String=, and =String= is a =Semigroup=
  - we don't inherit the instances of the underlying type by default

*** Add .cabal dependency

#+begin_src haskell-cabal
  executable validation
    hs-source-dirs:   src
    main-is:          Main.hs
    default-language: Haskell2010
    build-depends:    base >= 4.7 && < 5
                    , validation
#+end_src

*** Nominal refactoring

Change the =Error= type

#+begin_src haskell
  newtype Error = Error [String]
     deriving (Show)
#+end_src

*** Interpreting the errors

- After our new definition of =Error=, our code will need 2 changes due:

  1) "No instance for Monad (Validation Error) arising from a use >>="
     - we knew since, Validation is NOT an instance of Monad

  2) "No instance for (Semigroup Error) arising from a use of <*>"
     - =Error= must have a =Semigroup= instance, in order to know how to accumulate errors.
     - while =Error= is /representationally equivalent/ to [String], it is NOT the same (new)type.

*** 2) define Semigroup for new Error

- fixes error 2)

  #+begin_src haskell
    instance Semigroup Error where
      Error xs <> Error ys = Error (xs ++ ys) -- we could have used <> instead of ++
  #+end_src

- alternatively using ~GeneralizedNewTypeDeriving~ language extension
  - can only be used with /newtype/, not /data/ declarations
  - we could have just "derived" Semigroup
  - deriving means you get the standard instance for the underlying type, that the new type is isomorphic to

  #+begin_src haskell
    {-# LANGUAGE GeneralisedNewtypeDeriving #-}
    newtype Error = Error [String]
      deriving (Semigroup, Show)
  #+end_src

*** 1) Using Applicative

- fixes 1)

- We use the =Applicative= operators

  1) they let you sequence /function applications/
  2) discarding either the first or second value/operand respectly
  3) they do NOT eay any effects that are part of /f/
  |----+-----------------------------+---------------+-------------------|
  | *> | left "facing bird"/"shark"  | Applicative f | f a -> f b -> f b |
  | <* | right "facing bird"/"shark" | Applicative f | f a -> f b -> f a |
  |----+-----------------------------+---------------+-------------------|

  #+begin_src haskell
    Failure ["x"] *> Failure ["y"]              -- Failure ["x","y"]
    Success 1     *> Failure ["y"]              -- Failure ["y"]
    Failure ["x"] *> Success 1                  -- Failure ["x"]
    Failure ["x"] *> Success 1 *> Failure ["y"] -- Failure ["x","y"]
    Success 1     *> Success 2 *> Success 3     -- Success 3
    Success 1     <* Success 2 <* Success 3     -- Success 1
  #+end_src

- we refactor functions to stop using >>=, since we cannot have a Monad instance
  we use a /case/

  #+begin_src haskell
    validatePassword :: Password -> Validation Error Password
    validatePassword (Password password) =
      case (cleanWhitespace password) of
           Failure err       -> Failure err
           Success password2 -> requireAlphaNum password2 *>
                                checkPasswordLength password2
  #+end_src

*** Exercises

1) we could use Applicative for =Either= since is a =Monad=, and as such is an =Applicative=

   - in some more complex cases it might matter if =Applicative= compose better
   - or we can possible achieve better parallelism with it
   - ME: I have no idea how this will compose? appending string errors?

   #+begin_src haskell
     validatePassword :: Password -> Either String String
     validatePassword pwd =
       case (cleanWhitespace pwd) ->
         Left err   -> Left err
         Right pwd' -> requireAlphaNum pwd' *>
                       checkPasswordLength pwd'
   #+end_src

2) refactor code from using "do" to "applicative"

   #+begin_src haskell
     -- FROM
     promptWord1 :: IO String
     promptWord1 =
       do
         putStr "Please enter a word.\n"
         getLine

     -- TO
     prompWord1 =
        putStr "Please enter a word.\n" *> getLine

     -- main refactor
     main :: IO ()
     main =
       checkAnagram <$> prompt1 <*> prompt2 >>= print
   #+end_src

3) extension for using "do" notation for when you not have monads

   #+begin_src haskell
     {-# LANGUAGE ApplicativeDo #-}
     makeUser :: Username -> Password -> Validation Error User
     makeUser usr pwd =
       do
         usr' <- validateUsername usr
         pwd' <- validatePassword pwd
         pure $ User usr' pwd'
   #+end_src

4) While =String= is a type alias for =[Char]=, and a linked list.
   As such his memory layout might not be the efficient.
   =Text= is an alternative data type that is more efficient.
   - add "text" in the .cabal dependencies
   - import it
     #+begin_src haskell
       import qualified Data.Text as T    -- avoid Prelude clashing
       import qualified Data.Text.IO as T -- avoid Prelude clashing
       import Data.Text (Text)            -- avoid calling the type Text as T.Text
     #+end_src
   - type conversion functions
     #+begin_src haskell
       T.pack :: String -> Text
       T.unpack :: Text -> String
     #+end_src
   - language extension allows us to use the same "string" syntax for any string type
     #+begin_src haskell
       {-# LANGUAGE OverloadedStrings #-}
     #+end_src

5) Refactoring using =Text=

  #+begin_src haskell
    -- just changing String for T.Text
    newtype Username = Username T.Text deriving Show
    newtype Password = Password T.Text deriving Show
    newtype Error = Error [T.Text] deriving (Semigroup, Show)

    checkPasswordLength :: T.Text -> Validation Error Password
    checkPasswordLength password =
      case (T.length password > 20) of -- !!
        True  -> Failure (Error ["Your password cannot be longer than 20 characters"])
        False -> Success (Password password)

    requireAlphaNum :: T.Text -> Validation Error Text
    requireAlphaNum xs =
      case (T.all isAlphaNum xs) of -- !!
        False -> Failure (Error ["Cannot contain white space or special characters."])
        True  -> Success xs

    cleanWhitespace :: T.Text -> Validation Error Text
    cleanWhitespace input =
      if T.null (T.strip input) -- !!
      then Failure (Error ["Cannot be empty."])
      else Success (T.strip input) -- !!

    main :: IO ()
    main =
      do
        putStrLn "Please enter a username."
        username <- Username <$> T.getLine
        putStrLn "Please enter a password."
        password <- Password <$> T.getLine
        print (makeUser username password)
  #+end_src

** 9 Better error messages

- Goal of this chapter is write ~errorCoerce~ function,
  to be able use list functions with our =Error= newtype

- We will use
  1) explicit coercion in a separate function
  2) destructuring in pattern matching

*** The problem

- We would like to be able to distinguish between errors.
  Currently only is possible for length errors, since they use different functions.
  But for "empty input" errors there is no way to disambiguate.

- We could refactor our "main" or we could write new functions for it.
  We would do the later one.
  To prepend a custom label (a String) to each error string and format them.

*** The error functions

- ~passwordErrors~, complementary to ~validatePassword~ it will do nothing instersting on Success.

  #+begin_src haskell
    passwordErrors :: Password -> Validation Error Password
    passwordErrors pwd =
      case validatePassword pwd of
            Failure err  -> Failure (Error ["Invalid password:"] <> err)
            Success pwd' -> Success pwd'

    usernameErrors :: Username -> Validation Error Username
    usernameErrors usr =
          case validateUsername usr of
               Failure err  -> Failure (Error ["Invalid username:"] <> err)
               Success usr' -> Success usr'
  #+end_src

*** Gathering up the errors

- To combine the errors, we use the "...Errors" functions instead of "validate..."

  #+begin_src haskell
    makeUser :: Username -> Password -> Validation Error User
    makeUser usr pwd =
      User <$> usernameErrors usr
           <*> passwordErrors pwd
  #+end_src

*** Lists upon lists

- We want to write a function to display the Success and Error better

  #+begin_src haskell
    display :: Username -> Password -> IO ()
    display usr pwd =
      case makeUser usr pwd of
        --Failure err -> _ -- we will want to use "unlines" and "putStr" for this
        Failure err ->
           putStr $ unlines $ errorCoerce err
        Success (User (Username name) pwd') ->
           putStr $ "Welcome, " ++ name
  #+end_src

*** Coercion

- It's good that =Error= and =[String]= are different nominal types
  1) allows us to have different typeclasses for them
  2) explicit type conversions make it clear in our code,
     the points when we think of data in different light

- Coercion functions

  #+begin_src haskell
    errorCoerce :: Error -> [String]
    errorCoerce (Error err) = err
  #+end_src

*** Handling sucess

- Just adding the Success branch printing of the name "Welcome, NAME"
  by destructuring =Username= on the branch pattern matching

*** The final ~main~

#+begin_src haskell
  main :: IO ()
  main = do
    putStr "Please enter a username.\n>"
    username <- Username <$> getLine
    putStr "Please enter a password.\n>"
    password <- Password <$> getLine
    display username password
#+end_src

*** Exercises

1) Changing the type of Error from [String] to String separated by "\n"

   #+begin_src haskell
     newtype Error = Error String deriving Show
     instance Semigroup Error where
       Error x <> Error y = Failure (x ++ "\n" ++ y)
   #+end_src

2) Write a function to coerce from =String= to =Error=,
   and use it instead of constructing directly new =Error= s
   this avoids refactoring types when changing the underlying type of =Error=
   so instead of adding/removing brace[] everywhere we would just do it on the new constructor function

   #+begin_src haskell
     errorMessage :: String -> Error
     errorMessage msg = Error msg
   #+end_src

3) Because (Error []) has no meaning for us but is still type valid.
   We consider a new type for =Error=, the =Data.List.NonEmpty=.
   Which has only 1(one) constructor (:|)

   #+begin_src haskell
     > 1 :| 2 : 3 : [] -- 1 :| [2,3]
     import Data.List.NonEmpty (NonEmpty ((:|)))
     import qualified Data.List.NonEmpty as NE

     newtype Error = Error (NonEmpty String)
       deriving (Semigroup, Show) -- Semigroup is also list concatenation

     errorMessage :: String -> Error
     errorMessage msg = Error (msg :| [])

     -- putStrLn (unlines (NE.toList (errorCoerce err)))
   #+end_src

** 10 Coercible

- Instead of manually writting coercing functions like ~errorCoerce~ above.
  Or in worst situations, having to coerce newtypes that contain other newtypes.
  We will use =Coercible=.

*** Enter =Coercible=

#+begin_src haskell
  class Coercible a b where -- approximate definition
    coerce :: a -> b
#+end_src

- It's a "magic" typeclass, you do NOT need to define your own instances of it.
  But you need to import the module.

  #+begin_src haskell
    import Data.Coerce
  #+end_src

*** What can be coerced?

- simple newtypes definition like this

  #+begin_src haskell
    newtype B = N A
  #+end_src

- Will create for us instances like these, without us having to write them

  #+begin_src haskell
    instance Coercible A B where
      coerce a = N a

    instance Coercible B A where
      coerce (N a) = a
  #+end_src

*** Updating the display function

- we update the above ~display~ to use ~coerce~ for "err" on "Failure err" branch

*** Type applications

1) Using ~coerce~ might give away some /type safety/
   This type checks, but has a bug.

   #+begin_src haskell
     greet :: User -> IO ()
     greet (User password name) = -- !!
       putStrLn ("Welcome, " ++ coerce name) -- will compile, and display the actual Password :(
   #+end_src

2) is better to use explicit type applications with ~coerce~ (or other similary extremly polymorphic function)

   #+begin_src haskell
     greet :: User -> IO ()
     greet (User password name) = -- !!
       putStrLn ("Welcome, " ++ coerce @Username @String name) -- won't compile
   #+end_src

*** Coercibility is transitive

- This means that:
  + if A and B are coercible
  + and B and C coercible
  + then A and C are coercible

- this means that we can just write coerce

  #+begin_src haskell
    userPasswordCoerce' :: UserPW -> String
    userPasswordCoerce' = coerce
  #+end_src

*** Coercion in type parameters

- if types A and B are coercible, then:

  1) lists [A] and [B] are coercible
  2) tuples (A,C) and (B,C) are coercible

- As such, not all uses of ~coerce~ are sensible:

  Password -> String
  Error -> [String] -> [Password]

*** Coercing functions

- we can coercion to define a function to replace both

  - requireAlphaNumUsername :: Username -> Validation Error Username
  - requireAlphaNumPassword :: Password -> Validation Error Password

- or the more generic version we picked

  - requireAlphaNum :: String -> Validation Error String

- we create a type, to make it easier to write

  - type Rule a = (a -> Validation Error a)
  - checkPasswordLength :: Rule Password
  - checkUsernameLength :: Rule Username
  - requireAlphaNum     :: Rule String
  - cleanWhitespace     :: Rule String
  - validatePassword    :: Rule Password
  - validateUsername    :: Rule Username

#+begin_src haskell
  validatePassword :: Rule Password
  validatePassword password =
    -- coercing fn from "Rule String" to "Rule Password"
    case (coerce cleanWhitespace :: Rule Password) password of
      Failure err -> Failure err
      Success password2 ->
        -- coercing fn from "Rule String" to "Rule Password"
        (coerce requireAlphaNum :: Rule Password) password2 *>
        checkPasswordLength password2
#+end_src

** 11 Generalizing Further

- So far we showed 2 constrasts

  1) =Right= is the side of =Either= were functions like fmap and (>>=) act upon
     =Left= is the side that just tags along for the ride
  2) =Either= is the type for which (<*>) stops at the first left value
     =Validation= is the type for which (<*>) accumulates left values

- And as such we could conclude
  1) =Either a b= is not really different from =Either b a=
  2) both =Either= and =Validation= have exactly the same structure

- recommendation:
  * don't start with a generality
  * start with concrete examples
  * then observe what aspects they share

*** Designing a typeclass
*** Folding over sum types

- there are additional versions of some types or expressions in Haskell
  called ~folds~ or ~catamorphisms~

  #+begin_src haskell
    Data.Bool.bool :: a        -> a        -> Bool           -> a -- ifFalse     -> ifTrue      -> condition
    maybe          :: b        -> (a -> b) -> Maybe a        -> b -- ifIsNothing -> FN          -> Maybe a
    either         :: (a -> c) -> (b -> c) -> Either a b     -> c -- fnIfLeft    -> fnIfIfRight -> Either a b
    validation     :: (e -> c) -> (a -> c) -> Validation e a -> c
  #+end_src

- ~either~ and ~validation~ catamorphisms are identical, seems ripe for generalization

- we try a new class that defines the deconstruction of a sum type as fold

  #+begin_src haskell
    class FoldAB f where
      foldAB :: (a -> c) -> (b -> c) -> f a b -> c
  #+end_src

- instances will only need to specialize the type of the third argument,
  and can be implemented with the catamorphism already exits

  #+begin_src haskell
    instance FOldAB Either where
      foldAB = either

    instance FoldAB Validation where
      foldAB = validation
  #+end_src

- rewriting ~display~ with ~foldAB~

  #+begin_src haskell
    display :: Username -> Password -> IO ()
    display name password =
      foldAB (\err -> _ {- Print the error -})
             (\user -> _ {- Greet the user -})
             (makeUser name password)
  #+end_src

*** Desire for a generalized ~fmap~

- generalized part of ~passwordErrors~ were we "modify the failure value if there is one"

  #+begin_src haskell
    mapFailure :: (e1 -> e2) -> Validation e1 a -> Validation e2 a
    mapFailure f (Failure e) = Failure (f e)
    mapFailure _ (Success x) = Success x
  #+end_src

- rewriting ~passwordErrors~, previously written with a case

  #+begin_src haskell
    passwordErrors :: Password -> Validation Error Password
    passwordErrors password =
      mapFailure (\err -> Error ["Invalid password:"] <> err)
                 (validatePassword password)
  #+end_src

- an hipotethical ~mapSuccess~ would just be plain old ~fmap~

- ~Data.Bifunctor.first~ and ~Data.Bifunctor.second~
  - provide functions that do an "fmap" over the first or second type parameter.
  - But only work on sum types with 2(two) type parameters.

- ~Data.Validation~ instead of containing many functions like these, contains 2(two) prisms.

  #+begin_src haskell
    _Failure :: Prism (Validation e1 a) (Validation e2 a) e1 e2
    _Success :: Prism (Validation e  a) (Validation e  b) a  b
  #+end_src

*** The ~lens~ library

- add ~lens~ to .cabal and ~import Control.Lens~

- the types in the ~lens~ library are called =optics=
  - =Prism=
  - Lens
  - =Iso=
  - Traversal
  - Fold
  - Getter
  - Setter

*** The =Success= and =Failure= prisms

- Once we have
  - a /general function/ that operates on a particular "side" of a sum type,
  - a ~prism~ parameter specifies which side.

- ~over~ function is the generalization of ~fmap~ in the ~lens~ library

  1) if we pass it the =_Success= ~prism~ it behaves like ~fmap~
     #+begin_src haskell
       > over _Success (+ 1) (Success 4)
         Success 5
       > over _Success (+ 1) (Failure "x")
         Failure "x"
     #+end_src

  2) if we pass it the =_Failure= ~prism~ we will map over the failure
     #+begin_src haskell
       > over _Failure (<> "y") (Success 4)
         Success 4
       > over _Failure (<> "y") (Failure "x")
         Failure "xy"
     #+end_src

- comparison of type signatures
  #+begin_src haskell
    fmap :: Functor f     => (a -> b) -> (f a -> f b)
    over :: Prism s t a b -> (a -> b) -> (s   -> t)
  #+end_src

- differences
  1) the method of lifting "a -> b" function comes from the =Prism= value rather than the =Functor= constraint
  2) more general result

- using the ~prism~ on our ~passwordErrors~ function

  #+begin_src haskell
    passwordErrors password =
      over _Failure (\err -> Error ["Invalid password:"] <> err)
                    (validatePassword password)
  #+end_src

- =Prism= tye variable values are
  - s = Validation Error Password
  - t = Validation Error Password
  - a = Error
  - b = Error

- Is common that types s=t and a=b, so there is a type alias
  a.k.a ~simple prism~

  #+begin_src haskell
    type Prism' s a = Prism s s a a
  #+end_src

- Using the lens ~preview~ we can define ~maybeSuccess~ a ~maybeFailure~

  #+begin_src haskell
    preview _Success :: Validation e a -> Maybe a
    preview _Failure :: Validation e a -> Maybe e

    > preview _Success (Success "Hello")
      Just "Hello"
    > preview _Success (Failure ":(")
      Nothing

    > preview _Failure (Success "Hello")
      Nothing
    > preview _Failure (Failure ":(")
      Just ":("
  #+end_src

- ~preview~ can only be used with simple prisms

  #+begin_src haskell
    preview :: Prism' s a -> (s -> Maybe a)
  #+end_src

*** TODO The =Either= & =Validation= isomorphism

- ...can be represented by an =Iso= called =_Validation=

  #+begin_src haskell
    -- type Iso' s a = Iso s s a a -- two parameter, "simple" variant of Iso
    _Validation :: Iso' (Either a b) (Validation a b)
  #+end_src

- Can also be used as a parameter by ~over~

  #+begin_src haskell
    over :: Iso s t a b -> (a -> b) -> (s -> t)
  #+end_src

- Differences between =Prism'= and =Iso'=
  - A =Prism' s a= indicates that ~s~ is a sum type, and ~a~ is one of his components
  - A =Iso'   s a= indicates that ~s~ and ~a~ are merelly different representations of the same information
    (you can convert between them)

- ~view~ and ~review~ used for converting between "s" and "a"
  #+begin_src haskell
    view   :: Iso' s a -> (s -> a)
    review :: Iso' s a -> (a -> s)
  #+end_src

- isomorphism is a bit like coercibility, but differ in:
  - if two types are coercible, then they are certainly isomorphic

*** TODO The =Validate= class
*** TODO Exercises
* 21 | Book Of Monads                            | LeanPub  | Alejandro Serrano Mena

ERRATA:
119 in "String -> (Result -> IO ()) -> IO ()" Result should be Response

** 9 Resource Managment and Continuations

- the operations provided by these monads can be understood as particular cases of =continuations=
- for _resources_ that require a certain "protocol" (ME: ceremony) to be accessed
  - eg: files

*** 9.1 The Bracket Idiom

- States of a system _resource_
  1) acquisition
  2) use
  3) release

- =Control.Exception=
  #+begin_src haskell
    bracket :: IO r -> (r -> IO b) -> (r -> IO a) -> IO a
            --  v       v              v
            -- acq.   release         use
  #+end_src

- Similar pattern used in System.IO.withFile and System.IO.Temp (from =temporary= package)

*** TODO 9.2 Nicer code with continuations

- we want to avoid nested code on multiple resources
  Example: (imagine mooore resources...)
  #+begin_src haskell
    withFile inFile ReadMode $ \inHandle ->
      withFile outFile WriteMode $ \outHandle ->
        doWork inHandle outHandle
  #+end_src

- solution: using the ~Managed~ monad, from the =managed= package
  #+begin_src haskell
    runManaged $ do                                     -- block in the Managed monad
      inHandle <- managed (withFile inFile ReadMode)    -- bracket variant
      outHandle <- managed (withFile outFile WriteMode) -- bracket variant
      liftIO $ doWork inHandle outHandle                -- IO -> Managed
  #+end_src

- callbacks are =continuations=
  - you do not get to see the resulting value
  - instead you provide a function that consumes the value

*** 9.3 Early Release

- resource management with ~bracket~ also _imposes a sever restriction_, on *when* release takes place
  - it's only _AFTER_ the whole computation has finished

- however, there are times were we might want to release one of many resources before the end of *runManaged*

- resource management packages that support early release (=managed= package does not support this)
  - =resourcet= via the Resource monad
  - =pipes-safe= via the Safe monad

* 21 | Almost Standard Library                   | LeanPub  | Alejandro Serrano Mena

** 3 Utilities

- =extra= package
- Control.Monad
  #+begin_src haskell
    guard :: Alternative f => Bool -> f ()
    validatePerson first last age = do
      guard $ not (null first)
      guard $ not (null last)
      guard $ (age >= 0)
      -- ...
  #+end_src

* 21 | Haskell in Depth                          | Manning  | Vitaly Bragilevsky

- source https://github.com/bravit/hid-examples
  - GHC 8.6 or newer
  - cabal 3.0 or newer

- Author is a member of the "GHC Steering Committee"
  - https://twitter.com/VBragilevsky

- Contains:
  - Libraries: lens, singletons, servant
  - Cabal & Stack
  - Error-handling and testing
  - Pure Parallelism for multicore processors

- Preface
  - https://www.microsoft.com/en-us/research/publication/a-history-of-haskell-being-lazy-with-class/
  - https://wiki.haskell.org/Non-strict_semantics
  - https://taylor.fausak.me/2020/11/22/haskell-survey-results/
  - https://wiki.haskell.org/IDEs
  - DEPRECATED by GHCup https://www.haskell.org/platform/

- 2
  - https://en.wikipedia.org/wiki/Cayley_table to describe the structure of a finite group

** Foreward

By Simon Peyton Jones

#+begin_src haskell
  traverse :: Applicative f => (a -> f b) -> t a -> f (t b)
#+end_src

- Book exposes many of the more sophisticated parts of the language
  - typeclasses, type families
  - existentials
  - GADTs
  - type families
  - kinds
  - kind polymorphism
  - deriving
  - metaprogramming

- Explains key abstractions
  - Functor
  - Applicative
  - Traversable

- "Functional programming lets you think big thoughts. It reduce the brain-to-code
   distance by allowing you to program at a very high level."

** Preface

- Non-Strict Semantics https://wiki.haskell.org/Non-strict_semantics
  An expression language is said to have non-strict semantics if
  expressions can have a value even if some of their subexpressions do
  not.

- Components commonly discuss of a industry programming language
  1) Libraries
  2) Tooling
  3) Language features AND programming style
     + functional programming
     + static (polymorphic) typing with type inference
       * static = means that types are checked at compile type
       * polymorphic = any function entity (fn/expr/var) can have different types, depending on context being used
     + lazyness (aka non-strict semantics)
       semantics = relating to the definition of how things should behave

- =Referential transparency= https://wiki.haskell.org/Referential_transparency
  Bein able to replace a /variable/ with its /value/ without introduccing effects
- =Equational reasoning= https://wiki.haskell.org/Equational_reasoning_examples
  The ability to reason about functions and their results

- Other programming languages use the term /function/ as a synonym for /subroutine/ or /procedure/

- Th idea of introducing new types all the time contradicts the well-known programming
  principle of avoiding repetition ~DRY~. Haskell makes it easier to use types *without repeating*
  via mechanism of functions over types.
  - GADTs
  - Type Families
  - Kind Polymorphism

- Type discipline:
  - Weak type systems: we can use an integer value instead of a Bool, the compiler does NOT help
  - Dynamic Typing: we face type errors at runtime

- When we write programs relying on lazy evaluation, we don't have to know how they are
  /actually/ evaluated. (aka "declarative")

- Book uses
  - Stack for Window & Mac
  - And Cabal for Linux.

** Core Haskell
***  1 Functions and types

- Data.Text provides many functions analogous to the Data.List
  #+begin_src haskell
    toCaseFold :: Text -> Text -- analogue of "map toLower" over each String character
    dropAround :: (Char -> Bool) -> Text -> Text -- removes leading and trailing chars, that satisfy 1st fn arg
  #+end_src

- ~Data.Text.ICU~ module from ~text-icu~ package, will work moreliable to split non-english text with unicode

- Counting words on a text
**** Take 1: on the REPL

#+begin_src haskell
  > :module + Data.List Data.Char -- import a couple modules
  > text <- readFile "data/texts/hamlet.txt"
  > ws = map head $ group $ sort $ words $ map toLower text
  > take 7 ws
#+end_src

**** Take 2: on a file

#+begin_src haskell
  import Data.Char
  import Data.List (group, sort)
  import qualified Data.Text as T      -- to avoid clashes with Prelude
  import qualified Data.Text.IO as TIO -- "
  import System.Environment -- getArgs

  main = do
    [fname] <- getArgs
    text <- TIO.readFile fname
    let ws = map head
             $ group
             $ sort
             $ map T.tocaseFold
             $ filter (not . T.null)
             $ map (T.dropAround $ not . isLetter)
             $ T.words text
    TIO.putStrLn $ T.unwords ws
    print $ length ws
#+end_src

**** Take 3: on a file as many IO actions

#+begin_src haskell
  type Entry = (T.Text, Int)
  type Vocabulary = [Entry]

  extractVocab :: T.Text -> Vocabulary -- pure
  extractVocab t = map buildEntry $ group $ sort ws
    where
      buildEntry xs@(x:_) = (x, length xs)
      cleanWord = T.dropAround (not . isLetter)
      ws = map T.toCaseFold $ filter (not . T.null) $ map cleanWord $ T.words t

  printAllWords :: Vocabulary -> IO ()
  printAllWords vocab = do
    putStrLn "All words: "
    TIO.putSTrLn $ T.unlines $ map fst vocab

  processTextFile :: FilePath -> IO ()
  processTextFile fname = do
    text <- TIO.readFile fname
    let vocab = extractVocab text
    printAllWords vocab

  -- makes it easier to extend
  printWordsCount :: Vocabulary -> IO ()
  printFrequentWords :: VOcabulary -> Int -> IO ()

  main :: IO()
  main = do
    args <- getArgs
    case args of
      [fname] -> processTextFile fname
      _ -> putStrLn "Usage: vocab-builder filename"
#+end_src

**** Take 4.0: Embracing pure functions - Just the Types

#+begin_src haskell
  import Data.Text (Text)
  import qualified Data.Text as T
  import Data.Ord (comparing, Down)

  extractVocab :: Text -> Vocabulary

  -- prepares it for printing
  -- returns a Text ready to print, to be used in processTextFile
  allWordsReport :: Vocabulary -> Text
  wordsCountReport :: Vocabulary -> Text
  frequentWordsReport :: Vocabulary -> Int -> Text

  -- auxiliary functions
  allWords :: Vocabulary -> [Text]
  wordsCount :: Vocabulary -> (Int, Int)
  wordsByFrequency :: Vocabulary -> Vocabulary
  wordsByFrequency = sortBy (comparing $ Down . snd) -- reverse order

  processTextFile :: FilePath -> Bool -> Int -> IO ()
  main :: IO ()
#+end_src

**** Take 4.1: wordsCountReport without OverloadedStrings

#+begin_src haskell
  wordsCountReport :: Vocabulary -> Text
  wordsCountReport vocab = T.unlines [part1, part2]
    where
      (total, unique) = wordsCount vocab
      part1 = T.append (T.pack "Total number of words: ")
                       (T.pack $ show total)
      part2 = T.append (T.pack "Number of unique words: ")
                       (T.pack $ show unique)
#+end_src

**** Take 4.2: wordsCountReport with OverloadedStrings

#+begin_src haskell
  {-# LANGUAGE OverloadedStrings #-}
  wordsCountReport :: Vocabulary -> Text
  wordsCountReport vocab = T.unlines [part1, part2]
    where
      (total, unique) = wordsCount vocab
      part1 = T.append "Total number of words: "
                       (T.pack $ show total)
      part2 = T.append "Number of unique words: "
                       (T.pack $ show unique)
#+end_src

**** Take 4.3: wordsCountReport with OverloadedStrings + =fmt= package

+||+ to include variables and formatters, inside ("")
+||||+ to implicitly call *show* if there are not default formatters for it
A new formatters can be writting by writting  a function returning *Builder*
*nameF* - gives a name to the rest of the output
*unlinesF* - combines elements of the list into one /Builder/
*blockListF'* formats list elements into the given way, line by line

#+begin_src haskell
  import Fmt

  allWordsReport :: Vocabulary -> Text
  allWordsReport vocab =
    fmt $ nameF "All words" $ unlinesF (allWords vocab)

  wordsCountReport :: Vocabulary -> Text
  wordsCountReport vocab = fmt $
                           "Total number of words: " +|total|+
                           "\nNumber of unique words: " +|unique|+ "\n"
    where
      (total, unique) = wordCount vocab

  frequentWordsReport :: Vocabulary -> Int -> Text
  frequentWordsReport vocab num =
    fmt $ nameF "Frequent words"
        $ blockListF' "" fmtEntry reportData
    where
      reportData = take num $ wordsByFrequency vocab
      fmtEntry (t,n) = ""+|t|+": "+|n|+""
#+end_src

**** Take 4.4: IO() impure function - processTextFile

#+begin_src haskell
  processTextFile :: FilePath -> Bool -> Int -> IO ()
  processTextFile fname withAllWords n = do
    text <- TIO.readFile fname
    let vocab = extractVocab text
    when withAllWords -- from the Control.Monad module
      $ TIO.putStLn $ allWordsReport vocab
    TIO.putStrLn $ wordsCountReport vocab
    TIO.putStrLn $ frequentWordsReport vocab n
#+end_src

#+begin_src haskell
  main :: IO ()
  main = do
    args <- getArgs
    case args of
      ["-a", fname, num] -> processTextFile fname True (read num)
      [fname, num]       -> processTextFile fname False (read num)
      _                  -> putStrLn "Usage: vocab3 [-a] filename freq_words_num"
#+end_src

***  2 Type classes

- Typeclass
  - defined with respect to some /type variable/
  - it contains a collection of methods, given by type signatures
  - we can define as many instances (of a /typeclass/), or implementations, for specific types as needed

- Problem:
  - A radar antenna, a device with the ability to be /oriented/ toward 4 points of direction.
  - Input
    - List of turns, and an initial direction. Outputs list of directions.
    - List of directions. Outputs list of turns.

**** Coding: Radar Antenna
***** Step 1: overview with types only

#+begin_src haskell
  data Direction = North | East | South | West
    deriving (Eq, Enum, Bounded, Show) -- later adding CyclicEnum, Read, Ord
  data Turn = TNone | TLeft | TRight | TAround
    deriving (Eq, Enum, Bounded, Show)

  -- basic ops
  rotate :: Turn -> Direction -> Direction
  orient :: Direction -> Direction -> Turn

  -- over lists
  rotateManySteps :: Direction -> [Turn] -> [Direction]
  rotateMany :: Direction -> [Turn] -> Direction
  orientMany :: [Direction] -> [Turn]

  -- file processing
  rotateFromFile :: Direction -> FilePath -> IO ()
  orientFromFile :: FilePath -> IO ()
  main :: IO ()
#+end_src

***** Step 2: deriving custom typeclass for cycles

Then derived on data types using =DeriveAnyClass= GHC extension

#+begin_src haskell
  class CyclicEnum a where
      cpred :: a -> a
      cpred d
        | d == minBound = maxBound
        | otherwise = pred d
      csucc :: a -> a
      csucc d
        | d == maxBound = minBound
        | otherwise = succ d
#+end_src

***** Step 3: ~rotate~ definition - using custom new typecass methods

#+begin_src haskell
  rotate :: Turn -> Direction -> Direction
  rotate TNone   = id
  rotate TLeft   = cpred
  rotate TRight  = csucc
  rotate TAround = cpred . cpred
#+end_src

***** Step 4: ~orient~ definition - using Enum/Bounded

#+begin_src haskell
  [TNone, TLeft, TRight, TAround]
  [TNone..TAround]     -- due Enum
  [minBound..maxBound] -- due Bounded

  every :: (Enum a, Bounded a) => [a]
  every = enumFrom minBound -- due Enum & Bounded
#+end_src

Now writting =orient= using every

#+begin_src haskell
  orient :: Direction -> Direction -> Turn
  orient d1 d2 = head $ filter (\t -> rotate t d1 == d2) every
#+end_src

***** Step 5: defining list functions - using stdlib list functions

#+begin_src haskell
  rotateMany :: Direction -> [Turn] -> Direction
  rotateMany = foldl (flip rotate)

  rotateManySteps :: Direction -> [Turn] -> [Direction]
  rotateManySteps = scanl (flip rotate) -- like foldl but returns the list of "reductions"

  orientMany :: [Direction] -> [Turn]
  orientMany ds@(_:_:_) = zipWith orient ds (tail ds)
  orientMany _          = []
#+end_src

***** Step 6: combining 2 turns as a binary op - using =Semigroup/Monoids=

- This code will result in the below returning TNone
  mconcat [TLeft, TRight, TAround, TAround]

#+begin_src haskell
  instance Monoid Turn where
    mempty = TNone

  instance Semigroup Turn where
    TNone   <> t       = t
    TLeft   <> TLeft   = TAround
    TLeft   <> TRight  = TNone
    TLeft   <> TAround = TRight
    TRight  <> TRight  = TAround
    TRight  <> TAround = TLeft
    TAround <> TAround = TNone
    t1      <> t2      = t2 <> t1 -- commutative
#+end_src

***** Step 7: redefining ~rotateMany~ with mconcat

#+begin_src haskell
  rotateMany' :: Direction -> [Turn] -> Direction
  rotateMany' dir ts = rotate (mconcat ts) dir
#+end_src

***** Step 8: ~read~ input file

#+begin_src haskell
  do
    f <- readFile fname
    let dirs = map read $ lines f
#+end_src

***** Step 9: using =fmt= package with our custom type

#+begin_src haskell
  instance Buildable Direction where
    build North = "N"
    build East  = "E"
    build South = "S"
    build West  = "W"

  instance Buildable Turn where
    build TNone   = "--"
    build TLeft   = "<-"
    build TRight  = "->"
    build TAround = "||"
#+end_src

***** Step 10: defining ~rotateFromFile~ using both =Show/Buildable=

#+begin_src haskell
  rotateFromFile :: Direction -> FilePath -> IO ()
  rotateFromFile dir fname = do
    f <- readFile fname
    let turns = map read $ lines f
        finalDir = rotateMany dir turns
        dirs = rotateManySteps dir turns
    fmtLn $ "Final direction: "+||finalDir||+"" -- using Show instance
    fmt $ nameF "Intermediate directions" (unwordsF dirs) -- using Buildable Instance
#+end_src

***** Step 11: main

$ cabal run radar -- -r data/turns.txt North
$ cabal run radar -- -o /data/dirs.txt

#+begin_src haskell
  main :: IO ()
  main = do
    args <- getArgs
    case args of
      ["-r", fname, dir] -> rotateFromFile (read dir) fname
      ["-o", fname] -> orientFromFile fname
      _ -> putStrLn $ "Usage: locator -o filename\n" ++
                      "       locator -r filename direction"
#+end_src

**** Coding: Testing Radar Antenna

***  3 Developing and application: Stock quotes
** Introduction to Application Design
***  4 Haskell development with modules, packages, and projects
***  5 Monads as practical functionality providers
***  6 Structuring programs with monad transformers
** Quality Assurance
***  7 Error handling and logging
***  8 Writing tests
***  9 Haskell data and code at run time
*** 10 Benchmarking and profiling
** Advanced Haskell
*** 11 Type system advances
*** 12 Metaprogramming in Haskell
*** 13 More about types
** Haskell Toolkit
*** 14 Data-processing pipelines
*** 15 Working with relational databases
*** 16 Concurrency
* 21 | Haskell Tutorial and Cookbook             |          | Mark Watson
** 1

- length of tuples will always be one (1)

* 22 | Practical Haskell                         | Apress   | Alejandro Serrano Mena

source https://github.com/Apress/practical-haskell
- Packages https://hackage.haskell.org/
- Packages https://www.stackage.org/ (subset of hackage)
- library https://www.yesodweb.com/book/persistent
- Package Version Policy https://pvp.haskell.org/
- Encyclopedia of Typeclasses https://wiki.haskell.org/Typeclassopedia

** 1 Going Functional

- Haskell:
  1) Functional
  2) Purity, separates code with side-effects
     - Expressions in haskell cannot have side effects by defaults. Are called pure.
     - Referential Transparency: https://en.wikipedia.org/wiki/Referential_transparency
       - If code can be replaced with their corresponding value (and vice-versa) without changing the program's behavior.
       - Requires a function to be pure.
  3) Laziness, *evaluation model*
  4) Statically Checked
     - Java and C#, need to perform extra _type checking at runtime_
     - Haskell, no more type checks are done once the program has been compiled. Increases Performance.
     - Type-Oriented Programming: programmers know the type of the functions they are developing and have a broad idea of the structure of the code then they fill the holes with expressions from the surrounding environment
  5) Polimorphism
     - based on *parametricity* (like generics in Java and C#) (templates on c++?)
     - and *type classes* which groups different types witha common interface
- 1980 - Miranda was one of the most important lazy functional programming languages
- Haskell Versions: 98, 10

** 2 Declaring the Data Model

*** Characters, Numbers and Lists

- Data: Clients, Machines and Orders
- "Sometimes, ADTs and pattern matching lead to code that's not clear enough. Records introduce some syntactic forms that make values easier to create and modify"
- Haskell does not make numeric constants of a specific type.
  Uses =Num= and =Fractional=. Which are polymorphic.
- Like in most functional languages, lists in Haskell are *linked lists*
- Lists of lists do not need to be of the same dimension, so they are not equivalent to arrays of multiple dimensions.
  [] and [[]] are NOT equivalent

*** Creating a New Project (and module)

|-------+----------------------------------+--------------+-------------+----------|
| name  | goals and features               | installation |             | repo     |
|-------+----------------------------------+--------------+-------------+----------|
| cabal |                                  | no           | name.cabal  | Hackage  |
| stack | reproducible builds + versioning | yes          | +stack.yaml | Stackage |
|-------+----------------------------------+--------------+-------------+----------|

- .cabal
  - case insensitive property name
  - stanzas begin with a header (eg: library or executable)

- modules in Haskell
  - similar to packages in Java or namespaces in C#
  - each modulo defined on his own file
  -        Chapter2.Section2.Example goes in
  -   path Chapter2/Section2/Example.hs
  - module Chapter2.Section2.Example where

*** Defining Simple Functions

- tuples of different lengths are completely different types
- src/Chapter2/SimpleFunctions.hs
  #+begin_src haskell
    {- Multiline
       Comment -}
    firstOrEmpty :: [[Char]] -> [Char] -- Single Line Comment
    firstOrEmpty lst = if not (null lst) then head lst else "empty"
  #+end_src
- Use *local binding* to avoid recomputation
  - let vs where
    - let bindings before the main expressions, must end with an "in"
    - where does after the expression
- Haskell uses a *layout-based syntax*
- group blocks {;;}, discouraged!!!!
  #+begin_src haskell
    where { t = maxmin (tail list); t_max = fst t ; t_min = snd t }
  #+end_src
- ADTs, must have
  1) have a name
  2) a set of constructors
- Example: 3 different kinds of clients, using *auto-deriving* for Show
  #+begin_src haskell
    -- Goverments: need a name
    -- Companies: need a id number, contact person, position of the contact
    -- Individuals: name, surname, if they want spam
    data Client = GovOrg     String
                | Company    String Integer Person String
                | Individual Person Bool
                deriving Show
    data Person = Person String String Gender
                deriving Show
    data Gender = Male | Female | Unknown
                deriving Show
  #+end_src
- Types, constructors, type classes, and kinds must start with an UPPERCASE letter
- Inside a module all constructors MUST have a *different name*
- Data Types and Constructors live in *different namespaces* (? worlds
- All *types inside* a "showable" must derive Show too
- Functions that are not defined over the complete domain of their arguments are called *partial*

*** Working With Data Types

- Pattern Matching does *NOT backtrack* when something goes wrong in the body of a match

- You can pattern match on *let* and *where* BUT with only 1 pattern
  - instead of
    #+begin_src haskell
      let name = case companyName client of
                   Just n -> n
    #+end_src
  - with let pattern matching
    #+begin_src haskell
      let Just name = companyName client
    #+end_src
  - where
    #+begin_src haskell
      maxmin [x]    = (x,x)
      maxmin (x:xs) = ( if x > xs_max then x else xs_max
                      , if x < xs_min then x else xs_min
                      ) where (xs_max, xs_min) = maxmin xs
    #+end_src

- Haskell conventions
  + to write the ~pattern matching~ on lists using a letter or a small word followed by the same identifier in plural
    - like "x" and "xs"
    - or "x:y:zs"
  + to use the same identifier, but with (') (pronounced prime) afterward, to refer to a highly related binding
  + With ~guards~, using *otherwise* in the last pattern, when using guards is a common convention
    - Although it does NOT do anything

**** =as pattern=, allows you to *bind* some value in the match, while at the same time allowing you to match on inner components
  #+begin_src haskell
    -- instead of
    sorted []       = True
    sorted [_]      = True
    sorted (x:y:zs) = x < y && sorted (y:zs)
    -- you can use the "as patternW
    sorted []            = True
    sorted [_]           = True
    sorted (x : r@(y:_)) = x < y && sorted r
  #+end_src
**** =Guards!=
  - Anything that returns Boolean can be used, including our custom functions
  - A compact syntax can be used for checking several conditions on the same argument
    #+begin_src haskell
      specialMultiples n
        | multipleOf n 2 = show n ++ " is multiple of 2"
        | otherwise      = show n ++ " is a beautiful number"
      -- Instead of
      specialMultiples n | multipleOf n 2 = show n ++ " is multiple of 2"
      specialMultiples n | otherwise      = show n ++ " is a beautiful number"
    #+end_src
**** =View Patterns= (extension) to preprocess the value before matching
  function -> pattern
  which applies *function* to the value AND then matches the result with the *pattern*
  needs a *pragma*
  #+begin_src haskell
    {-# LANGUAGE ViewPatterns #-} -- in ghci do ":set -XViewPatterns"
    responsability :: Client -> String
    responsability (Company _ _ _ r) = r
    responsability _                 = "Unknown"

    specialClient :: Client -> Bool
    specialClient (clientName -> "Mr. Alejandro") = False
    specialClient (responsability -> "Director")  = True
    specialClient _                               = False
  #+end_src
**** =Records=

- Regular Pattern matching on big structure may get unwierdly quickly, because:
  1) it forces to write long matches to retrieve just a single value
  2) and to re-create entire data structure merely to change just a single field

- *Defining* using data declarations
  #+begin_src haskell
    data ClientR = GovOrgR  { clientRName :: String }
                 | CompanyR { clientRName :: String
                            , companyId :: Integer
                            , person :: PersonR
                            , duty :: String }
                 | IndividualR { person :: PersonR }
                 deriving Show

    data PersonR = PersonR { firstName :: String
                           , lastName :: String
                           } deriving Show
  #+end_src

- *Create*
  #+begin_src haskell
    GovOrgR "NATO" -- passing the values directly OR
    IndividualR { person = PersonR { lastName = "Smith", firstName = "John" } }
  #+end_src

- *Access*, special functions are automatically created to access those particular fields
  #+begin_src haskell
    >>> clientRName (GovOrgR "NATO")
      "NATO"
    >>> :t duty
      duty :: ClientR -> String
  #+end_src

- *Pattern Matching*, does NOT need a binding or pattern for *each field* in it.
  #+begin_src haskell
    greet :: ClientR -> String
    greet IndividualR { person = PersonR { firstname = fn } } = "Hi, " ++ fn
    greet CompanyR    { clientRName = c }                     = "Hi, " ++ c
    greet GovOrgR     { }                                     = "Welcome"
  #+end_src

- *Pattern Matching* =record puns=, creates a binding for the correspinding field availble *with the same name* in the body of hte match.
  #+begin_src haskell
    {-# LANGUAGE NamedFieldPuns #-}
    greet IndividualR { person = PersonR { firstname } } = "Hi, " ++ firstName
    greet CompanyR    { clientRName }                    = "Hi, " ++ clientRName
    greet GovOrgR     {  }                               = "Welcome"
  #+end_src

- *Pattern Matching* automatically create bindings (..), while making some field obey a pattern
  #+begin_src haskell
    {-# LANGUAGE RecordWildCards #-}
    greet IndividualR { person = { PersonR { .. } } = "Hi, " ++ firstName
    greet CompnayR    { .. }                        = "Hi, " ++ clientRName
    greet GovOrgR     { }                           = "Welcome"
  #+end_src

- *Updating* a record field
  #+begin_src haskell
    import Data.Char (toUpper)
    nameInCapitals :: PersonR -> PersonR
    nameInCapitals p@(PersonR { firstName = initial:rest }) =
      let newName = (toUpper initial):rest
      in p { firstName = newName } -- UPDATE!!!
    nameInCapitals p@(PersonR { firstName = "" }) =
      p
  #+end_src

- Use case: *Default* values for functions calls.
  Instead of writing a function with a lot of arguments. Use a *record* for the default arguments.
  Provide this record as *constant* with sensible defaults.
  Changing defaults would mean just a record *update* as seen before
  Is better for maintainability, to forbid calling the constructor directly, forcing the use of the constant.
  #+begin_src haskell
    data ConnType = TCP | UDP
    data UseProxy = NoProxy | Proxy String
    data TimeOut  = NoTimeOut | TimeOut Integer
    data Connection = ... -- Definition ommited
    data ConnOptions = ConnOptions { connType      :: ConnType
                                   , connSpeed     :: Integer
                                   , connProxy     :: UseProxy
                                   , connCaching   :: Bool
                                   , connKeepAlive :: Bool
                                   , connTimeOut   :: Timeout
                                   }

    connect' :: String -> ConnOptions -> Connection
    connect' url options = ...

    connDefault :: ConnOptions
    connDefault = ConnOptions TCP 0 NoProxy False False NoTimeout

    >>> connect' "https://apress.com" connDefault { connType = UDP }
  #+end_src

**** Exercise on Guards: Binomial Coeficient
- of n and k
- This coefficient gives the *number of ways* in  which you can get =k= balls from a bag of =n= without repetition
- Solution: Using Pascal's Triangle
- ERROR: Without guards
  #+begin_src haskell
    binom _ 0 = 1
    binom x x = 1 -- ERROR: variables can appear only once
    binom n k = (binom (n-1) (k-1)) + (binom (n-1) k)
#+end_src
- With guards
  #+begin_src haskell
    binom _ 0          = 1
    binom x y | x == y = 1
    binom n k          = (binom (n-1) (k-1)) + (binom (n-1) k)

    ifibonacci n | n < 0 = Nothing
    ifibonacci 0         = Just 0
    ifibonacci 1         = Just 1
    ifibonacci n | otherwise = let Just f1 = ifibonacci (n-1)
                                   Just f2 = ifibonacci (n-2)
                               in Just (f1 + f2)
  #+end_src
**** Exercise 2-5: More Type Of Values
#+begin_src haskell
  data TimeMachine = TimeMachine String Int String Bool Bool Float
                   deriving Show
#+end_src
**** Exercise 2-5: The perfect match for your machines
- Write a function that return the number of clients of each gender
  #+begin_src haskell
    data Result = Result Int Int Int
      deriving Show

    gender2Result :: Gender -> Result
    gender2Result Male    = Result 1 0 0
    gender2Result Female  = Result 0 1 0
    gender2Result Unknown = Result 0 0 1

    addResult :: Result -> Result -> Result
    addResult (Result m1 f1 u1) (Result m2 f2 u2) =
       Result (m1+m2) (f1+f2) (u1+u2)

    clientsPerGender :: [Client] -> Result
    clientsPerGender []                                       = Result 0 0 0
    clientsPerGender (GovOrg _) : xs                          = clientsPerGender xs
    clientsPerGender (Company _ _ (Person _ _ gender) _) : xs = addResult (clientsPerGender xs) $ gender2Result gender
    clientsPerGender (Individual (Person _ _ gender) _)  : xs = addResult (clientsPerGender xs) $ gender2Result gender
  #+end_src

- sale-off price of timemachines
  #+begin_src haskell
    saleOffPrice :: [TimeMachine] -> Float
    saleOffPrice []                                 = 0.0
    saleOffPrice (TimeMachine _ _ _ _ _ price) : xs = (price * 0.9) + saleOffPrice
  #+end_src
**** Exercise 2-6: More Matches and Guards
#+begin_src haskell
  ackerman :: Int -> Int -> Int
  ackerman 0 n                  = n + 1
  ackerman m 0 | m > 0          = ackerman (m-1) 1
  ackerman m n | m > 0 && n > 0 = ackerman (m-1) $ ackerman m (n-1)

  gunzip :: [(a,b)] -> ([a],[b])
  gunzip []           = ([],[])
  gunzip ((a,b) : xs) = (a : as, b : bs)
    where (as,bs) = gunzip xs
#+end_src
**** Exercise 2-7: Time Machine Records
#+begin_src haskell
  {-# LANGUAGE NamedFieldPuns #-}
  data TimeMachine = TimeMachine { manufacturer :: String
                                 , model        :: Int
                                 , name         :: String
                                 , backwards    :: Bool
                                 , forwards     :: Bool
                                 , price        :: Float
                                 } deriving Show

  saleOffPrice :: [TimeMachine] -> Float
  saleOffPrice []                           = 0.0
  saleOffPrice (TimeMachine { price }) : xs = (price * 0.9) + saleOffPrice xs
#+end_src
** 3 Increasing Code Reuse

*** Parametric Polymorphism

- Etymology
  multiple = poly
  types    = morphé is Ancient Greek for "shape"

- =Ad-Hoc Polymorphism= allows for functions to be applicable for just a subset of all types

- Polymorphism is also available in data types

  - Example: in tuples, you have multiple type variables
    #+begin_src haskell
      data Triple a b c = Triple a b c
      data SamePair a = SamePair a a
    #+end_src

  - Example: where the "clientId" can take many shapes
    #+begin_src haskell
      data Client i = GovOrg  { clientId :: i, clientName :: String }
                    | Company { clientId :: i, clientName :: String
                              , person :: Person, duty :: String }
                    | Individual { clientId :: i, person :: Person }
                    deriving (Show, Eq, Ord)

      data Person = Person { firstName :: String, lastName :: String }
                  deriving (Show, Eq, Ord)
    #+end_src
*** Funtions As Parameters (HoF)

- ($) both sides of this operator will be evaluated before f is applied to a.
  Therefore, you can omit a lot parentheses.

  #+begin_src haskell
    f $ a = f a
  #+end_src

- =Anonymous functions= are sometimes called "lambda abstractions" or simply "abstractions"
  - Recursion is forbidden
  - only 1(one) pattern can be matched (like on let/where?)
    - Unless you are using GHC LambdaCase extension
      #+begin_src haskell
        {-# LANGUAGE LambdaCase #-}
        sayHello names = map (\case "Alejandro" -> "Hello, writer"
                                    name        -> "Welcome, " ++ name
                             ) names
      #+end_src
- =Section= is just a specification, careful of commutativity and where you put the operator.
  double = map (*2)
- =Partial application= encourages a programming style where functions are combined without ever mentioning their parameters.
  This is called *point-free style* (because in mathematic, parameters to functios are called points)
- =Combinators= functions:
  #+begin_src haskell
    uncurry :: (a -> b -> c) -> (a,b) -> c
    uncurry f = \(x,y) ->

    curry :: ((a,b) -> c) -> a -> b -> c
    curry f = \x y -> f (x,y)

    flip :: (a -> b -> c) -> (b -> a -> c)
    flip f = \x y -> f y x
  #+end_src
  - from multiple-argument functions to single-argument functions which take a tuple of values.
  - =Curried=: functions that take a sequence of arguments
  - Use Case: you are given a list of pairs of numbers, and you cant to get the list of maximums of pairs.
    #+begin_src haskell
      > map (uncurry max) [(1,2),(2,1),(3,4)]
        [2,2,4]
    #+end_src
**** Exercise 3.2 - Working With Filters
#+begin_src haskell
  {-# LANGUAGE LambdaCase #-}
  filterOnes :: [Int] -> [Int]
  filterOnes = filter ((==) 1)

  filterANumber Int -> [Int] -> [Int]
  filterANumber n = filter ((==) n)

  filterNot :: (a -> Bool) -> [a] -> [a]
  filterNot f = filter (not . f)

  isGovOrg :: Client -> Bool
  isGovOrg (GovOrg _) = True
  isGovOrg _          = False

  filterGovOrgs :: [Client] -> [Client]
  filterGovOrgs = filter isGovOrg

  filterGovOrgs :: [Client] -> [Client]
  filterGovOrgs = filter (\case (GovOrg_) -> True
                                 _        -> False)
#+end_src
*** More Modules (exporting/importing)
- After the *module* declaration but before any other definitions
 | All Functions  | import Data.List                             | Do not bring into scope child modules |
 | explicit       | import Data.List (permutations, subsequence) |                                       |
 | hiding imports | import Data.List hiding (head, tail)         |                                       |
 | data types     | import Chapter3.ParamPoly (Client())         | only type, no constructors            |
 |                | import Chapter3.ParamPoly (Client(GovOrg))   | a subset of construct(s)              |
 |                | import Chapter3.ParamPoly (Client(..))       | all constructors                      |
 | qualified      | import qualified Data.List (filter)          | use it as Data.List.filter            |
 | renaming       | import qualified Data.List as L              | use it as L.filter                    |
 | e+q+r          | import qualified Data.List as L(filter)      |                                       |
- NoImplicitPrelude
- By default every single declaration is exported
- eg: export only "f" declaration
  #+begin_src haskell
    module M (f) where
    f = ...
    g = ...
  #+end_src
- eg: only export data type and default
  #+begin_src haskell
    module Chapter2.DataTypes (ConnOptions(), connDefault) where -- the Data Type and the constant
  #+end_src
**** =Smart Constructors=, hidding the constructors and giving the data type
  the idea is to provide a function that acts as the constructor and checks for invariants on the creation of the data types
  - Try 1: we fail to provide pattern match, since we don't export the constructor
   #+begin_src haskell
     module Chapter3.Ranges (Range(), range) where
     data Range = Range Integer Integer deriving Show
     range :: Integer -> Integer -> Range
     range a b = if a <= b then Range a b else error "a must be <= b"
  #+end_src
  - Try 2: create a *new data type* that encodes the observed value of that type.
    #+begin_src haskell
      data RangeObs = R Integer Integer deriving Show
      r :: Range -> RangeObs
      r (Range a b) = R a b
    #+end_src
    And then use =views= when pattern matching.
    #+begin_src haskell
      {-# LANGUAGE ViewPatterns #-}
      prettyRange :: Range -> String
      prettyRange rng = case rng of
                          (r -> R a b) -> "[" ++ show a ++ "," ++ show b ++ "]"
    #+end_src
  - Try 3: Create a =pattern synonym= which packages this form of building/deconstructing Range values
    Using a =bidirectional pattern=
    #+begin_src haskell
      {-# LANGUAGE PatternSynonyms #-}
      pattern R :: Integer -> Integer -> Range -- 1) coincides with the Range constructor
      pattern R a b <- Range a b               -- 2) the matcher, the equivalences
        where R a b = range a b                -- 3) makes it equivalent to the function call (range) our smart-constructor
    #+end_src
*** Diving into Lists (foldr,comprehensions)
- {} pattern can be used for matching a constructor regardless of the datatype elements.
- Individual{person = p1}
- can use *where* to define functions
  #+begin_src haskell
    companyDUtiesAnalytics :: [Client a] -> [String]
    companyDutiesAnalytics = map (duty . head) .
                             sortBy (\x y -> compare (length y) (length x)) .
                             groupBy (\x y -> duty x == duty y) .
                             filter isCompany
      where isCompany (Company {}) = True
            isCompany _            = False
  #+end_src

- The *initial* value on foldr, is also called *neutral* or *identity element* of the operation.

- Example: maximum, we define:
  1) a new polymorphic type to support infinity
  2) an initial value, considering the max of an empty list (the MinusInfinity), and the it shouldn't change the value of binary operation
  #+begin_src haskell
    data InfNumber a = MinusInfinity
                     | Number a
                     | PlusInfinity
                     deriving Show

    infMax :: InfNumber -> InfNumber
    infMax MinusInfinity x       = x
    infMax x MinusInfinity       = x
    infMax PlusInfinity _        = PlusInfinity
    infMax _ PlusInfinity        = PlusInfinity
    infMax (Number a) (Number b) = Number (max a b) -- call to max

    foldr infMax                        MinusInfinity [1,2,3] -- Error
    foldr infMax                        MinusInfinity $ map Number [1,2,3]
    foldr (\x y -> infMax (Number x) y) MinusInfinity [1,2,3]
  #+end_src

- ranges
  #+begin_src haskell
    withPositions list = zip [1 .. length someList] list
  #+end_src

**** foldr1 or foldl1
  - they do NOT take an intial value, but they take it from the first/last element of the list
    - used then handling an empty list is guarenteed not to happen
  - are know as "reduce" in other languages
  - example maximum
    #+begin_src haskell
      maximum' :: [Integer] -> Integer
      maximum' = foldr1 max
    #+end_src
**** Data.List
| partition     | on Data.List, returns a tuple of filter/(not filter)                       |               |
| find          | returns Maybe                                                              |               |
| dropWhile     | returns a list *from* the point in which predicate becomes False           |               |
| takeWhile     | returns a list of the initial elements *until* the predicate becomes False |               |
| span          | returns a tuple of dropWhile/takeWhile                                     |               |
| break         | like span, but negates the predicate first                                 |               |
| any           | "exists"                                                                   |               |
| all           | "for all"                                                                  |               |
|---------------+----------------------------------------------------------------------------+---------------|
|               | BINARY PREDICATES                                                          |               |
|---------------+----------------------------------------------------------------------------+---------------|
| nubBy         | returns a list, takes out elements, so no two elements are equivalent      |               |
| nub           | works with the default comparison of the type                              |               |
| union(By)     | from 2 lists                                                               |               |
| intersect(By) | from 2 lists                                                               |               |
| insert(By)    | adds one elements to a set,                                                |               |
| (\\)          | set difference                                                             |               |
| elem          | if element is on a list, boolean                                           |               |
|---------------+----------------------------------------------------------------------------+---------------|
| groupBy       | put 2 elements in the same group if True                                   | Data.List     |
| on            | when 2 elements are compared, AFTER using a functions                      | Data.Function |
| flip          | calling a 2-parameter functions with the arguments reversed                |               |
|---------------+----------------------------------------------------------------------------+---------------|
| zip           |                                                                            |               |
| unzip         |                                                                            |               |
| lookup        | Maybe associative list lookup                                              |               |
|               |                                                                            |               |
**** Ordering (sortBy,sort,compare)
- When *compare* function is defined, Haskell also provides impplementationd of the >,<,>=,<= operators
- Some types already come defined with adefault way in which to otder values.
  - numbers, characters
  - tuples, lists: if their contained elements have default comparison. Lexicographicly. Smaller lists first.
- For both clarity and performance reasons, ordering in haskell is NOT defined by returning a Bool,
  but by returning and *Ordering* Value. Which can be LT, EQ, GT.
  - Example: Ordering Clients by type and name
    #+begin_src haskell
      > sortBy compareClient listOfClients
      > sort [1,4,2,-3]
      > compare (1,2)                 => GT
      > compare "Hello" "Hello world" => LT
      > compare "This" "That"         => GT
      compareClient :: Client a -> Client a -> Ordering
      compareClient (Individual{person = p1}) (Individual{person = p2})
                                      = compare (firstName p1) (firstName p2)
      compareClient (Individual {}) _ = GT
      compareClient - (Individual {}) = LT
      compareClient c1 c2             = compare (clientName c1) (clientName c2)
    #+end_src
**** List Comprehensions
- They can be understand, either as a:
  - set expression
  - SQL expression
  - quey expression in C# 3.0
- Has 2 parts separated by (|) and wrapped by []
  1) =Expression=: defines the transformation sot apply
  2) =Qualifiers=: from whence the elements will come, and the contraints upon them
#+begin_src haskell
  dupicateOdds list = [ 2 * x | x <- list, odd x]
  -- generators can have a PATTERN stating that only values matching it will be included
  [ clientName x | x@(GovOrg _ _) <- listOfClients ]
  -- Might depends on other value in the comprehension
  [(x,y) | x <- [0 .. 6], y <- [x .. 6]]
  -- LIST OF LIST, might appear on the right hand side of the generator
  import Data.Char
  [ toUpper c | s <- ["A","list"], c <- ' ':s ]
  -- LET expressions, for readability of the code
  [ sqrt v | (x,v) <- [(1,2),(3,8)], let v = x*x+y*y ]
  -- GUARDS, are just a call to a predicate. Only those elements satisfying the guard will go in.
  [(x,y) | x <- [1 .. 6], y <- [1 .. 6], x <= y]
  -- EXTENSION, :set -XTransformListComp
  -- then (f), transforms the input list by applying the function to the result of the comprehension
  [x*y | x <- [-1,1,-2], y <- [1,2,3], then reverse ]
  -- then (f) by (v), transforms the list depending on the values in (v)
  import GHC.ext -- for sortWith
  [x*y | x <- [-1,2,-2], y <- [1,2,3]
       , then sortWith by x ]
  -- group by (e) using (f)
  -- In many cases, all grouped elements will be equal, so GHC provies a THE function that takes just 1 element form the list
  import GHC.ext -- for groupWith
  [ (the p, m) | x <- [-1,2,-2]
               , y <- [1,2,3]
               , let m = x*y
               , let p = m > 0
               , then group by p using groupWith ]
  -- PARALLEL Comprehension
  -- :set -XParallelListComp
  -- More than 1(one) branch of qualifiers can be stated, separated by (|)
  -- Instead of nesting iterations, the result of all branches will be "zipped"
  [ x*y | x <- [1,2,3] | y <- [1,2,3] ] -- [1,4,9]
#+end_src
***** Example
#+begin_src haskell
  companyAnalytics :: [Client a] -> [(String, [(Person, String)])]
  companyAnalytics clients = [ (the clientName, zip person duty)
                             | client@(Company { .. }) <- clients
                             , then sortWith by duty
                             , then group    by clientName using groupWith
                             , then sorWith  by length client
                             ]
#+end_src
**** TODO Exercise 3.3 - Your first folds
#+begin_src haskell
  -- Pattern Matching
  product :: [Integer] -> Integer
  product []     = 1
  product (x:xs) = x * product xs

  clientLength :: Client -> Integer
  clientLength GovOrg name                      = length name
  clientLength Company name _ _ _               = length name
  clientLength Individual (Person name _ _ _) _ = length name

  minimumClient :: [Client] -> Client
  minimumClient client : cs = min (clientLength client) $ minimumClient cs

  all :: [Bool] -> Bool
  product []     = True
  product (x:xs) = x && product xs
  -- folds
  product :: [Integer] -> Integer
  product = foldr1 (*)
  minimumClient :: [Client] -> Client
  all :: [Bool] -> Bool
  all = foldr1 (&&)
#+end_src
*** Haskell Origami (unfold)
- You can write almost all list functions using foldr
- How to ensure that one function using pattern matching and other using fold are equivalent?
  - =Induction= & =Equational Reasoning=
    - a technique for formally verifying code that manipulates equations between functions.
    - prove that works the same way for the *base case* (the empty list)
    - prove that they are equal for "xs", as well as for "x:xs", the *inductive step*
- Can define in terms of fold: filter, map
- =fusion law= for maps
  map f . map g = map (f . g)
**** unfoldr :: (b -> Maybe (a,b)) -> b -> [a]
- create a lists out of some seed
- *Nothing* signals that it should stop producing elements
  *Just (x,s)* attaches (x) to the new list, AND continues to process with a new seed (s)
- Example: enumUnfold
  #+begin_src haskell
    enumUnfold :: Int -> Int -> [Int]
    enumUnfold n m = unfoldr (\x -> if x > m then Nothing else Just (x, x+1)) n
  #+end_src
- Example: minSort
  #+begin_src haskell
    minSort :: [Integer] -> Integer
    minSort = unfoldr (\case [] -> Nothing
                             xs -> Just (m, delete m xs) where m = minimum xs)
  #+end_src
*** Summary
** 4 Using Containers and Type Classes

*** Using Packages

- A ~package~ is the *distribution unit of code* understood by Cabal and Stack
  - It includes a set of modules

- Stackage provides *snapshots* of Hackage (called *resolvers*) in which all pacakges are know to work well together.
  - Provides reproducibility
  - At the expense of not always containing the bleeding-edge version of the packages

- Add packages to =build-depends= property on your .cabal file
  - Can add it to both the "library" or in "executable" *stanzas*

- =Rule of Thumb=
  - add constraint requiring the MINIMUM version where you know that your package compiles and runs.
  - and another constraint to limit future versions to the next MAJOR one
  #+begin_src
    containers >= 0.6.0.1 && 0.7
  #+end_src

- Package Versioning Policy
  1) If any Function/DataType/TypeClass/Instance has been changed or its type or behavior removed,
     the major version (a.b) must be increased.
  2) Otherwise, for additions you can just increase the remaining components (x.x.c.d).
     Except in the case of a likely conflict with a module in another package

**** Cabal

- How to: Develop several packages at the same time, one depending of the other.
  - Avoids "global mutation" of packages
  - Put all the packages in a common folder
  - Create a ~cabal.project~ file
    packages: chapter4 wonderful
  - Build 1(one) package:
    $ cabal new-build chapter4
    $ cabal new-build wonderful

*** Containers: Maps, Sets, Trees, Graphs

- A =container= is any *Data Structure* whose purpose is to hold elements of other types in it.
  - Lists
  - Trees

**** Data.Map
- Special purpose map where integers are the keys (more performant), in *unordered-containers*
  IntMap
  HashMap (when the keys are NOT numbers but are mapped to)
- many of the functions in that module collide with name s from the built-in Prelude
  #+begin_src haskell
  import qualified Data.Map as M
  #+end_src
- Haskell has no special syntax for maps (like for lists with [], or [1,2])
  or for exporting any of its data constructors.
|----------------------+-------------------------------------------------------------|
| M.assocs             | get an assoc list from a map                                |
| M.empty              | constructor                                                 |
| M.singleton          | constructor, eg: M.singleton "hello" 3                      |
| M.fromList           | constructor, eg: M.fromList [("hello",3)]                   |
| M.insert             | adding new value                                            |
| M.insertWith         | adding new value, to combine the old value with the new one |
| M.insertWithKey      | adding new value,                                           |
| M.null               | checks if map is empty                                      |
| M.member             | checks if key is avaible on map                             |
| M.lookup             | returns a Maybe                                             |
| M.findWithDefault    |                                                             |
| M.delete             | kelete key from map                                         |
| M.adjust             | takes a function to apply to the value in key               |
| M.alter              | insert/delete/adjust are wrappers of this one               |
|                      | takes a (Maybe a -> Maybe a)                                |
| M.union(With)        | by default, the first map takes precedence if repeated      |
| M.intersection(With) |                                                             |
| M.difference(With    |                                                             |
| M.map                |                                                             |
| M.foldr              |                                                             |
| M.foldl              |                                                             |
| M.filter             |                                                             |
| M.partition          |                                                             |
| M.find(Min/Max)      |                                                             |
| M.delete(Min/Max)    |                                                             |
| M.update(Min/Max)    |                                                             |
|----------------------+-------------------------------------------------------------|
**** Data.Set
- Like lists but do not allow duplicates
- Sorts in ascending order
- Special purpose types for sets of integers, in *unordered-containers*
  IntSet
  HashSet (when the values are not integers, but are mapped to...)
- Elements in a set don't have a key
  #+begin_src haskell
    import qualified Data.Set as S
  #+end_src
- union/intersection/difference/member/map
| S.empty     | constructor |
| S.singleton | constructor |
| fromList    | constructor |
| toList      | set to list |
| insert      | add one     |
|             |             |
**** Data.Tree
#+begin_src haskell
  data Tree   a = Node { rootLabel :: a, subForest :: Forest a }
  type Forest a = [Tree a]
#+end_src
| Data.Tree     | flatten | pre-order traversal, just returns them as they are |
| Data.Tree     | levels  | BFS, returns each level as a list                  |
| Data.Foldable | foldr   |                                                    |
| Prelude       | fmap    |                                                    |
- *type* creates type synonyms
  *newtype* does NOT create type equivalents
- composed of nodes, which hold a vlaue and may have other trees as children
  - Those children are represented as bare list of trees (a forest)
- This implementation is not specialized for any particular purpose
  - TreeStructures, AvlTree, RBTree
- ways to visit nodes in a tree
  1) DFS pre-order  (visiting the value before any subtree)
  2) DFS post-order (visiting the value after all subtrees are visited)
  3) BFS
- preorder example
  #+begin_src haskell
    import Data.Tree
    preORder :: (a -> b) -> Tree a -> [b]
    preOrder f (Node v subtrees) -- TRY concatMap
      = let subtreesTraversed = concat $ map (preOrder f) subtrees
        in f v : subtreesTraversed
  #+end_src
**** Data.Graph
| graphFromEdges   | constructor, gets a list of triplets, returns also 2 lookup functions |
| buildG           | constructor, gets a tuple and a list of tuples                        |
|------------------+-----------------------------------------------------------------------|
| vertices         |                                                                       |
| edges            |                                                                       |
| reachable        | every vertex reachable from vertex                                    |
| path             | boolean, path between vertex names                                    |
| scc              | strongly connected components                                         |
| stronglyConnComp | a special type SCC is used for repsenting each component              |
| flattenSCC       | returns a printable version of SCC                                    |
- graphs are vertices joined via a set of edges
- on this implementation
  - nodes are always integers
  - edges are directed
  - without weights
- Example: find the partitions of *strongly connected components* and filter out the one with only 1 node, due being built with buildG
  #+begin_src haskell
    filter (\(Node { subForest = s }) -> s /= []) $ scc timeMachineTravel
  #+end_src
*** =Ad-Hoc Polymorphism=: Type Classes
- M.insert :: Ord k => k -> a -> M.Map k a -> M.map k a
  - Ord =type class=
  - Ord k, used to constrain the set of possible types that k type variable can take
- You can express that certain types exhibit a common behavior
- Declaring a type class, aka class
  #+begin_src haskell
    class ClassName variable where
      oneFunction :: oneType
  #+end_src
- =Instance= of a type class, that type supports the operation of the typeclass
  In OO, it means a concreate value of a class
  In Haskell, it refers to the implementaion of a class by a type
  #+begin_src haskell
    instance ClassName Type where
      oneFunction = ... -- Implementation
    instance Nameable (Client i) where
      name Individual { person = Person { firstName = f, lastName = n } }
        = f ++ " " ++ n
  #+end_src
- Is NOT possible to prevent an instance declaration from being imported.
  import Module () -- would then import the instance declarations
- Haskell is able to *derive* instances for only some type classes, which are hard-coded in the compiler
  - Generic Programming, provides ways to write functions that depend on the *structure* of data types
- to use *read*, haskell needs to know which instance of Read should be used
- Ord, Eq
  - Type Classes
  - Encode the "default comparisons" and "default equivalences" for lists
  - Eq has *default definitions* for (==) and (/=) you need to implement just one.
    For a minimal complete definition.
- =restrictions for instantiating a type class=,
  - eg: an instance of Eq for any possible list type in a generic way.
    - in this case we require the inner elements also implement the Eq class
    #+begin_src haskell
      instance Eq a => Eq [a] where
        []     == []     = True
        (x:xs) == (y:ys) = x == y && xs == ys
        _      == _      = False
    #+end_src
  - eg : Ord
    - Prerequisite it's being a member of Eq
      - Eq is a =superclass= of Ord
    - minimal complete definitions, is either implementing *compare* or *<=*
    #+begin_src haskell
      class Eq a => Ord a where
        compare              :: a -> a -> Ordering
        (<), (<=), (>), (>=) :: a -> a -> Bool
        max, min             :: a -> a -> a
        compare x y = if x == y then EQ
                      else if x <= y then LT
                           else GT
        x < y   = case compare x y of { LT -> True; _ -> False }
        x <= y  = case compare x y of { GT -> False; _ -> True }
        x > y   = case compare x y of { GT -> True; _ -> False }
        x >= y  = case compare x y of { LT -> False; _ -> True }
        max x y = if x <= y then y else x
        min x y = if x <= y then x else y
    #+end_src
- Constants are polymorphic
- Number related type classes
 | Num                     | +,-,*,negate,abs,signum,fromInteger               |
 | Num>Real                | toRational                                        |
 | Num>Real>Integral       | quot, rem, quotRem AND div, mod, divMod           |
 | Num>Fractional          | /, recip, fromRational                            |
 | Num>Fractional>Floating | pi, e, aqrt, log, exp, **, trigonometry functions |
- Example: *Complex* type class instance of Num (already defined on Data.Complex module)
  1) i^2 = -1
  2) absolute |x| and argument 0x
  #+begin_src haskell
    data Complex = C Double Double deriving (Show, Eq)
    instance Num Complex where
      (C a1 b2) + (C a2 b2) = C (a1 + a2) (b1 + b2)
      (C a1 b2) - (C a2 b2) = C (a1 - a2) (b1 - b2)
      (C a1 b2) * (C a2 b2) = C (a1*a2 - b1*b2) (a1*b2-b1*a2)
      negate (C a b)        = C (negate a) (negate b)
      fromInteger           = C (fromInteger n) 0
      abs (C a b)           = C (sqrt $ a*a+b*b) 0
      signum c@(C a b)      = let C n _ = abs c
                              in C (a / n) (b / n)
  #+end_src
- =Data.Default= module has a TypeClass (Default) for abstract the default values idiom
  in the *data-default* package
  with a member *def*
  #+begin_src haskell
    instance Default ConnOptions where
      def = ConnOptions TCP 0 NoProxy Flase False NoTimeout
  #+end_src
**** Exercise 4-4 Prices for the store
#+begin_src haskell
  data Guide = Guide { price :: Double, to :: String }
  data Tool  = Tool  { price :: Double, name :: String}
  class Priceable where
    price :: Double
  instance Priceable Guide where
    price (price = p) = p
  instance Priceable Tool where
    price (price = p) = p

  totalPrice :: Priceable p => [p] -> Double
  totalPrice = foldr (\x y -> price x + price y)
  totalPrice = sum . map price
#+end_src
**** TODO Exercise 4-5 The same client
- Eq for "Person" and "Client i" types
#+begin_src haskell
#+end_src
**** TODO Exercise 4-6 Ordering clients
- Should compare the name of the client
- Individuals first and Companies later, and Organizations at the end.
- Might be add other comparisions for other fields
#+begin_src haskell
#+end_src
*** Binary Trees for the Minimum Price (=Monoid=)
#+begin_src haskell
  data TravelGuide = TravelGuide { title :: String
                                 , authors :: [String]
                                 , price :: Double }
                   deriving (Show, Eq, Ord)
#+end_src
- Designing a custom container to be used for the discount module of the timemachines example
  - Cheapest elements in the container
  - Will hhold travel guides
- Binary trees
  1) has *logaritmic* complexity for lookups
  2) each node holds a value and 2(two) *references* to subtrees
  3) any node in the *left subtree* will hold only those value smaller than the on in the node
**** Step 1 - Simple Binary Trees
#+begin_src haskell
  data BinaryTree = Node1 TravelGuide BinaryTree1 BinaryTree1
                  | Leaf1
                  deriving Show

  treeFind1 :: TravelGuide -> BinaryTree1 -> Maybe TravelGuide
  treeFind1 t (Node1 v l r) = case compare t v of
                                EQ -> Just v
                                LT -> treeFind1 t l
                                GT -> treeFind1 t r
  treeFind1 _ Leaf1         = Nothing

  treeInsert1 :: TravelGuide -> BinaryTree1 -> BinaryTree1
  treeInsert1 t n@(Node1 v l r) = case compare t v of
                                    EQ -> n
                                    LT -> Node1 v (treeInsert1 t l) r
                                    GT -> Node1 v l (treeInsert1 t r)
  treeInsert1 t Leaf1           = Node1 t Leaf1 Leaf1
#+end_src
**** Step 2 - Polymorphic Binary Trees
- While it is possible encode the restriction of the class elements that the binary tree may hold directly in the data declaration.
  It's NOT recommended.
  The best way is to encode the restriction in each of the operation that work on the structure.
  In order to impose this restriction, you must hide the Node2 and Leaf2 constructors from public consuption.
#+begin_src haskell
  data BinaryTree2 a = Node2 a (BinaryTree2 a) (BinaryTree2 a)
                     | Leaf2
                     deriving Show
  treeFind2 :: Ord a => a -> BinaryTree2 a -> Maybe a
  treeFind2 t (Node2 v l r) = case compare t v of
                                EQ -> Just v
                                LT -> treeFind2 t l
                                GT -> treeFInd2 t r
  treeFind2 _ Leaf2         = Nothing
#+end_src
**** Step 2.1 - Problem: order of the TravelGuide is NOT by default by price
  - You CANNOT override the default with "instance Ord TravelGuide where"
  - Naive solution would be creat a new field with a single field
    #+begin_src haskell
      data TGByPRice = TGByPrice TravelGuide
      instance ORd TGByPrice where . . .
    #+end_src
  - =newtype= used to declare another name for an already existing type
    NOT as a synonym, byt as a completely unrelated type.
    #+begin_src haskell
      newtype TGByPrice = TGByPrice TravelGUide deriving Eq
      instance Ord TGByPrice where
        (TGByPrice (TravelGuide t1 a1 p1)) <= (TGByPrice (TravelGuide t2 a2 p2)) =
          p1 < p2 || (p1 == p2 && (t1 < t2 || (t1 == t2 && a1 <= a2)))
    #+end_src
***** TODO Exercise 4-7 More operations on generic trees
After Step 2
1) treeInsert for BinaryTree2
2) concatenation of ninary trees, by repeatedly inserting all the elements in one of the binary trees
**** Step 3 - Binary Trees with Monoidal Cache

- New Problem: finding the smalles price still takes some time (going into the left subtree until you reach a leaf)
  Solution: include a cache in evey node. Stores the price of the smalles in the tree.

#+begin_src haskell
  data BinaryTree3 v c = Node3 v c (BinaryTree3 v c) (BinaryTree3 v c)
                       | Leaf3
                       deriving (Show, Eq, Ord)

  treeInsert3 :: (Ord v, Ord c)
              => v
              -> c
              -> BinaryTree3 v c
              -> BinaryTree3 v c
  treeInsert3 v c (Node3 v2 c2 l r)
    = case compare v v2 of
        EQ -> Node3 v2 c2 l r
        LT -> Node3 v2 (min c c2) (treeInsert3 v c l) r
        GT -> Node3 v2 (min c c2) l (treeInsert3 v c r)
  treeInsert3 v c Leaf3 = Node3 v c Leaf3 Leaf3
#+end_src

**** Step 3.1 Monoid and Semigroup (<>)

- Properties of the function to cache on the Binary Tree.
  An associative binary operation with an eelement that does not affect the outcome.
  A =Monoid=.
  1) Same type inputs and outputs: c -> c -> c
  2) Operation must be associative. Structure of the BT might not be the same.
  3) neutral element
     f e x = f x e = x

- Since GHC 8.4
  =Monoid= is subclass of a more general notion called
  =Semigroup= which *drops the neutral element* requirement and just includes the associative binary operation.

- Examples of monoidal structures
  1) All with && and True
  2) All with || and False
  3) numbers, with Sum with addition and 0,
  4) numbers, with Product with multiplication and 1

**** Step 3.2 New version, using Monoid as a restriction

#+begin_src haskell
  treeInsert :: (Ord v, Monoid c)
             => v
             -> c
             -> BinaryTree3 v c
             -> Binarytree3 v c
  treeInsert4 v c (Node3 v2 c2 l r)
    = case compare v v2 of
        EQ -> Node3 v2 c2 l r
        LT -> let newLeft = treeInsert4 v c l
                  newCache = c2 <> cached newLeft <> cached r
              in Node3 v2 newCache newLeft r
        GT -> let newRight = treeInsert4 v c r
                  newCache = c2 <> cached l <> cached newRight
              in Node3 v2 newCache l newRight
  treeInsert4 v c Leaf3 = Node3 v c Leaf3 Leaf3

  cached :: Monoid c
         => BinaryTree v c
         -> c
  cached (Node3 _ c _ _) = c
  cached Leaf3           = mempty
  #+end_src

- Semigroup/Monoid instance and newtype needed for cache insertion algorithm to work
  #+begin_src haskell
    newtype Min = Min Double deriving Show

    instance Semigroup Min where
      Min x <> Min y = Min $ min x y

    instance Monoid Min where
      mempty  = Min infinity where infinity = 1/0
      mappend = (<>) -- use the definition from Semigroup
  #+end_src

*** Container-Related Type Classes (=Functors/Foldables=)
- Thinking about the commonalities between different containers.
  Lead to discover some useful type class.
**** Functors
- All on "Example 1" apply a function inside a data structure.
- A data type supporting  afunction like *map* is called a =functor=
  Notice how the types that are to be functions should take one type parameter (f a)
  Eg: IntSet cannot be used, even though conceptually is a Functor
  #+begin_src haskell
    class Functor f where
      fmap :: (a -> b) -> f a -> f b
  #+end_src
- =Kind system=
  - Is used for the haskell compiler to check the correct application of *type parameters*
  - Types themselves are also *categorized* based on the level of application
    1) Basic types have kind "*"
    2) Types that need one parameter to be fully applied such as Maybe, have kind "* -> *"
       So, the final kind for "Maybe Integer" is indeed "*"
- *Set* cannot be made an instance of Functor. Mapping functions would need to have an Ord restriction.
- There are other users that are not related to containers.
  - (->) r
  - aka functions of the form "r -> a"
  - The corresponding fmap type would be
    #+begin_src haskell
      fmap :: (a -> b)
           -> (r -> a)
           -> (r -> b)
    #+end_src
  - The instance would be
    #+begin_src haskell
      instance Functor ((->) r) where
        fmap f g = f . g
    #+end_src
***** Example 1: modifying  a value on a list/Map/Tree
#+begin_src haskell
  modifyTravelGuidePrice
    :: Double
    -> [TravelGuide]
    -> [TravelGuide]
  modifyTravelGuide m = map (\tg -> tg { price = m * price tg})

  modifyTravelGuidePriceMap
    :: Double
    -> M.Map a TravelGuide
    -> M.Map a TravelGuide
  modifyTravelGuidePriceMap m = M.map (\tg -> { price = m * price tg })

  modifyTravelGuidePriceTree
    :: Double
    -> T.Tree TravelGuide
    -> T.Tree TravelGuide
  modifyTravelGuidePriceTree m = fmap (\tg -> tg { price = m * price tg })
  #+end_src
***** Example 2: more general way to modify a container (fmap)
#+begin_src haskell
  modifyTravelGuidePrice'
    :: Functor f
    -> Double
    -> f TravelGuide
    -> f TravelGuide
  modifyTravelGUidePrice' m = fmap (\tg -> tg { price = m * price tg })
#+end_src
***** Exercise 4-8 Functor fun!
- Write the corresponding Functor instance for both Maybe and the binary trees from the previous section.
  - You will need to create a new type for Maybe value sin order to make the compiler happy.
  - Choose BinaryTree2 as the type for instantiating Functor
#+begin_src haskell
  instance Functor Maybe a where
    fmap _ Nothing  = Nothing
    fmap f (Just v) = (Just f v)
  instance Functor BinaryTree2 a where
    fmap f Leaf2         = Leaf2
    fmap f (Node2 v l r) = Node2 (f v) (fmap f l) (fmap f r)
#+end_src
**** Foldable

- You can define a Foldable as either, both valid ways
  1) The *foldr* version: A combining function + an initial value.
  2) The *foldMap* version: where you thinking as a Monoid
- Eg: maximum, elem
- Prelude has functions specialized for lists by default. For beginners.
  - "You should aim for the largest degree of abstraction that you can achieve"
- Extensions: =DeriveFunctor= and =DeriveFoldable= are automatic derivation of these type classes.

***** Exercise 4-9 Foldable Fun!

Write Foldable for Maybe and Binary Trees. See 4-9 restrictions.

#+begin_src haskell
  instance Foldable Maybe a where
    foldr f i Nothing   = i
    foldr f i (Maybe a) = f i a

  instance Foldable BinaryTree2 a where
    foldr _ i Leaf2 = i
    foldr f i (Node2 v l r) = f leftValue rightValue
      where newValue   = f i v
            leftValue  = foldr f newValue l
            rightValue = foldr f newValue r
#+end_src

** 5 Laziness and Infinite Structures

*** An infinite Number of Time Machines

- Each TimeMachine has a year that is ONLY allowed to travel
  #+begin_src haskell
    data TimeMachine = TM { manufacturer :: String, year :: Integer }
                     deriving (Eq, Show)
  #+end_src

- Haskell *infinite list ranges*, means all elements "larger than", NOT infinite
  > zip allNumbers "abcd"
  > zip [1 .. ] "abcd"
  [(1,'a'),(2,'b'),(3,'c'),(4,'d')]
  > [False ..]
  [False, True]

- Some operations might enter into an infinite computation and will never return.

**** Example: A function to return all the time machines from a year *n* on.
#+begin_src haskell
  timeMachinesFrom :: String -> Integer -> [TimeMachine]
  timeMachinesFrom mf y = TM mf y : timeMachinesFrom mf (y+1)

  timelyIncMachines :: [TimeMachine]
  timelyIncMachines = timeMachinesFrom "Timely Inc." 100
  #+end_src
**** Example: All integer numbers
#+begin_src haskell
  allNumbers :: [Integer]
  allNumbers = allNumbersFrom 1
  allNumbersFrom :: Integer -> [Integer]
  allNumbersFrom n = n : allNumbersFrom (n+1)
  #+end_src
**** Example: Infinite Fibonacci numbers, using infinite lists
#+begin_src haskell
  fibonacci :: [Integer]
  fibonacci = 0 : 1 : zipWith (+) fibonacci (tail fibonacci)
  -- > import Data.List
  -- > fibonacci !! 20
  -- 6765
#+end_src
**** Example: Infinite TimeMachine, =repeat=
#+begin_src haskell
  infinite2020Machines :: [TimeMachine]
  infinite2020Machines = TM "Timely Inc." 2020 : infinite2020Machines
  infinite2020Machines = repeat $ TM "Timely Inc." 2020 -- or using repeat
#+end_src
**** Example: Infinite TimeMachine list of a certain order, =cycle=
#+begin_src haskell
  specialOffer :: [TimeMachine]
  specialOffer = cycle [TM m 2005, TM m 1994, TM m 908]
    where m = "Timely Inc."
#+end_src
**** Example: Infinite Fibonacci tuples, =iterate=
- itarate, applies the functions to a value to obtain the 2nd value, applies again to obtain the 3rd...
  iterate f x = [x, f x, f (f x), f (f (f x)), ...]
  #+begin_src haskell
    fibonacci2 :: [Integer]
    fibonacci2 = map fst $ iterate (\(n,n1) -> (n1,n+n1)) (0,1)
  #+end_src
**** Exercise 5-1 The sieve of Eratosthenes
#+begin_src haskell
  primes :: [Integer]
  primes = primes' [2..]

  primes' :: [Integer] -> [Integer]
  primes' (x:xs) = x : (primes' $ filter (`isPrime` x) xs)

  isPrime :: Integer -> Integer -> Bool
  isPrime a b | a `rem` b == 0 = False
              | otherwise      = True
#+end_src
- Algorithm for getting the list of all the primes
  1) Start with a list of all the numbers from 2 on
  2) take the first number, drop the the list all his multiples
  3) take the next number, drop all the multiples
  4) repeat previous step with the first number left in the previous one
*** Lazy Evaluation Model
**** Understainding Evaluation in Haskell
- Most programming languages follow a *strict evaluation model*
  1) whenever a compound expression if found it's _immediately_ transformed into a simpler version
  2) arguments to a function are evaluated _before_ the control flow enters the body of the function
- *non-strict or lazy evaluation*
  - Haskell tries to evaluate the expressions as late as possible.
  - Haskell evaluates an expression only _until_ a constructor is found
  - =Thunk= is the unevaluated code's placeholder
  - This also means that these thunks can be reused in the evaluation of other parts of the program
    - This does NOT mean a memoization of values happens, only expressions
    - Side effects make it impossible to apply sharing optimizations
**** Problems with Laziness
**** Pattern Matching and Laziness
**** Profiling with GHC
*** Strictness annotations
* 22 | Sockets & Pipes                           | JoyH     | Chris Martin

|----------------+-------------------------------------------------------------------|
| deps library   | https://github.com/joyofhaskell/sockets-and-pipes                 |
| anon code      | https://github.com/brhutchins/sockets-and-pipes/blob/main/Book.hs |
| http semantics | https://www.rfc-editor.org/rfc/rfc9110.html                       |
| http 1.1       | https://www.rfc-editor.org/rfc/rfc9112.html                       |
|----------------+-------------------------------------------------------------------|

ERRATA:
10 - "A typical running computer contains multitudes" add "of processes" at the end?
51 - "The first argument to addrInfo" should have been getAddrInfo

** Preface

- "What exactly /is/ a a web server?"
- Creating a webserver that speaks HTTP from scratch
- Libraries:
  - bytestring, text
  - sockets, network
  - attoparsec (from bytestring to http messages)
  - mtl (aka Monad Transformers):
    - =ResourceT= to deal with files/sockets without resource leaks
    - =ExceptT= to deal with different errors
    - =ListT=
    - Producer
    - ReaderT

** 0 Setup

- GHC 9.2 or 9.4 is required

*** book.cabal

old book version
#+begin_src haskell-cabal
  common base
    default-language:   Haskell2010
    default-extensions: BlockArguments
                        QuasiQuotes
                        TypeApplications
                        ScopedTypeVariables
    build-depends:      sockets-and-pipes ^>=0.3
#+end_src


#+begin_src haskell-cabal
  cabal-version: 3.0 # NECESSARY
  name: book         # NECESSARY
  version: 0.0.0.0   # NECESSARY

  common base
    default-language: GHC2021
    default-extensions: BlockArguments
                        DerivingVia
                        NoImplicitPrelude
                        QuasiQuotes
    ghc-options:        -Wall -fdefer-typed-holes
    build-depends:      sockets-and-pipes ^>= 1.0

  library
    import:          base
    hs-source-dirs:  library
    exposed-modules: Book
#+end_src

*** sockets-and-pipes - dependencies

- ascii
- aeson
- async
- attoparsec
- attoparsec-run
- base
- blaze-html
- bytestring
- containers
- directory
- filepath
- hash-addressed
- mtl
- network
- network-simple
- pipes
- relude
- resourcet
- safe-exceptions
- stm
- text
- time
- unfork

*** sockets-and-pipes - reexported-modules

-- aeson
, Data.Aeson
, Data.Aeson.Key
, Data.Aeson.KeyMap

-- ascii
, ASCII
, ASCII.Char
, ASCII.Decimal

-- async
, Control.Concurrent.Async

-- attoparsec
, Data.Attoparsec.ByteString

-- attoparsec-run
, Data.Attoparsec.ByteString.Run

-- base
, Control.Concurrent
, Control.Monad
, Data.Char
, Prelude
, System.IO

-- blaze-html
, Text.Blaze.Html
, Text.Blaze.Html.Renderer.Utf8
, Text.Blaze.Html5
, Text.Blaze.Html5.Attributes

-- bytestring
, Data.ByteString
, Data.ByteString.Builder
, Data.ByteString.Char8
, Data.ByteString.Lazy

-- containers
, Data.Map.Strict

-- directory
, System.Directory

-- filepath
, System.FilePath

-- hash-addressed
, HashAddressed.Directory
, HashAddressed.HashFunction

-- mtl
, Control.Monad.Except

-- network
, Network.Socket
, Network.Socket.ByteString

-- network-simple
, Network.Simple.TCP

-- pipes
, Pipes

-- relude
, Relude

-- resourcet
, Control.Monad.Trans.Resource

-- safe-exceptions
, Control.Exception.Safe

-- stm
, Control.Concurrent.STM
, Control.Concurrent.STM.TVar
, Control.Monad.STM

-- text
, Data.Text
, Data.Text.Encoding
, Data.Text.IO
, Data.Text.Lazy
, Data.Text.Lazy.Builder
, Data.Text.Lazy.Builder.Int
, Data.Text.Lazy.Encoding
, Data.Text.Lazy.IO

-- time
, Data.Time

-- unfork
, Unfork

*** Book.hs

#+begin_src haskell
module Book where

import Prelude () -- not needed withNoImplicitPrelude?
import Relude
import qualified System.Directory as Dir

getDataDir :: IO FilePath
getDataDir = do
  dir <- Dir.getXdgDirectory Dir.XdgData "sockets-and-pipes"
  Dir.createDirectoryIfMissing True dir
  return dir
#+end_src

- once you have the file:
  #+begin_src haskell
  $ cabal repl
  ghci> getDataDir
  "/home/sendai/.local/share/sockets-and-pipes"
  #+end_src

** 1 Handles
*** The Necessity of indirection

- a ~process~
  - is an instance of a program that is running
  - it performs an _action_ when interacts with physical resources
  - mediated by the OS through /system calls/
    - $ man 2 syscalls


- ~multiplexing~
  - Is allowing many "tenants" to /share/ the same facilities without interfering with each other.
  - This is the job of the *OS*, to coordinate shared use of (limited) physical resources.
  - When we say that the program performs an /action/, we are usually talking about interacting with physical resources.

*** Writing to a file (hPutStrLn,hClose)

- A ~handle~ is a _identifier_ for the OS<->Process conversation
  - Windows: file handle
  - Linux:   file descriptor (aka fd)
  - a temporary means of grabbing onto a resource it, like the handhold provided by an ice climber's axe.

- System.IO
  - ~putStrLn~ is a specialization of the more general ~hPutStrLn~ with *stdout* as his handle parameter
  - it is ok to call ~hClose~ more than once on the same handle

- Example: handle used to write into a file
  #+begin_src haskell
    import System.FilePath ((</>))
    import qualified System.IO as IO

    writeGreetingFile :: IO ()
    writeGreetingFile = do
      dir <- getDataDir -- getDataDir :: IO FilePath
      h   <- IO.openFile (dir </> "greeting.txt") WriteMode -- data IOMode = ReadMode|AppendMode|ReadWriteMode
      IO.hPutStrLn h "hello"
      IO.hPutStrLn h "world"
      IO.hClose h
  #+end_src

*** Exceptions (tryAny)

- tryAny is from =safe-exceptions= package
- What can fail on our example?
  - ~putStrLn~ - storage is full (when stdout is redirected outside the program to a file?)
  - ~openFile~ - insufficient file permissions

- use ~Control.Exception.Safe.tryAny~ to change the default /halt action/ that happens when an exception happens
  #+begin_src haskell
    tryAny :: IO a -> IO (Either SomeException a)
  #+end_src

- What could go wrong?
  1) IO Exceptions: eg: disk is full
  2) Asynchronous exceptions:
     - NOT captured by ~tryAny~
     - An action can receive an exception at _any time_
     - Catching them should be left to dedicated libraries that know what they are doing.
     - eg: when received a kill signal (^C)
     - eg: one thread throws an exception to another with ~Control.Exception.throwTo~

**** Example: custom error message on ~openFile~ error
#+begin_src haskell
  writeGreetingTry :: IO ()
  writeGreetingTry = do
    dir <- getDataDir
    IO.hPutStrLn IO.stderr "About to open the file :/"
    openResult <- tryAny $ IO.openFile (dir </> "greeting.txt") WriteMode
    case openResult of
        Left _ -> IO.hPutStrLn IO.stderr "Cannot open file to write :("
        Right h -> do
          IO.hPutStrLn h "hello"
          IO.hPutStrLn h "world"
          IO.hClose h
          IO.hPutStrLn IO.stderr "Done :)"
#+end_src

*** Diligent cleanup (ResourceT IO, allocate, liftIO)

- from =resourcet= package
- Using ~tryAny~ to make sure the handle is closed on exceptions. Still, does NOT capture asynchronous exceptions.
  #+begin_src haskell
    writeGreetingSafeAttempt :: IO ()
    writeGreetingSafeAttempt = do
      dir <- getDataDir
      h   <- IO.openFile (dir </> "greeting.txt") WriteMode
      _   <- tryAny do -- <<<<<<<<<<HERE<<<<<<<<<<
        IO.hPutStrLn h "hello"
        IO.hPutStrLn h "world"
      IO.hClose h
  #+end_src

- Instead, we will use =ResourceT m a= from the ~resourcet~ library
  - the ~T~ at the end of a type stands for *transformer* (it is one)
  - if ~m~ is a monad, then "ResourceT m" is a monad too
  #+begin_src haskell
    {-# LANGUAGE TypeApplications #-}
    import Control.Monad.Trans.Resource ( ReleaseKey
                                        , ResourceT
                                        , allocate
                                        , runResourceT)
    -- signature is not needed due @IO's TypeApplication
    writeGreetingSafe :: IO ()
    writeGreetingSafe = runResourceT @IO do -- ResourceT IO ()
        dir <- liftIO getDataDir -- getDataDir :: IO FilePath
        (_releaseKey, h) <-
            allocate (IO.openFile (dir </> "greeting.txt") IO.WriteMode)
                      IO.hClose
        liftIO (IO.hPutStrLn h "hello") -- IO () to ResourceT IO ()
        liftIO (IO.hPutStrLn h "world") -- IO () to ResourceT IO ()
  #+end_src

- ~ResourceT IO~
  - represents the concept of ~IO~ that has been _transformed or modified_ by adding a certain *safety* feature.
  - much like an ~IO~ action, but it is _augmented_ with a register of *resources* that are guarenteed to be closed.
  - anything that you can do in ~IO~ can also be done in ~ResourceT IO~

- new functions used and their specializations
  #+begin_src haskell
    liftIO       :: MonadIO m       => IO a           -> m a
    liftIO       ::                    IO a           -> ResourceT IO a

    allocate     :: MonadResource m => IO a           -> (a -> IO ()) -> m         (ReleaseKey, a)
    allocate     ::                    IO a           -> (a -> IO ()) -> ResourceT (ReleaseKey, a)

    runResourceT :: MonadUnliftIO m => ResourceT m  a -> m  a
    runResourceT ::                    ResourceT IO a -> IO a

    release      :: MonadIO m       => ReleaseKey     -> m () -- when you can release early
  #+end_src

- Whenever learning about a new type, pay attention to:
  1) Introduction: which functions _introduce that type_ (eg: liftIO, allocate)
  2) Elimination: which functions _eliminate it_ (eg: runResource)

- This tell us what is the general structure of a program using the type will look like.

**** =ResourceT= classes

- ~MonadIO~
  - classes that belong to it: ResourceT IO, IO
  - describes any Monad that an ~IO~ action can be lifted into.
    #+begin_src haskell
      class (Monad m) => MonadIO m where
        liftIO :: IO a -> m a
    #+end_src

- ~MonadUnliftIO~
  - "you don't need to know..."
  - every constraint in a polymorphic type signature means

- ~MonadResource~
  - class describes the special safety augmentation of ~IO~
  - ~ResourceT IO~ belongs to it
    - can have further monad transformers applied to it

*** MonadIO programmer's relationship to it

- when introducing a new *monad transformer* like ~ResourceT~ into an ~IO~ sequence, every line under the ~do~ whose type is not already of type ~ResourceT IO~ will have to be lift into it using *liftIO*

- if we choose to add the class to our function, it will make the output liftable
  #+begin_src haskell
    helloWorld :: MonadIO m => m ()
    helloWorld = liftIO (IO.putStrLn "hello world!")
  #+end_src

*** Exercises

#+begin_src haskell
fileResource :: FilePath -> IO.IOMode -> ResourceT IO (ReleaseKey, IO.Handle)
fileResource file mode = do
  allocate (IO.openFile file mode) IO.hClose
#+end_src

#+begin_src haskell
main :: IO ()
main = do
  h <- IO.openFile filename IO.ReadMode
  s <- IO.hShow h
  IO.putStrLn s -- {loc=/home/sendai/testfield/what.sh, type=readable, buffering=block (2048)}
  IO.hClose h
  where
    filename = "/home/sendai/testfield/what.sh"
#+end_src

#+begin_src haskell
howManyHandles :: IO ()
howManyHandles = runResourceT do
  hs <- openManyHandles
  liftIO $ putStrLn ("Opened " <> show (length hs) <> " handles")

openManyHandles :: ResourceT IO [IO.Handle]
openManyHandles = go []
  where
    go :: [IO.Handle] -> ResourceT IO [IO.Handle]
    go hs = do
      r <- fileResourceMaybe -- r :: Maybe IO.Handle
      case r of
        Nothing -> return hs
        Just h -> go (h : hs)

fileResourceMaybe :: ResourceT IO (Maybe IO.Handle)
fileResourceMaybe = do
  dir <- liftIO getDataDir
  result <- tryAny do
    (_, h) <- fileResource (dir </> "greetings.txt") IO.ReadMode
    return $ Just h
  case result of
    Right x -> return x
    Left e -> do
      liftIO $ print (displayException e)
      return Nothing

main :: IO ()
main = howManyHandles
#+end_src

"/home/sendai/.local/share/sockets-and-pipes/greetings.txt: openFile: resource exhausted (Too many open files)"
Opened 1020 handles

** 2 Chunks

#+begin_src haskell
  import qualified Data.Text as T
  import qualified Data.Text.IO as T
  import qualified Data.Char as Char
#+end_src

*** Packed characters (T.pack and strictness)

- T.pack
- T.hPutStrLn
- Text is packed in memory, unlike String(s) which are Linked Lists and sparse in
- Text is ~strict~
  - Values are evaluated "in one go"
  - You CANNOT rely on lazy evaluation to compute a part of a Text sequence
    #+begin_src haskell
      T.take 10 (T.pack (cycle "abc")) -- runs out of memory
    #+end_src

*** Reading from a file

#+begin_src haskell
  T.hGetChunk :: Handle -> IO Text
#+end_src

- chunk to not choke
- around thousands characters per chunk
- empty chunk when done

**** Example: Reading chunks from a handle
#+begin_src haskell
  printFileContentsUpperCase :: IO ()
  printFileContentsUpperCase = runResourceT do
    dir <- liftIO getDataDir
    (_, h) <- fileResource (dir </> "greetings.txt") IO.ReadMode
    liftIO $ printCapitalizedText h

  printCapitalizedText :: IO.Handle -> IO ()
  printCapitalizedText h = proceed
    where
      proceed = do
        chunk <- T.hGetChunk h
        if T.null chunk
          then
            return ()
          else do
            T.putStrLn (T.toUpper chunk)
            proceed -- loop
#+end_src

**** Example: code abstraction for iteration
#+begin_src haskell
repeatUntilIO ::
  IO chunk            -- producer of chunks
  -> (chunk -> Bool)  -- does chunk indicate the end of file?
  -> (chunk -> IO ()) -- what to do with each chunk?
  -> IO ()
repeatUntioIO getChunk isEnd f = proceed
  where
    proceed :: IO ()
    proceed = do
      chunk <- getChunk
      if (isEnd chunk)
      then return ()
      else do
        f chunk
        proceed
#+end_src

**** Example: refactor using the abstraction
#+begin_src haskell
  printFileContentsUpperCase :: IO ()
  printFileContentsUpperCase = runResourceT do
    dir <- liftIO getDataDir
    (_,h) <- fileResource (dir </> "greetings.txt") IO.ReadMode
    liftIO $ repeatUntilIO (T.hGetChunk h) T.null \chunk ->
      T.putStr (T.toUpper chunk)
#+end_src

*** TODO Exercises

#+begin_src haskell
-- find the numbers
digitsOnly :: T.Text -> T.Text
digitsOnly = T.filter Char.isNumber
-- capitalize the last
capitalizeLast :: T.Text -> T.Text
capitalizeLast =
  T.unwords . map (T.reverse . T.toTitle . T.reverse) . T.words
capitalizeLast' :: T.Text -> T.Text
capitalizeLast' t =
  case T.unsnoc t of -- snoc <-> cons
    Nothing -> T.empty
    Just (t', c) -> T.snoc t' (Char.toUpper c)
-- paren removal
unParen :: T.Text -> Maybe T.Text
unParen t =
  if T.last t == ')' && T.head t == '('
    then Just $ T.take (T.length t - 2) $ T.takeEnd (T.length t - 1) t
    else Nothing
unParen' :: T.Text -> Maybe T.Text
unParen' t =
  case T.stripSuffix (T.pack ")") t of
    Nothing -> Nothing
    Just t' -> T.stripPrefix (T.pack "(") t'
unParen'' :: T.Text -> Maybe T.Text
unParen'' =
  T.stripPrefix (T.pack "(")
    >=> T.stripSuffix (T.pack ")")

-- character count
characterCount' :: FilePath -> IO Int
characterCount' fp = runResourceT do
  (_, h) <- fileResource fp IO.ReadMode
  liftIO $ handleCharacterCount h

handleCharacterCount :: IO.Handle -> IO Int
handleCharacterCount handle =
  proceed 0
  where
    proceed :: Int -> IO Int
    proceed total = do
      chunk <- T.hGetChunk handle
      if T.null chunk
        then
          return total
        else
          proceed (T.length chunk + total)
-- beyond IO
repeatUntil :: (Monad m) => m chunk -> (chunk -> Bool) -> (chunk -> m ()) -> m ()
repeatUntil getChunk isEnd f = do
  chunk <- getChunk
  if isEnd chunk
    then
      return ()
    else do
      f chunk
      repeatUntil getChunk isEnd f
-- when and unless
#+end_src

** 3 Bytes
*** Packed octets (bytestream, ByteString)

from =bytestream= package

#+begin_src haskell
import qualified Data.ByteString as BS
#+end_src

- ~Data.Word~ module provides Word8/16/32/64 types
  - =Word8= type represents a byte (octect)

#+DESC: in BS package
#+begin_src haskell
pack   :: [Word8] -> ByteString
unpack :: ByteString -> [Word8]
null   :: ByteString -> Bool
#+end_src

*** Copying a file (hPut, hGetSome)

#+DESC: in BS package
#+begin_src haskell
hPut     :: Handle     -> ByteString -> IO ()
hGetSome :: Handle     -> Int        -> IO ByteString -- input max chunk size to get
#+end_src

reading from a file, and writting to another one

#+begin_src haskell
  copyGreetingFile :: IO ()
  copyGreetingFile = runResourceT do
#+end_src

*** Characters encodings (encodeUtf8,decodeUtf8')

- =Much of the HTTP protocol uses ASCII=

- To WRITE text as a byte string, you must choose an encoding.
- To READ a byte string as text, you must know how it was encodes.

- Text vs ByteString
  - There is no single pair of functions to convert between
  - Conversions can fail, depending on the encoding
    - ASCII bytes 128-255 are invalid
    - UTF-8
      - encoding never fails
      - decoding can fail

- [Char] vs [Word8]
  - when we do both
    - writting in natural language
    - and writting to a file
  - we need a way to map between them

|--------+------------+----------|
|    <r> |    <c>     |   <c>    |
|        | bytes/char |  width   |
|--------+------------+----------|
|  ASCII |     1      |  fixed   |
|  UTF-8 |    1-4     | variable |
| UTF-16 |    2-4     | variable |
| UTF-32 |     4      |  fixed   |
|--------+------------+----------|
*** Dangerous classes (IsString)

- =Show=
  - exists for the sake of GHCi and for testing, not for real use in applications
  - we recommend never allowing the behavior of your program to depend on the ~show~ function

- =IsString= defined in Data.String
  - for String=>ByteString relies on pack, which crudely truncates UTF chars
  - related to OverloadedStrings: implicitly runs ~fromString~ when a "string" is found
  #+begin_src haskell
    class IsString a where
      fromString :: String -> a
  #+end_src

*** Avoiding system defaults (hSetBinaryMode)

- hPutStrLn and others rely on the OS defaults to choose
  1) string encodings
  2) line termination

- to disable System.IO defaults detection
  #+begin_src haskell
    hSetBinaryMode :: Handle -> Bool -> IO ()
  #+end_src

**** Example: Hello world with no defaults

#+begin_src haskell
  helloByteString :: IO ()
  helloByteString = do
    IO.hSetBinaryMode stdout True
    BS.hPut stdout (BS.pack helloBytes)
    BS.hPut stdout (T.encodeUtf8 (T.pack "hello world!\n"))

  helloBytes = [
    104, 101, 108, 108, 111,    -- hello
    32,                         -- space
    119, 111, 114, 108, 100, 33 -- world!
    10 ]                        -- \n
#+end_src

*** Exercises
A character encoding bug
Byte manipulation

#+begin_src haskell
asciiUpper :: BS.ByteString -> BS.ByteString
asciiUpper = BS.map convert
  where
    convert :: Word8 -> Word8
    convert w
      | w > 96 && w < 123 = w - 32
      | otherwise = w
#+end_src

** 4 Sockets

- The OS interface for sending/receiving data from the internet.
- There are still *handles* (aka socket handles). An OS identifier for the conversation.
- Chapter uses =network= library

#+begin_src haskell
  import Network.Socket (Socket)
  import qualified Network.Socket as S
  import qualified Network.Socket.ByteString as S
#+end_src

*** Open up and connect (socket, connect, recv, sendAll)

#+begin_src haskell
makeFriend :: S.SockAddr -> IO ()
makeFriend address = do
  s <- S.socket S.AF_INET S.Stream S.defaultProtocol -- open socket
  S.connect s address                                -- connect to address
  S.sendAll s $ T.encodeUtf8 $ T.pack "Hello friend" -- send msg
  repeatUntil (S.recv s 1024) BS.null BS.putStr      -- listen for reply and print it
#+end_src

*** Extra details (gracefulClose, close, setSocketOption)

#+begin_src haskell
makeFriendSafely :: S.SockAddr -> IO ()
makeFriendSafely address = runResourceT do
  (_, s) <- allocate (S.socket S.AF_INET S.Stream S.defaultProtocol) S.close
  liftIO do
    S.setSocketOption s S.UserTimeout 1000
    S.connect s address -- connect to address
    S.sendAll s $ T.encodeUtf8 $ T.pack "Hello friend" -- send msg
    repeatUntil (S.recv s 1024) BS.null BS.putStr -- listen for reply and print it
    S.gracefulClose s 1000 -- normal close
#+end_src

- socket closing functions: it's ok to run both on the same ~Socket~ handle
  - ~gracefulClose~: under normal circumstances, we wait a bit for the other side to cleanup
  - ~close~: when the OS demands a prompt clean up, or in an exception abrustly ending the communication is desired

*** Names and addresses (tupleToHostAddress, SockAddr constructors)

#+begin_src haskell
data SockAddr -- as defined in Network.Socket
  = SockAddrInet PortNumber HostAddr
  | SockAddrInet6 PortNumber FlowInfo HostAddress6 ScopeID
  | SockAddrUnix String
#+end_src

#+begin_src haskell
tupleToHostAddress :: (Word8,Word8,Word8,Word8) -> HostAddress
makeFriendSafely $ S.SockAddrInet 80 $ S.tupleToHostAddress (147,75,67,13)
#+end_src

*** Address information (getAddrInfo, openSocket)

- AddrInfo = SockAddr + "all the information about the protocol that you need to construct"
- getAddrInfo function is the Hasekll equivalent to the *host* command
  #+begin_src haskell
    getAddrInfo
      :: Maybe AddrInfo    -- hint eg: Just (S.defaultHints{ S.addrFamily = AF_INET6 })
      -> Maybe HostName    -- eg: Just "www.haskell.org"
      -> Maybe ServiceName -- eg: Just "http"
      -> IO [AddrInfo]
  #+end_src

#+begin_src haskell
  Data.Foldable.traverse_ print
    =<< S.getAddrInfo (Just S.defaultHints{ S.addrFamily = S.AF_INET })
                      (Just "www.haskell.org")
                      (Just "http")
#+end_src

#+begin_src haskell
findHaskellWebsite :: IO S.AddrInfo
findHaskellWebsite = do
  addrInfos <-
    S.getAddrInfo
      (Just S.defaultHints {S.addrSocketType = S.Stream})
      (Just "www.haskell.org")
      (Just "http")
  case addrInfos of
    [] -> fail "getAddrInfo returned []"
    x : _ -> return x
#+end_src

=openSocket= is more convenient when we have a ~AddrInfo~ instead of a ~SockAddr~

#+begin_src haskell
makeFriendAddrInfo :: S.AddrInfo -> IO ()
makeFriendAddrInfo addressInfo = runResourceT do
  (_, s) <- allocate (S.openSocket addressInfo) S.close -- openSocket
  liftIO do
    S.setSocketOption s S.UserTimeout 1000
    S.connect s (S.addrAddress addressInfo) -- using addrAddress to get the field from AddrInfo
    S.sendAll $ T.encodeUtf8 $ T.pack "Hello, friend"
    repeatUntil (S.recv s 1024) BS.null BS.putStr
    S.gracefulClose s 1000
#+end_src

*** Exercises

improper ResourceT allocation: since ~connect~ can throw it should go outside ~allocate~

#+begin_src haskell
openAndConnect' :: S.AddrInfo -> ResourceT IO (ReleaseKey, Socket)
openAndConnect' addressInfo = do
  (rk, s) <- allocate (S.openSocket addressInfo) S.close
  liftIO do
    S.setSocketOption s S.UserTimeout 1000
    S.connect s (S.addrAddress addressInfo)
  return (rk, s)
#+end_src

explore gopherspace: Gopher serves the same purpose than the HTTP protocol

#+begin_src haskell
helloGopher :: IO ()
helloGopher = do
  addr <- findHaskellWebsite'
  runResourceT do -- once ran his life cycle is done and anything returned done for
    (_, s) <- openAndConnect addr
    liftIO do
      S.sendAll s $ T.encodeUtf8 $ T.pack "\r\n"
      repeatUntil (S.recv s 1024) BS.null BS.putStr
      S.gracefulClose s 1000
#+end_src

address resolution

#+begin_src haskell
resolve :: S.ServiceName -> S.HostName -> IO S.AddrInfo
resolve service hostname = do
  addrInfos <-
    S.getAddrInfo
      (Just S.defaultHints {S.addrSocketType = S.Stream})
      (Just hostname)
      (Just service)
  case addrInfos of
    [] -> fail "getAddrInfo returned []"
    x : _ -> return x
#+end_src

** 5 HTTP

- New (2022) HTTP features
  1) a client can send documents
  2) the documents can be of any kind of data
  3) requests/responses can contain additional metadata
  4) is possible to make multiple requests over a single connection

*** The specification

- v1 revisions
  |-----+----+------|
  | ver | yy |  RFC |
  |-----+----+------|
  | 0.9 | 91 |    - |
  | 1.0 | 96 | 1945 |
  | 1.1 | 97 | 2068 |
  |     | 99 | 2616 |
  |     | 14 | 7230 |
  |     | 14 | 7231 |
  |     | 22 | 9110 |
  |     | 22 | 9112 |
  |-----+----+------|

*** HTTP requests

- the first line is called ~request line~
  - request method
  - resource
  - protocol version

- then come the ~fields~

*** ASCII strings (ascii package)

#+begin_src haskell
line :: BS.ByteString -> BS.ByteString
line x = x <> fromString "\r\n"

helloRequestString :: BS.ByteString
helloRequestString =
  line (fromString "GET /hello.txt HTTP/1.1")
    <> line (fromString "User-Agent: curl/7.64.1")
    <> line (fromString "Accept-Language: en, mi")
    <> line (fromString "")
#+end_src

using the =ascii= package

#+begin_src haskell
{-# LANGUAGE QuasiQuotes #-}
import qualified ASCII as A
import qualified ASCII.Char as A

helloRequestString' :: BS.ByteString
helloRequestString' =
  line' [A.string|Get /hello.txt HTTP/1.1|]
    <> line' [A.string|User-Agent: curl/7.64.1|]
    <> line' [A.string|Accept-Language: en, mi|]
    <> line' [A.string||]

crlf :: [A.Char]
crlf = [A.CarriageReturn, A.LineFeed]

line' :: BS.ByteString -> BS.ByteString
line' x = x <> A.fromCharList crlf
#+end_src

*** HTTP responses

- the first response line is the ~status line~
  - protocol version
  - status code

- Content-Type: aka the MIME type
- Content-Length:
  - in bytes, without considering the header
  - to let the client know for how long it should read

#+begin_src haskell
helloResponseString :: BS.ByteString
helloResponseString =
  line' [A.string|HTTP/1.1 200 OK|]
    <> line' [A.string|Content-Type: text/plain; charset=us-ascii|]
    <> line' [A.string|Content-Lenght: 6|]
    <> line' [A.string||]
    <> [A.string|Hello!|]
#+end_src

*** Serving others (network-simple package, send, recv, serve)

- network-simple package
  - https://hackage.haskell.org/package/network-simple
  - https://github.com/k0001/network-simple

#+begin_src haskell
  import Network.Simple.TCP (serve, HostPreference (..))
  import qualified Network.Simple.TCP as Net
#+end_src

- Net.send instead of ~S.sendAll~
  - output is polymorphic "m a" with MonadIO, instead of "IO a"
  - sparing you a liftIO in a ResourceT context
- Net.recv instead of ~S.recv~
  - output is polymorphic "m (Maybe ByteString)"
  - instead of relying on an null/empty output to signal the end
- Net.serve
  - we do NOT need to worry about closing the socket
  - connections are handled concurrently, one per thread
  #+begin_src haskell
    serve :: MonadIO m
          => HostPreference               -- eg: HostAny
          -> ServiceName                  -- eg: "http", "8000"
          -> ((Socket,SockAddr) -> IO ()) -- handler/callback
          -> m a
  #+end_src

**** Example: Net.serve
#+begin_src haskell
ourFirstServer :: IO ()
ourFirstServer =
  Net.serve HostAny "8000" go
  where
    go :: (Socket, S.SockAddr) -> IO ()
    go (s, a) = do
      putStrLn ("New connection from: " <> show a)
      Net.send s helloResponseString
#+end_src

*** Exercises
repeat until nothing

#+begin_src haskell
repeatUntilNothing :: (Monad m) => m (Maybe chunk) -> (chunk -> m ()) -> m ()
repeatUntilNothing getMChunk f = do
  mChunk <- getMChunk
  case mChunk of
    Nothing -> return ()
    Just chunk ->
      f chunk >> repeatUntilNothing getMChunk f
#+end_src

make an http request

#+begin_src haskell
helloHaskellClose :: BS.ByteString
helloHaskellClose =
  line' [A.string|GET / HTTP/1.1|]
    <> line' [A.string|Host: haskell.org|]
    <> line' [A.string|Connection: close|]
    <> line' [A.string||]

myGetHaskellClose :: IO ()
myGetHaskellClose = runResourceT do
  addr <- liftIO $ resolve "http" "haskell.org"
  (_, s) <- openAndConnect addr
  liftIO do
    S.sendAll s helloHaskellClose
    repeatUntilNothing (Net.recv s 1024) BS.putStr
    S.gracefulClose s 1000
#+end_src

test the hello server

** 6 HTTP types

#+begin_src haskell
  import ASCII (ASCII)
  import ASCII.Decimal (Digit (..))
  import qualified Data.ByteString.Lazy as LBS

  data Version = Version Digit Digit

  data Request = Request RequestLine [Field] (Maybe Body)
  data RequestLine = RequestLine Method RequestTarget Version
  data Method = Get | Post -- | Head | Put | Delete | Connect | Options | Trace
  data Method = Method (ASCII ByteString)
  data RequestTarget = RequestTarget (ASCII ByteString)

  data Response = Response StatusLine [Field] (Maybe Body)
  data StatusLine = StatusLine Version StatusCode (Maybe ReasonPhrase)
  data StatusCode = StatusCode Digit Digit Digit
  data ReasonPhrase = ReasonPhrase (ASCII ByteString)

  data Field = Field FieldName FieldValue
  data FieldName = FieldName (ASCII ByteString) -- RFC says you can make up your own field name
  data FieldValue = FieldValue (ASCII ByteString)

  data Body = Body (ASCII LBS.ByteString) -- LByteString in "relude"
#+end_src

*** The ASCII type

#+begin_src haskell
  import ASCII (ASCII)
  -- when we know for a fact that a string is valid ASCII, we use the constructor
  newtype ASCII string = ASCII string
  -- or manual conversion
  convertStringMaybe :: ByteString -> Maybe (ASCII ByteString)
  lift :: ASCII ByteString -> ByteString
  -- otherwise, we can use the quasiquotes
  http :: ASCII ByteString
  http = [A.string|HTTP|]
#+end_src

*** Body (Data.ByteString.Lazy module)

you can think of a lazy bytestring as a [bytestring], a list of strict bytestrings

#+NAME: fns defined on Data.ByteString.Lazy
#+begin_src haskell
  fromChunks ::   [ByteString] -> LBS.ByteString
  toChunks   :: LBS.ByteString -> [ByteString]
  fromStrict ::     ByteString -> LBS.ByteString
  toStrict   :: LBS.ByteString -> ByteString
#+end_src

*** Exercises

construct some values

#+begin_src haskell
helloRequest :: Request
helloRequest =
  Request start [host, lang] Nothing
  where
    start = RequestLine (Method [A.string|GET|]) (RequestTarget [A.string|/hello.txt|]) (Version Digit1 Digit1)
    host = Field (FieldName [A.string|Host|]) (FieldValue [A.string|www.example.com|])
    lang = Field (FieldName [A.string|Accept-Language|]) (FieldValue [A.string|en, mi|])

helloResponse :: Response
helloResponse =
  Response (StatusLine version code Nothing) fields body
  where
    code = StatusCode Digit4 Digit0 Digit4
    version = Version Digit1 Digit1
    fields =
      [ Field (FieldName [A.string|Content-Type|]) (FieldValue [A.string|text/plain; charset=us-ascii|]),
        Field (FieldName [A.string|Content-Length|]) (FieldValue [A.string|6|])
      ]
    body = Just $ Body [A.string|Hello!|]
#+end_src

infinite byte strings (create one and "take" some of it without blowing up)

** 7 Encoding

from Response to ByteString

#+begin_src haskell
  import qualified Data.ByteString.Builder as BSB
  import qualified Data.Text.Lazy.Builder as TB
  import qualified Data.Text.Lazy as LT
  import qualified Data.Text.Lazy.IO as LT -- putStrLn
#+end_src

*** String builders (Builder,LText)

- they support _efficient_ concatenation

- from
  #+begin_src haskell
sayHello :: Text -> Text
sayHello name = T.pack "hello, " <> name <> T.pack "!"
  #+end_src

- to
  #+begin_src haskell
sayHelloWithBuilder :: Text -> Text
sayHelloWithBuilder name =
  LT.toStrict -- optional: get it into a contiguos area of memory
  $ TB.toLazyText
  $ TB.fromString "Hello " <> TB.fromText name <> TB.fromString "!"
  #+end_src

- each piece of data is wrapped in the builder type of Data.Text.Lazy.Builder
  #+begin_src haskell
fromText     :: Text    -> Builder
fromLazyText :: LText   -> Builder
fromString   :: String  -> Builder
toLazyText   :: Builder -> LText   -- once we joined all the little builders
  #+end_src

*** Measuring time (aka benchmarking) (time package)

aka poor's man benchmarking, using =time= package

#+begin_src haskell
  import qualified Data.Time as Time

  time :: IO () -> IO ()
  time action = do
    a <- Time.getCurrentTime
    action
    b <- Time.getCurrentTime
    print (Time.diffUTCTime b a)
#+end_src

we use fold+replicate create

#+begin_src haskell
  concatWithStrict :: Int -> Text
  concatWithStrict numberOfTimes =
    fold $ replicate numberOfTimes $ T.pack "a"

  concatWithBuilder :: Int -> Text
  concatWithBuilder numberOfTimes = LT.toStrict $ TB.toLazyText $ -- avoid lazyness for a more fair test
    fold $ replicate numberOfTimes $ TB.fromString "a"

  concatSpeedTest :: Int -> IO ()
  concatSpeedTest n = do
    dir <- getDataDir
    time $ T.writeFile (dir </> "strict.txt") (concatWithStrict n) -- 50000 = 2.46s
    time $ T.writeFile (dir </> "builder.txt") (concatWithBuilder n) -- 50000 =  0.004s
#+end_src

*** High-order encoding

#+begin_src haskell
repeatedlyEncode :: (a -> BSB.Builder) -> [a] -> BSB.Builder
repeatedlyEncode = foldMap

optionallyEncode :: (a -> BSB.Builder) -> Maybe a -> BSB.Builder
optionallyEncode = maybe mempty -- could have been foldMap too since Maybe is Foldable
#+end_src

*** The start line (encodeRequestLine, encodeStatusLine

- ASCII - lift Space fromCharList fromDigitList
- BSB - Builder byteString

#+begin_src
HTTP-version = HTTP-name "/" DIGIT "." DIGIT
HTTP-name    = %s"HTTP"
#+end_src

#+begin_src haskell
encodeVersion :: Version -> BSB.Builder
encodeVersion (Version x y) = [A.string|HTTP/|] <> A.fromDigitList [x] <> [A.string|.|] <> A.fromDigitList [y]
#+end_src

#+begin_src
request-line = method SP request-target SP HTTP-version CRLF
#+end_src

#+begin_src haskell
encodeRequestLine :: RequestLine -> BSB.Builder
encodeRequestLine (RequestLine method target version) =
  encodeMethod method
    <> space
    <> encodeRequestTarget target
    <> space
    <> encodeVersion version
    <> encodeLineEnd
  where
    space = A.fromCharList [A.Space]
    encodeMethod (Method x) = BSB.byteString $ A.lift x
    encodeRequestTarget (RequestTarget x) = BSB.byteString $ A.lift x
#+end_src

#+begin_src
status-line   = HTTP-version SP status-code SP [ reason-phrase ] CRLF
status-code   = 3DIGIT
reason-phrase = 1*( HTAB / SP / VCHAR )
#+end_src

#+begin_src haskell
encodeStatusLine :: StatusLine -> BSB.Builder
encodeStatusLine (StatusLine version code reason) =
  encodeVersion version
    <> space
    <> encodeStatusCode code
    <> space
    <> optionallyEncode encodeReasonPhrase reason
    <> encodeLineEnd
  where
    space = A.fromCharList [A.Space]
    encodeStatusCode (StatusCode x y z) = A.fromDigitList [x, y, z]
    encodeReasonPhrase (ReasonPhrase s) = BSB.byteString $ A.lift s
#+end_src

*** Exercises

field encoding
#+begin_src haskell
encodeField :: Field -> BSB.Builder
encodeField (Field (FieldName name) (FieldValue value)) =
  BSB.byteString (A.lift name) <> [A.string|: |] <> BSB.byteString (A.lift value)
#+end_src

message body encoding
#+begin_src haskell
encodeBody :: Body -> BSB.Builder
encodeBody (Body body) = BSB.lazyByteString (A.lift body)
#+end_src

encoding test

#+begin_src
ghci> encodeRequest $ helloRequest
"GET /hello.txt HTTP/1.1\r\nHost: www.example.com\r\nAccept-Language: en, mi\r\n"
ghci> encodeResponse $ helloResponse
"HTTP/1.1 404 \r\nContent-Type: text/plain; charset=us-ascii\r\nContent-Length: 6\r\n\r\nHello!"
#+end_src

** 8 Responding

goal: create a hit counter

*** A measure of success

ASCII - showIntegralDecimal

#+begin_src haskell
import Numeric.Natural (Natural)
countHelloAscii :: Natural -> ASCII LBS.ByteString
countHelloAscii count =
  [A.string|Hello!|] <> A.fromCharList crlf <> case count of
    0 -> [A.string|This page has never been viewed|]
    1 -> [A.string|This page has been viewed 1 time.|]
    _ ->
      [A.string|This page has been viewed |]
        <> A.showIntegralDecimal count
        <> [A.string| times.|]
#+end_src

*** Response-building utilities

see the =http-types= package for more

#+begin_src haskell
data Status = Status StatusCode (Maybe ReasonPhrase)

ok :: Status
ok = Status code phrase
  where
    code = StatusCode Digit2 Digit0 Digit0
    phrase = Just (ReasonPhrase [A.string|OK|])

status :: Status -> StatusLine
status (Status code phrase) =
  StatusLine http_1_1 code phrase

http_1_1 :: Version
http_1_1 = Version Digit1 Digit1

contentType :: FieldName
contentType = FieldName [A.string|Content-Type|]

plainAscii :: FieldValue
plainAscii = FieldValue [A.string|text/plain; charset=us-ascii|]

contentLength :: FieldName
contentLength = FieldName [A.string|Content-Length|]
#+end_src

*** Integers
*** Response transmission
*** Exercises
read the header
overflow
* 23 | Learn Haskell by building a blogGenerator |          | Gil Mizrahi
- 04 https://gilmi.me/blog/post/2020/10/01/substitution-and-equational-reasoning
** 02 Hello World
- The order in which we declare the binding does NOT matter
** 03 Building an HTML printer library

- operators
  - ~fixity~: left or right
  - ~precedence~: a number between 0 and 10
  - (<>) has right fixity

- =referential transparency=
  - pretty unique to haskell
  - allows to /substitute/ two sided of an equal sign with another.

- multiple argument lambda
  \num1 -> \num2 -> num1 + num2
  \num1     num2 -> num1 + num2

- =combinator pattern= used in Haskell by many EDSLs (embedded domain specific language)
  - ~primitives~ basic building block of the language
  - ~combinators~ functions that combine primitves

*** Final Code

#+begin_src haskell
myHtml :: String
myHtml =
  makeHtml
    "Hello title"
    (h1_ "hello, world!" <> p_ "Let's learn about haskell")

makeHtml :: String -> String -> String
makeHtml title content =
  html_ (head_ (title_ title) <> body_ content)

wrapHtml :: String -> String
wrapHtml content = "<html><body>" <> content <> "</body></html>"

html_ :: String -> String
html_ = el "html"

body_ :: String -> String
body_ = el "body"

title :: String -> String
title content = el "title"

el :: String -> String -> String
el tag content =
  "<" <> tag <> ">" <> content <> "</>" <> tag <> ">"

escape :: String -> String
escape = concat . map escapeChar
  where
    escapeChar c =
      case c of
        '<'  -> "&lt;"
        '>'  -> "&gt;"
        '&'  -> "&amp;"
        '"'  -> "&quot;"
        '\'' -> "&#39;"
        _    -> [c]
#+end_src

*** Safe HTML construction with types

- =newtype=
  - to define a new distinct type for an *existing* type
  - wrapping/unwrapping has not performance cost
- =type= we reference the type name directly without a constructor, just _a name alias_
- =data= kind of a struct+enum chimera, where we can define multiple constructs to a type
- composition: (.) f g x = f (g x)

*** Preventing incorrect use with modules

- the module ~Main~ that defines *main*, can have any filename
- Linked Lists
  - not particularly space efficient
  - slow for appending
  - slow for random access
- What HTML characters to escape: https://stackoverflow.com/questions/7381974/which-characters-need-to-be-escaped-in-html
  &<>"'

*** Exposing internal functionality (Internal Modules)

- We can expose some ~Internal Modules~ to provide some flexibility to external users.
- It's a common design pattern or idiom in Haskell.
- *<something>.Internal* which exports all of the functionality and implementation details of the module.
  while the module <something> imports and re-exports only what we want public
- hello.hs
  Html.hs
  Html/Internal.hs

** 04 Custom Markup Language

- Features
|-----------------+-------------------------------------------------|
| Headings        | prefix by a number of * characters              |
| Paragraphs      | a group of lines without empty lines in between |
| Unordered lists | a group of lines each prefix with -             |
| Ordered lists   | a group of lines each prefix with #             |
| Code blocks     | a group of lines each prefix with >             |
|-----------------+-------------------------------------------------|

*** Representing the markup language as a haskell data type

#+begin_src haskell
  type Document = [Structure]
  data Structure
    = Heading Natural String
    | Paragram String
    | UnorderedLIst [String]
    | OrderedList [String]
    | CodeBlock [String]
#+end_src

- We represent the markup as a type, instead of a String for *flexibility* and *modularity*
- If the /parsing/ was *coupled* with /HTML generation/, we would lose the ability to pre-process the markup document.
  - For example:
    - Take only a small part of the document, and present it
    - Or create a ToC from headings

*** Parsing markup part 01 - Recursion

- split by lines, and group by paragraphs (which are separated by empty lines)
- Lazy *vs* Strict - Evaluation Strategy
  - *Evaluation Strategy*: refers to /when/ do we evaluate a computation
  - *Strict*: we _evaluate_ the arguments of a function before entering the function
  - *Lazy*: we only _evaluate_ computation when we need it (aka when it will have some effect on the outside world)
- Steps to think a problem recursively:
  1) Finding the *base case*, the most simple, the one we know how to answer
  2) Figuring out how to *reduce* the problem to something simpler, closer to 1)
  3) *Mitigating the difference* between 2) and the solution we need
- 2 & 3 are called ~recursive step~
- ~mutual recursion~ instead of directly calling ourselves in a function,
  we call another function that will eventually call ourselves back.
  #+begin_src haskell
    even' :: Int -> Bool
    even' 0 = True
    even' n = odd (n - 1)

      odd' :: Int -> Bool
    odd' 0 = False
    odd' n = even' (n - 1)
  #+end_src
- ~partial function~ a function that NOT returns for some value
  either due not terminating, or returning an error
- =Numeric.Natural= type throws an exception if you try to assign it a negative number
- =Data.List.NonEmpty= type promises that the list has at least 1 element

*** Displaying the parsing results (type classes)

#+begin_src haskell
  class Semigroup a where
    (<>) :: a -> a -> a

  instance Semigroup [a] where
    (<>) = (++)
#+end_src

- *print* works by calling show
  #+begin_src haskell
    print' :: Show a => a IO ()
    print' = putStrLn . show
  #+end_src

- defining an instance of the class ~Show~, aka providing an implemenation for the interface of a specific type can be done by just *deriving*

- ~typeclasses~
  - are often just interface with laws (aka expected behaviours)
  - can be used to create abstractions, were we don't actually care about concrete details, just their API
  - can provide rules or laws that the instances should satisfy
    - example:
      - can combine two values in some way, and (<>) should be associativce
      - _which Haskell type system CANNOT PROVE_

*** Parsing markup part 02 - Pattern Matching

- Author encourages to NOT use the multiple function definitions in favor of *case/of*
  - https://twitter.com/_gilmi/status/1257225601079029760
  - Reasons: (ME: 4 is the strongest)
    1) More to write
    2) More effort to change the name of the function
    3) More effort to add another argument
    4) For longer functions, harder to tell where it stars and where it ends (identation)
    5) Especially when you want to remove clutter by adding new lines between cases

- ~Maybe~ a way to avoid writing *partial functions*
  #+begin_src haskell
    data Maybe a = Nothing | Just a
  #+end_src
- =Data.Maybe.(listToMaybe,maybeToList)= aka safeHead

- sometimes, to avoid dealing with strings and unword'in in the middle of algorithm we could create a new data type with the correct structure.
  #+begin_src haskell
    data Context
      = CtxHeading Natural String
      | CtxParagraph [String]
      | CtxUnorderedList [String]
      | CtxOrderedList [String]
      | CtxCodeBlock [String]
  #+end_src

**** ~Data.Maybe.maybe~

- takes
  - a default value
  - a function to apply to 3rd value if not Nothing
  - a Maybe value

- We use it here to return a partially applied (:) function or (id)
  #+begin_src haskell
    -- parseLines :: ... -> [Structure]
    -- context :: Maybe Structure
    maybe id (:) context (parseLines Nothing rest)
  #+end_src

- ME: maybe is like a .OrValue() type of function in java/rust,
      but here we also use it with partial application

** 05 Gluing things together
*** Converting Markup to HTML

- notice how each module Markup and Html have their own ~Structure~ data type
- Convert.hs
  #+begin_src haskell
import qualified Html
import qualified Html.Internal as HI
import qualified Markup
  #+end_src
- We take advantage that Html.Structure is a *Semigroup*, and create an empty value.
  In Html.Internal
  We also create a function *concatStructure* to concat (<>) the values of [Html.Structure]
  #+begin_src haskell
empty_ :: Structure
empty_ = Structure ""

concatStructure :: [Structure] -> Structure
concatStructure list =
  case list of
    [] -> empty_
    x : xs -> x <> concatStructure xs
  #+end_src
- =Monoid=
  - using an *empty* value along with (<>) is what a *Monoid* is
  #+begin_src haskell
    class Semigroup a => Monoid a where
          mempty :: a
    instance Monoid Structure
      mempty = empty_
  #+end_src
  - Implementing a monoid, gives you access to *mconcat*, which does what concatStructure did
  - ~Sum~ and ~Product~ are instances of =Monoid= due a type cannot be instance of 2 different monoids
    As integers are instace of (+ 0) and (* 1)
- =Foldable=
  - unifies *map* and *mconcat* pattern
  - *foldMap* is the function you call to apply the function and then (<>)
  - *mconcat* is just a specialized version of fold for lists
    #+begin_src haskell
      fold    :: (Foldable t, Monoid m) => t m -> m
      mconcat :: Monoid m               => [m] -> m
    #+end_src
- Final convert funcion
  #+begin_src haskell
convert :: Html.Title -> Markup.Document -> Html.Html
convert title = Html.html_ title . foldMap convertStructure
  #+end_src

*** Working with IO
- We are goint to support different use cases
  1) If the user calls the program without arguments, reads/writes to stdin/stdout
  2) if the user calls the program with 2(two) arguments, takes them as the input/output file
  3) if OUTPUT already exists, asks for confirmation
  4) else print usage information
- Haskell is designed to support *non-strict semantics*, we use *Lazy Evaluation Strategy* (in GHC) to implement it.
- Lazyness /conflicts/ with the desire of have any type of IO (aka side-effects)
  #+begin_src haskell
addWithInput :: Int -> Int
addWithInput n = readIntFromStdin + 2

main =
  let result1 = addWithInput 1  -- won't be evaluated until we print
      result2 = addWithInput 2
  in
    print (result2 - result1) -- we ask first for (2)
  #+end_src
- There is an *interface*, along with the *type* IO.
  Requires that in order to /combine/ IO ops, we need to specify an *order*
- IO is an opaque type
  - Executing ~IO a~ is different from evaluating it.
  - Evaluating an ~IO a~ expression is pure. It will always reduce to the same description of a program.
**** *(>>=)* aka "bind"
      #+begin_src haskell
        (>>=) :: IO a -> (a -> IO b) -> b

        getLine >>= (\line -> putStrLn line) -- or
        getLine >>= putStrLn

        getLine >>= \honorific ->
          getLIne >>= \name ->
            putStrLn ("Hello " ++ honorific ++ " " ++ name)
      #+end_src
**** *(*>) and (>>)*
      same thing
      *> is a slightly more generalized version of >> and can always be used instead
      >> only exists to avoid breaking backward compatibility
      It means run the first IO, discard the result then run the second operation
      #+begin_src haskell
        (*>) :: IO a -> IO b -> IO b
        (>>) :: IO a -> IO b -> IO b
      #+end_src
**** *pure* and *return*
/pure/ is a more general version of /return/
useful when we want ot do some uneffectul computation that depnds on IO
"lift" a value into IO context, does NOT add any I/O effects
#+begin_src haskell
  confirm :: IO Bool
  confirm =
    putStrLn "Are you sure? (y/n)" *>
      getLine >>= \answer ->
        case answer of
          "y" -> pure True  -- !
          "n" -> pure False -- !
          _ ->
            putStrLn "Invalid response. use y or n" *>
              confirm
      #+end_src
**** fmap and <$>
#+begin_src haskell
  fmap :: (a -> b) -> IO a -> IO b
#+end_src
- The unified version of using *>>=* and *pure*
  #+begin_src haskell
    getLine >>= \line -> pure (line ++ "!")
    fmap (\line -> line ++ "!") getLine
  #+end_src
**** Functional core, imperative shell
- Is a pattern
- In Haskell, we like to keep IO usage minimal, and we like to push it ot the edged of the program.
- In many programming languages, we might interleave:
  - reading from the file parsing
  - writing to the file wiht HTML conversion
- But we don't mix these here.
- Especially good pattern to write batch programs
**** main.hs
- We use the auxiliary functions confirm/whenIO to write output only when we confirm
#+begin_src haskell
  import System.Directory (doesFileExists)
  import System.Environment (getArgs)
  -- import System.IO (getContents, readFile, writeFile) -- already imported by Prelude
  confirm :: IO Bool
  whenIO :: IO Bool -> IO () -> IO ()
#+end_src
**** do
- provides syntactic sugar for:
  1) expressions of type *IO ()* aka (*>)
  2) *let* statement inside it do NOT have *in* (aka let in)
  3) when using "var <- something" aka (>>=)
*** Defining a project description
- https://gilmi.me/blog/post/2021/08/14/hs-core-tools#using-external-packages-in-ghci
  Using external packages on ghci. Without a project description.
  > cabal repl --build-depends async --build-depends say
  > stack exec --package       async --package       say -- ghci
- initialize
  > cabal init --libandexe
  > stack new
- needs this on HsBlog.Html.Internal.hs, for deriving Semigroup
  {-# LANGUAGE GeneralizedNewtypeDeriving #-}
**** .cabal - package metadata
    - version: most use semver (https://semver.org/), but some use PvP (https://pvp.haskell.org/)
    - extra-doc-files: README CHANGELOG
**** .cabal - common common-settings
    - shared among all targets
    - default-language: Haskell2010
      ghc-options: -Wall
    - later on our targets we can include it by doing *import: common-settings*
**** .cabal - library
    - hs-source-dir: where to find the source files
    - build-depends: packages dependencies
    - exposed-modules: public modules
    - other-modules: private modules
**** .cabal - executable
    - main-is: where is Main module file
    - build-depends: we import our library here
**** cabal.project and stack.yaml
- additional files to add additional informations on how to build the package
- /stack.yaml/ is necessary for stack
  - resolver: snapshot to use for packages and ghc version (eg: lts-18.22)
  - packages: list of locations of the packages to build, use "- ."
- /cabal.project/ isn't for cabal
- build artifacts are on
  - dist
  - dist-newstyle
  - .stack-work
*** Fancy option parsing
- We want to add the feature of processing a while directory
- We could model our program use cases with *data*
  #+begin_src haskell
    data Options
      = ConvertSingle SingleInput SingleOutput
      | ConvertDir FilePath FilePath
      deriving (Show)

    data SingleInput
      = Stdin
      | InputFile FilePath
      deriving (Show)

    data SingleOutput
      = Stdout
      | OutputFile FilePath
      deriving (Show)
  #+end_src
- We could have used *Maybe FilePath* to encode *SingleInput* and *SingleOutput*,
  but then we would need to remember what *Nothing* means in each context.
- New use cases
  - they will use the command ~convert~ with flags *--input* and *--output*
  - if *--output* is not supplied it will STDOUT
  - if *--input* is not supplied it will take STDIN
  - for a directory it would use ~convert-dir~ command, where input/output are mandatory
**** <$> fmap
- allows to "lift" a function (a -> b) to work in a context of (C a -> C -> b)
- it belongs to the typeclass =Functor=
  #+begin_src haskell
    class Functor f where
      fmap :: (a -> b) -> f a -> f b
  #+end_src
- It has the following laws:
 | Identity    | fmap id = id                    | if we don't change the values, nothing should change                    |
 | Composition | fmap (f . g) == fmap f . fmap g | composing the lifted functions is the same as composing them after fmap |
  - Example: This won't follow the first law. Haskell doesn't help us make sure the laws are satisfied.
    #+begin_src haskell
      mapMaybe :: (a -> b) -> Maybe a -> Maybe b
      mapMaybe f maybeX = Nothing
    #+end_src
**** <*> Applicative
#+begin_src haskell
  class Functor f => Applicative f where
    pure   :: a             -> f a
    liftA2 :: (a -> b -> c) -> f a -> f b -> f c
    (<*>)  :: f (a -> b)    -> f a -> f b
#+end_src
- combining <*> and <$> allow us to apply a function with many argument instead of just 2(two)
  - both associate to the left
** TODO 06 Handing errors and multiple files
*** Handing errors with Either
*** Either with IO
*** Exceptions
*** Lets code already!
*** Summary
** TODO 07 Passing and Environment
** TODO 08 Writing tests
** TODO 09 Generating documentation
** TODO 10 Recap
* 23 | Effective Haskell                         | PragProg | Rebecca Skinner
ERRATA:
192
"You can export field constructors just..." should be
"You can export field selectors just..."
228
ghc error refers to "Show Password" a type that was never declared before
259
typo: on type constructor for "AdminUser" is "Adminuser" instead
289
typo+incoherent: With the withArgs function function will help you with both (!?) of those problems
301
typo: "When we put all of this togther..."
** DONE Introduction
- 1990 First version of Haskell
  - 1 year before Python
  - 5 years before Java
- Thanks to its ~purity~, Haskel can offer us
  strict guarantees about immutability
  across our entire program.
- Haskell's ~type system~ is more expressive
  than the type system of any other mainstream
  programming languange in use these days.
  - about what *kind* of data a variable holds
  - where it came from (?)
  - what can be done with it (implements?)
  - whether a function could fail (Maybe)
- Learning Haskell can lead to a "circular knowledge references"
- GHC 9.5 (Used by the book)
  GHC 9.4 (GHC2021)
  GHC 8.10 (Haskel2010)
- Libraries used
  - base, bytestring, base64-bytestring, text, containers,vxtor, time, unix, mtl, transformers, process
** DONE 01 Getting Started
- "The Haskell motto /avoid success at all costs/
  is a reminder that programming in Haskell
  sometimes means trading away
  immediate familiarity or comfort
  for power, flexibility, and correctedness."
- =Purity=
  - all values are immutable
  - all functions have to be free of any side effects
- =Lazyness=
  - it let us /write programs in ways that feel more natural/
    but might have significant negative performance cost
    in a strict language.
- ~/.ghci
  #+begin_src
    set prompt "λ"
  #+end_src
- ":{" and "}:" for entering multi-line statement on ghci
- list =range= with step != 1
  > [2,4..10]
  [2,4,6,8,10]
  > [10,9..0]
    [10,9,8,7,6,5,4,3,2,1,0]
- print = putStrLn . show
- STYLE: 2 spaces for indentation
- Variables are immutable.
  two  = 1
  two  = two + 1 // NEVER ENDS!! recursive lazy definition
  two' = two + 1
- =Currying=
  Thre process of converting a
  function that takes multiple arguments
  into a series of single-argument functions.
- In Haskell all functions are curried by default.
- =Fully saturated=
  When a function is called with ALL of its
  arguments and can return a value
  that isn't a function.
- =Eta reduction= removing extra parameters
  =Eta expansion= adding a parameter and passing it along
- You can =partially apply=
  the left or righ-hand operand independently
  of infix operators.
- Use backticks to partially apply the 2nd argument
  or *flip*
  #+begin_src haskell
    makeGreeting salutation person =
      salutation <> " " <> person

    greetGeorge  = (`makeGreeting` "George")
    greetGeorge' = flip makegreeting "George"
  #+end_src
- printStr, printStrLn, show, print, flip
- =Pointfree programming= aka tacit programming
  = eta-reduction + function composition
  #+begin_src haskell
    makeGreeting salutation person = salutation <> " " <> person
    makeGreeting salutation = ((salutation <> " ") <>)
    makeGreeting salutation = (<>) (salutation <> " ")
    makeGreeting = (<>) . (\salutation -> salutation <> " ")
    makeGreeting = (<>) . (<> " ")
  #+end_src
- Haskell Parsing rules
  - passing an argument to a *function* always has higher precedence than
    passsing that argument to an *operator*.
    aka higher =Binding precedence=
    #+begin_src haskell
      "the sum of " <> show 1 <> " and "
    #+end_src
  - Associativity
    - normal functions are =left associative=
    - infix functions and operators have a bit more flexibility
- let bindings
  - order does NOT matter
    you are free to reference bindings that you define later, in the same let expression
  - supports =recursive let bindings=
    items can refer to one another
  - in genera, for immediate values
- where binding
  - same rules than let
  - anything defined on it, will be available on the *let binding*
  - in general, used for ancillary and helper functions
  - visible to ALL branches when using *guards*
- Exercises: factorial, fibonacci, implement curry and uncurry functions
*** Example: Hello world!
#+begin_src haskell
  module Main where
  main = print "Hello, World!"
#+end_src
$ ghc Main
$ ./Main
"Hello, World!"
$ runhaskell Main.hs
"Hello, World!"
$ ghci
> load Main.hs
> main
"Hello, World!"
*** Operators
#+begin_src haskell
  infixl 6 +++
  module OperatorExample where
  (+++) a b = a + b -- OR
  a +++ b   = a + b
#+end_src
- must be named using symbols
  - starting with (:) is reserved for type constructors
- can create your own ~binary operators~
- with a possible =fixity declaration= declarations to define his *associativity*
  where N is the =precedence= level, from 0-9, defaults to 6
  |-------------+------------------------------------|
  | infixl N OP | for left  associativity            |
  | infixr N OP | for right associativity            |
  | infix  N OP | if the operator is NOT associative |
  |-------------+------------------------------------|
- using <> is popular when naming operators
- an expression might error, due being unable to be solved, without using parens (), either if:
  1) when no it has to associativity
     #+begin_src haskell
       True == True == False -- will ERROR
     #+end_src
  2) the associativity is different AND the precedence is the same
     #+begin_src haskell
       > a +++ b = a + b; infixr 7 +++
       > a *** b = a * b; infixl 7 ***
       > 1 +++ 2 *** 3 -- ERRORS (Precedence parsing error)
       > (1 +++ 2) *** 3
        9
       > 1 +++ (2 *** 3)
        7
     #+end_src
** 02 Working with Lists
- ? streaming data, generators, infinitely long lists
- ['h', 'i'] == "hi"
- VOCABULARY: consing, prepending, push an element onto the head
- =Partial functions=
   a function that doesn't work for all its possible inputs,
   and might raise a runtime exception
   or cause the program to crash. Eg: head, tail
- ~shape~ of a function,
  the essential behavior of a function or datatype,
  without any extraneous buseness logic or data structure
*** Example: factors - recursively constructing a list
- using a "common pattern" where our algorithm requires some
  initial seed value that we don't want to require the use to pass in.
#+begin_src haskell
  factors num =
    factors' num 2
    where
      factors' num fact
        | num == 1              = []
        | (num `rem` fact) == 0 = fact : factors' (num `div` fact) fact
        | otherwise             = factors' num (fact + 1)
#+end_src
*** Example: isbalanced - recursively deconstructing lists
#+begin_src haskell
  isBalanced s =
    0 === isBalanced' 0 s
    where
      isBalanced' count s
        | null s        = count
        | head s == '(' = isBalanced' (count + 1) (tail s)
        | head s == ')' = isBalanced' (count - 1) (tail s)
        | otherwise     = isBalanced' count (tail s)
#+end_src
*** Example: folds
- in a LEFT fold
  - the ~initial value~ is applied first
    at the left-hand side of the unrolled expression
  - the accumulator value is the first (left) argument
- in a RIGHT fold
  - the ~initial value~ is applied last,
    at the right-hand side fo the unrolled expression
  - the accumulator value is the second (right) argument
#+begin_src haskell
  foldl func carryValue lst =
    if null lst
    then carryValue
    else foldl func (func carryValue (head lst)) (tail lst)

  foldr func carryValue lst =
    if null lst
    then carryValue
    else func (head lst) $ foldr func carryValue (tail lst)

  foldl (+) 0 [1,2,3] -- (((0 + 1) + 2) + 3)
  foldr (+) 0 [1,2,3] -- (1 + (2 + (3 + 0)))

  -- associativity comes from fold, NOT operator
  infixr 9 `divide`
  divide = (/)
  foldl (/) 1 [1,2,3,4,5] == foldl divide 1 [1,2,3,4,5]
#+end_src
*** Example: map - defined with fold
- can be used to *apply* a value to a list of functions
  > map ($ 10) [(+ 1), (* 3), (`div` 5)]
   [11,30,2]
#+begin_src haskell
  doubleElems = foldr doubleElem []
    where
      doubleElem num lst = (2 * num) : lst

  doubleElems' = foldr (applyElem (*2)) [] elems
    where
      applyElem f elem accumulator = f elem : accumulator

  doubleElems'' = foldr (applyElem f) []
    where
      applyElem f elem accumulator = (f elem) : accumulator
#+end_src
*** Example: zip - pairwiseSum
#+begin_src haskell
  pairwiseSum xs ys = map (uncurry (+)) $ zip xs ys
#+end_src
*** =List Comprehensions=
They start to shine when you have severla lists that you want to work with, and many different filter.s
Useful when we want ALL the permutations of our lists.
#+begin_src haskell
  doubleOdds = [2 * number | number <- [0..10], odd number]
  -- without
  pairs as bs =
    let as' = filter (`elem` bs) as
        bs' = filter odd bs
        mkPairs a = map (\b -> (a,b)) bs
    in concat $ map mkPairs as'
  -- with
  pairs as bs =
    [(a,b)
    | a <- as
    , b <- bs
    , a `elem` bs
    , odd b]
#+end_src
*** =Pattern matching= can be used on functions, case, and let bindings
- let destructuring
  #+begin_src haskell
    fancyNumbers n = (zip fibs primes) !! n

    printFancy n =
      let (fib, prime) = fancyNumbers n -- destructuring
          fib'         = show fib
          prime'       = show prime
      in "The fibonacci number is: " <> fib' <> " and the prime is: " <> prime'

    modifyPair p@(a,b) -- destructuring
      | a == "Hello"  = "this is a salutation"
      | b == "George" = "this is a message for George"
      | otherwise     = "I don't know what " <> show p <> " means"
  #+end_src
- case+guards
  #+begin_src haskell
    handleNums l =
      case l of
           [] -> "An empty list"
           [x] | x == 0 -> "a list called: [0]"
               | x == 1 -> "a singular list of [1]"
               | even x -> "a singleton list containing an even number"
               | otherwise -> "the list contains " <> (show x)
           _list -> "the list has more than 1 element"
  #+end_src
*** =stream= or =generator=
- Haskell uses a form of laziness known as ~call by need~
  - expressions won't be evaluated until the value is actually needed
  - ~thunks~: expressions not evaluated yet
- a type of list that takes advange of lazy evaluatio
  whose tail is a thunk.
- Unlike recursion, it don't count down to a base case.
- Is =corecursive=, dual to recursion.
- we can only ~foldr~ against it
  we can't ~foldl~ on an infinite list
#+begin_src haskell
  numbersStartingAt n =
    n : numbersStartingAt (n + 1)

  -- folding right over an infinite list
  -- to FIND the first to match
  findFirst predicate =
    foldr findHelper []
    where
      findHelper listElement maybeFound
        | predicate listElement = [listElement]
        | otherwise             = maybeFound
#+end_src
*** TODO Example: fibonaci
page 85
#+NAME: optimized
#+begin_src haskell
fibs = 0 : 1 : helper fibs (tail fibs)
  where
    helper (a:as) (b:bs) =
      a + b : helper as bs
#+end_src
** DONE 03 Getting Started with Types
- a type is way of naming a set of values
- a value /inhabits/ a type
- a in "a -> a" is a =type variable=
- putting type annotations on let/where bindings is NOT a common style
*** =type annotations=
  - add them to to functions, in let and where bindings
  - improve readability, in functions eta-reduced or in pointfree style
    #+begin_src haskell
      pointful :: [Int] -> Int -> Int
      pointful xs n = foldr (+) 0 xs * n

      etaReduced :: [Int] -> Int -> Int
      etaReduced xs = (*) (foldr (+) 0 xs)

      pointfree :: [Int] -> Int -> Int
      pointfree = (*) . foldr (+) 0
    #+end_src
|------------------------+-------------------------------|
| monomorphic            | value represent a single type |
| parameric polymorphism |                               |
| ad hoc polymorphism    | ?                             |
|------------------------+-------------------------------|
*** =undefined=
- can help you making sure your types are right, before working on the implementation
  thanks to laziness
- can help us recognize/reuse functions
*** =Type Holes=
- give us a way to use Haskell's type inference more interactively
- useful when working with polymorphic functions in general
- useful when Haskell reports a type error,
  but is attributed to the wrong place
- created by replacing an expression by
   "\_" or "\_Name" or "\_fname" (without the backslash)
- compiler will give you an error message that tells you:
  1) what type should be to fill the type hole
  2) relevant bindings
  3) valid holde fits
** DONE 04 Creating New Types

#+begin_src haskell
  data Void
  data Unit = Unit -- "punning" between type and function name
  data CustomerInfo = CustomerInfo Bool -- 2 inhabitants
  data CustomerInfo = CustomerInfo Bool Bool -- 4 inhabitants
  data CustomerInfo = CustomerInfo String String Int Int
#+end_src

- Resume: You'll learn how to create your own types that accurately represent the structure of your data.

- =Value Constructor=
  - Is a special function that lets us create a new value of a certain type.

- *pattern matching* out fields of a type
  - Works well for /small/ types, as you might want to access all or most fields
    But it becomes cumbersome for /larger/ types
  - For that you can create getters and setters functions
    or we can use records

- =Product Types=
  are those types which increases multiplicatively,
  based on the number of inhabitants of each parameter to the *value constructor*

- Whenever you find yourself wanting to work with a fixed number of operation, a ~sum type~ is a good first thing to start thinking about.

- Text.Read.readEither

*** Records aka =product types=

- are product types with named parameters
- ~field selectors~ are automatically created
- try *RecordWildCards*
- when you have conflicting field names in >1 record
  - separate them in different modules or
  - use a naming convetion, prefix the field name, with the record type name

#+begin_src haskell
  data CustomerInfo = CustomerInfo
    { firstName :: String
    , lastName :: String
    , widgetCount :: Int
    , balance :: Int
    }
  -- 1) constructing
  CustomerInfo "George" "Bird" 10 100
  -- 2) constructing - with named arguments
  CustomerInfo
    { balance = 100
    , lastName = "Bird"
    , firstName = "George"
    , widgetCount = 10
    }
  -- 3) record update syntax
  emptyCart :: CustomerInfo -> CustomerInfo
  emptyCart customer =
    customer { widgetcount = 0
             , balance = 0
             }
#+end_src

*** Enums - aka =sum types=
#+begin_src haskell
  data Bool = True | False
  data Direction = North | South | East | West
  #+end_src
- types that represent a choice between two types
*** sum product

if we will instead used different types
we won't have issues either with
1) the constructors
2) or accepting them as arguments
returning them is what will be a problem

#+begin_src haskell
data PreferredContactMethod -- sum of products
  = Email       String
  | TextMessage String
  | Mail String String String Int
-- it is more common to use CASE rather than FUNCTION level pattern matching
confirmContact :: PreferredContactMethod -> String
confirmContact contact =
  case contact of
       Email emailAddress ->
         "Okay, I'll email you at " <> emailAddress
       TextMessage{} -> -- when we don't care about the fields
         "Okay, I'lll text you!"
       Mail street1 street2 citystate zip ->
         "Okay, I'll send a letter to \n"
         <> street1 <> "\n"
         <> street2 <> "\n"
         <> citystate <> " " <> show zip
#+end_src
*** sum product - with records
- 2(two) records can have same field names
- ~PITFALL~:
  if you try to access a field that doesn't exists on a record
  you get a runtime exception.
  #+begin_src haskell
    data Person
      = Customer
      { name    :: String
      , balance :: Int
      }
      | Employee
      { name        :: String
      , managerName :: String
      , salary      :: Int
      }
  #+end_src
- That is why is better to just create different records
  and then sum the types.
  #+begin_src haskell
    data CustomerInfo = CustomerInfo
      { customerName    :: String
      , customerBalance :: Int
      }
    data EmployeeInfo = EmployeeInfo
      { employeeName        :: String
      , employeeManagerName :: String
      , employeeSalary      :: Int
      }

    data Person
      = Customer CustomerInfo
      | Employee EmployeeInfo

    -- to make it easier to get data that exists
    -- for all diferent potential values in our sum type
    getPersonName :: Person -> String
    getPersonName person =
      case person of
        Employee employee -> employeeName employee
        Customer customer -> customerName customer
  #+end_src
*** polymorphic types
#+begin_src haskell
  -- type VARIABLE "a", is a type PARAMETER
  -- of the type CONSTRUCTOR "Maybe"
  -- which we cannot call it plainly "a type"
  data Maybe a = Nothing | Just a

  -- Left  error
  -- Right success
  data Either a b = Left a | Right b
#+end_src
- Maybe is frequently used
  1) signal optional inputs to a functions
  2) or to make partial functions safe
**** Example: passing a parameterized type as an argument to another parameterized type.
you need to use parentheses to group the types
#+begin_src haskell
  handleMissingRight :: Either String (Maybe a) -> Either String a
  handleMissingRight e =
    case e of
      Left err         -> Left err
      Right (Just val) -> Right val
      Right Nothing    -> Left "Missing value"
#+end_src
*** Inductively Defined Data Structures
- Due *lazyness* most datastructures defined in Haskell
  are recursive, aka ~inductively defined~
**** Peano Numbers: a way to represent whole numbers as a recursive numbers
#+begin_src haskell
  data Peano
     = Z       -- zero
     | S Peano -- successor

  toPeano :: Int -> Peano
  toPeano 0 = Z
  toPeano n = S (toPeano $ n - 1)

  fromPeano :: Peano -> Int
  fromPeano Z     = 0
  fromPeano (S p) = succ (fromPeano p)

  eqPeano :: Peano -> Peano -> Bool
  eqPeano p p' =
    case (p,p') of
      (Z,Z)       -> True -- base case
      (S n, S n') -> eqPeano n n'
      _           -> False
  -- recursively destructuring 1st parameter
  -- while adding 1 constructor (layer) to the right one
  addPeano :: Peano -> Peano -> Peano
  addPeano Z b     = b
  addPeano (S a) b = addPeano a (S b)
  #+end_src
**** Inductively defined lists
#+begin_src haskell
  data List a = Empty | Cons a (List a)

  toList :: [a] -> List a
  toList []     = Empty
  toList (x:xs) = Cons x (toList xs)

  fromList :: List a -> [a]
  fromList Empty       = []
  fromList (Cons x xs) = x : fromList xs

  -- refactoring the recursion OUT of them
  -- using higher order functions
  toList :: [a] -> List a
  toList = foldr Cons Empty

  -- we need a fold function for our custom List type
  fromList :: List a -> [a]
  fromList = listFoldr (:) []

  listFoldr :: (a -> b -> b) -> b -> List a -> [b]
  listFoldr _ acc Empty       = acc
  listFoldr f acc (Cons x xs) = f x $ listFoldr f acc xs

  -- TODO:
  listFoldr   :: (b -> a -> b) -> b -> List a -> b
  listHead    :: List a -> Maybe a
  listTail    :: List a -> List a
  listReverse :: List a -> List a
  listMap     :: (a -> b) -> List a -> List b
#+end_src
*** Example: Calculator
**** Expr - data structure
#+begin_src haskell
data Expr = Lit Int
    | Sub Expr Expr
    | Add Expr Expr
    | Mul Expr Expr
    | Div Expr Expr
#+end_src
**** eval - evaluator
#+begin_src haskell
eval :: Expr -> Int
eval expr =
  case expr of
    Lit num -> num
    Add x y -> (eval x) + (eval y)
    Sub x y -> (eval x) - (eval y)
    Mul x y -> (eval x) * (eval y)
    Div x y -> (eval x) `div` (eval y)

-- reactoring the recursion part into a separate function
eval :: Expr -> Int
eval expr =
  case expr of
    Lit num -> num
    Add x y -> eval' (+) x y
    Sub x y -> eval' (-) x y
    Mul x y -> eval' (*) x y
    Div x y -> eval' div x y
    where
      eval' :: (Int -> Int -> Int) -> Expr -> Expr -> Int
      eval' op x y = op (eval x) (eval y)
#+end_src
**** parse - parser
- Steps
  1) tokenize ourinput string
  2) parse'
  3) final error handling
- parse' returns a tuple of an Expr and [String].
  - A ~common pattern~, when implementing recursive parsers.
  - Recursive calls will consume some part of the input,
    and return the reminder of the input.
#+begin_src haskell
parse :: String -> Either String Expr
parse str =
  case parse' (words str) of
    Left err       -> Left err
    Right (e,[])   -> Right e
    Right (_,rest) -> Left $ "Found extra tokens: " <> (unwords rest)
  where
    parse' :: [String] -> Either String (Expr,[String])
    parse' []     = Left "unexpected end of expression"
    parse' (w:ws) =
      case w of
        "+" -> parseBinary Add ws
        "-" -> parseBinary Sub ws
        "/" -> parseBinary Div ws
        "*" -> parseBinary Mul ws
        lit ->
          case readEither lit of
            Left err   -> Left err
            Right lit' -> Right (Lit lit', ws)

    parseBinary ::
      (Expr -> Expr -> Expr)
      -> [String]
      -> Either String (Expr, [String])
    parseBinary exprConstructor args =
      case parse' args of
        Left err -> Left err
        Right (firstArg,rest') ->
          case parse' rest' of
            Left err -> err
            Right (secondArg,rest'') ->
              Right $ (exprConstructor firstArg secondArg, rest'')

run :: String -> String
run expr =
  case parse expr of
    Left err    -> "Error: " <> err
    Right expr' ->
      let answer = show $ eval expr'
      in "The answer is: " <> answer
#+end_src
*** Functions as values

- A value you might sometimes want to hold
  inside of a ~data~ type is a function.
#+begin_src haskell
  data StringParser =
     StringParser (String -> (String, String))
#+end_src


- more often, they'll be records with field
  that gives the function some useful name
#+begin_src haskell
  data StringParser =
    StringParser { runStringParser :: String -> (String, String) }
#+end_src

- wrapped inside of a StringParser, will make it somewhat easier to work with (?)
#+begin_src haskell
  takeCharacters :: Int -> StringParser
  takeCharacters numCharacters = StringParser $ \inputString ->
    splitAt numCharacters inputString

  getNextWord :: StringParser
  getNextWord = StringParser $ \someString ->
    case break (== ' ') someString of
      (nextWord, "")   -> (nextWord, "")
      (nextWord, rest) -> (nextWord, tail rest)
#+end_src

- for example, we can have a function that combines 2(two) StringParsers
  #+begin_src haskell
    combineParsers :: StringParser -> StringParser -> StringParser
    combineParsers firstParser secondParser = StringParser $ \someString ->
      let (_firstPart, firstResult) = runStringParser firstParser someString -- runStringParser is a record field
      in runStringParser secondParser firstResult
  #+end_src

- this lets us re-use existing functions that we've already written
  #+begin_src haskell
    getNextWordAfterTenLetters :: StringParser
    getNextWordAfterTenLetters =
      combineParser (takeCharacters 10) getNextWord

    tenLettersAfterTheFirstWord :: StringParser
    tenLettersAfterTheFirstWord =
      combineParsers getNextWord (takeCharacters 10)
  #+end_src

- we define a function to get the first value of the tuple
  #+begin_src haskell
    parseString :: StringParser -> String -> String
    parseString parser inputString =
      fst $ runStringParser parser inputString  -- runStringParser is a record field
  #+end_src

- calling it
  > parseString (takeCharacters 5) "Hello, world!"
   "Hello"
  > parseString getWord "Haskell is fun"
   "Haskell"
  > parseString tenLettersAfterTheFirstWord "AveryLongWord 0123456789abcdf"
   "0123456789"
  > parseString getNextWordAfterTenLetters "123456 hello world"
   "lo"

- The StringParser datatypes has made our code a bit easier to work with.
  1) We no longer have to keep track of may layers of high-order functions directly.
  2) Or pass around a lot of parameters.
*** Creating Type Aliases

- Why?
  - to improve readibility
    - if it's an api, an user might look just at type signatures
  - avoid overhead of new types

#+begin_src haskell
  type String = [Char]
#+end_src

- When?
  - when the aliased type really does have the same meaning as the type it's aliasing
  - not for doing things like
    #+begin_src haskell
      type Seconds = Int
      type Meters = Int
    #+end_src

- _Type aliases with type parameters_
  we use them to fix some type parameters
  aka give a name to some /partially applied/ type
  #+begin_src haskell
    data AppError = AppError
      { errormessage :: String
      , errorContext :: [String]
      , errorWrapped :: Maybe AppError
      }

    type AppValue a = Either AppError a -- we fixed AppError to Either
    type AppValue = Either AppError -- eta-reduced

    parseUserOrder :: String -> AppValue Order
    generateInvoice :: Order -> AppValue Invoice
    updateInventory :: [Order] -> [(Widget, Int)] -> AppValue [(Widget, Int)]
  #+end_src

** DONE 05 Creating And Structuring Haskell Projects
*** cabal

- Is a:
  - package manager
  - dependency manager
  - builder
  - runner

- When writting an executable is common use the ~Library and Executable~ option
  - having a small /executable/ code
  - and most of the code on the /library/
  - makes testing easier

- =App.hs= is also a common name for the *main module* of an executable

- mostopen source Haskell code uses =BSD-3= license
- uses SPDX license indentifiers

*** imports/modules

- you can assign the same import alias to different modules
  #+begin_src haskell
    import Data.Text as T
    import Date.Text.Encoding as T

    countNonPrintableCharactersInText :: Text -> Int
    countNonPrintableCharactersInText =
      T.length . T.filter (not . isPrint) . T.decodeUtf8 . T.encodeUtf8
  #+end_src

- it is a common pattern, when we want to bring a type/s from a module, do it in 2 steps
  1) include it
  2) and also include the qualified version with and alias
  #+begin_src haskell
    import Data.Text (Text) -- the type
    import qualified Data.Text as T
    countNonPrintableCharactersInText :: Text -> Int
  #+end_src

- otherwise, the type will need to used as T.Text
  #+begin_src haskell
    import qualified Data.Text as T (Text, length, filter, path)
    countNonPrintableCharactersInText :: T.Text -> Int -- !!
  #+end_src

- Import lists might help compile times.
  Since GHC attempts to only recompile code that has changed,
  using an *import list* may allow you to avoid some extra work.

- ~modules~ are the basic unit of organization in Haskell
  - each file contains a module
  - each module is defined by a single file
  - names follow the directory hierachy name, relative to the source directory
    - src/Examples/ExampleOne.hs -> Examples.ExampleOne
  - by default is exported
    - everything defined at top-level
    - types

- ~Language extensions~ are NOT enabled through imports

- on ghci> :load
  - everything is imported, regardless if it was exported or not

- =smart constructors=
  - an ordinary function that lets you construct a value
  - can include some aditional logic over a regular constructor

*** Example: exporting ~smart constructors~

And NOT exporting bare type constructors.

In this case, is to make sure the list ALWAYS has at least 1(one) element.

#+begin_src haskell
  module HaskellBook.Examples.SortedList
    ( SortedList (getSorted)
    , makeSortedList -- the smart constructor
    , minimum
    ) where

  import Data.List (sort)
  import Prelude hiding (minimum)

  data SortedList = SortedList { getSorted :: [Int] }

  makeSortedList :: [Int] -> Maybe SortedList
  makeSortedList []      = Nothing
  makeSortedList numbers = Just $ SortedList (sort numbers)

  minimum :: SortedList -> Int
  minimum (SortedList numbers) = head numbers
#+end_src

*** Example: using ~phantom types~

- Phantom types:

  Are types that don't have any corresponding value.
  But help us track status at the =type level=.

#+name: module / import
#+begin_src haskell
  {-# LANGUAGE RecordWildCards #-}
  module HaskellBook.Examples.UserInfo
    ( User
    , lookupUser
    , getUsername
    , getUserScore
    , getUserEmailAddress
    ) where

  import Data.List (find)
#+end_src

#+name: types = record + phantom types
#+begin_src haskell
  -- the PHANTOM TYPES
  -- just to track state at the TYPE LEVEL
  -- we do not need value CONSTRUCTORS for our type
  -- we do not EXPORT them
  data Authenticated
  data Unauthenticated

  data User isAuthenticated = User
    { userName :: String
    , userInternetPoints :: Int
    , userPassword :: String
    , userEmailAddress :: String
    }
#+end_src

#+name: users examples
#+begin_src haskell
  users :: [User a]
  users = [george, porter]
    where
      george = User
        { userName = "george"
        , userInternetPoints = 1000
        , userPassword = "secret"
        , userEmailAddress = "gbird2015@example.com"
        }
      porter = User
        { userName = "porter"
        , userInternetPoints = 500
        , userPassword = "hunter2"
        , userEmailAddress = "woofwoof@example.com2
        }
#+end_src

#+name: api
#+begin_src haskell
lookupUser :: String -> Maybe (User Unauthenticated) -- we want it to be unauth
lookupUser name =
  find (\user -> userName user == name) users

-- we DO NOT care about auth status in this cases
getUserName :: User isAuthenticated -> String
getUserName = userName
getUserScore :: User isAuthenticated -> Int
getUserScore = userInternetPoints

-- we DO care about the auth status to read emails
getUserEmailAddress :: User Authenticated -> String
getUserEmailAddress = userEmailAddress

authenticate :: User Unauthenticated -> String -> Maybe (User Authenticated)
authenticate User{..} password =
  | userPassword == password = Just User{..} -- returns an authenticated user, ME: notice that is handled at type level without casting
  | otherwise                = Nothing
#+end_src

*** Re-exporting code from other modules

- A _common pattern_ in haskell codebases is that:
  - you'll have several small independent *modules*
  - along with a parent module that re-exports all or most relevant parts

#+name: src/HaskellBook/Examples.hs
#+begin_src haskell
  module HaskellBook.Examples
    ( module HaskellBook.Examples.UserInfo
    , module CreatingModules -- using the local alias
    , SortedList.SortedList(..)
    , SortedList.makeSortedList
    , SortedList.minimum
    )
  where

  import HaskellBook.Examples.UserInfo
  import HaskellBook.Examples.Introduction.CreatingModules
    as CreatingModules hiding (testMessage)
  import qualified HaskellBook.Examples.SortedList
    as SortedList -- qualified (due minimum) + local alias
#+end_src

*** Example: using the chapter code in a Main.hs

#+begin_src haskell
  module ModuleDemo where
  import qualified HaskellBook.Examples as Examples

  georgesEmail :: Maybe String
  georgesEmail =
    case Examples.lookupUser "george" of
         Nothing -> Nothing
         Just unauthenticatedGeorge ->
           case Examples.authenticate unauthenticatedGeorge "secret" of
                Nothing -> Nothing
                Just george -> Just $ Examples.getUserEmailAddress george

  friendlyEmail :: String -> String
  friendlyEmail emailAddress =
    Examples.formatMessage Examples.GreetingMessage
    { Examples.greetingSalutation = Examples.Salutation "Hello"
    , Examples.greetingTo         = Examples.Name emailAddress
    , Examples.greetingFrom       = [Examples.Name "mailer daemon"]
    }

  demo :: String
  demo =
    maybe "unknown user" friendlyEmail georgesEmailAddress
#+end_src

** DONE 06 Type Classes

- =parametric polymorphism=
  - allows you to write a function that works with differen types
  - when you are concerned about the ~shape~ of your data,
  - but DO NOT need to inspect directly the values

- =ad-hoc polymorphism=
  - to provide different implementation of functions depending on their type
  - in OO: inheritance, interfaces
  - in Haskell: type classes

- For Example:
  1) a function that could remove duplicates on a list,
     we'll need the elements to be comparable OR a comparator function
  2) a function that calculate the sum, of all the elements on a list
     we'll need a comparator function and a sum function

- As the number of functions passed down by argument increase it becomes les feasible

- Typeclasses should be:
  1) narrowly focused on a specific feature,
  2) generally only define a small handful of functions.
     - It's common to only introduce a single new function
     - while *Natural* is on the upper limit of how big they should be

- When to (maybe) use Typeclasses
  - if you are modeling something that exists outside your program
    - real world object
    - mathematical object
    - business process with well defined operations

- When (maybe) NOT use a typeclass
  - if your type class would only be used on 1 or 2 places, consider passing a function instead
  - if you would only have 1 instance, wait until you'll need at least 1 more instance
  - if you find that most of your instances are *newtype* wrapers around some underlying type
    consider using a *record* that holds functions instead

- ~Rule of threes~ consider abstracting the behavior into a typeclass after the third time you rewrite your code
*** with =Type Classes= you can give a name to a group of related functions

  - allows to provide different implementations for different types

  - you could think it analogous as if you were defining a ~record~,
    where every field on the record is a function to do something

  #+name: class definition
  #+begin_src haskell
    module NaturalClass where

    class Natural n where
      equal                  :: n -> n -> Bool
      add                    :: n -> n -> n
      multiply               :: n -> n -> n
      additiveIdentity       :: n
      multiplicativeIdentive :: n
      displayAsString        :: n -> String
  #+end_src
  #+name: instance definition for Int
  #+begin_src haskell
    instance Natural Int where
      equal                  = (==)
      add                    = (+)
      multiply               = (*)
      additiveIdentity       = 0
      multiplicativeIdentity = 1
      displayAsString        = show
  #+end_src

*** composing =Type Classes=

- If you want to use (==) from Eq in the *default implementations* of functions,
  compose them like this.

#+begin_src haskell
  class Eq a where -- given Eq
    (==) :: a -> a -> Bool

  class Eq n => Natural n where -- we use Eq to define equality and add extra functionality
    add :: n -> n -> n
     -- ...
#+end_src

- It is advisable to keep the instances of *Show* simple,
  - by default deriving creates something parseable by *read*.
  - If you need something else, create your custom classes for it.

- Adding Show constraint

  #+begin_src haskell
    class (Show n, Eq n) => Natural n where
      add :: n -> n -> n
      -- ...
  #+end_src

- implementing/instancing *Natural* for ~Peano~, for all required typeclasses
  unlike *Int*, we also need to implement *Eq* and *Show* separately

  #+begin_src haskell
    -- data Peano = Z | S Peano
    instance Eq Peano where
      (==) Z Z         = True
      (==) (S a) (S b) = a == b
      (==) _ _         = False

    instance Show Peano where
      show Z     = "Z"
      show (S a) = "(S " <> show a <> ")"

    instance Natural Peano where
      add a Z                = a
      add a (S b)            = add (S a) b
      multiply Z _           = Z
      multiply (S a) b       = add b (multiply a b)
      additiveIdentity       = Z
      multiplicativeIdentity = S Z
  #+end_src

*** creating _default implementations_ and defining a =MINIMAL=

- Example: implementing Ord and Ordering

  #+begin_src haskell
    module OrdExample where
    import Prelude hiding (Ord(..), Ordering(..)) -- hide Prelude implementations

    data Ordering = LT | EQ | GT

    instance Show Ordering where
      show LT = "LT"
      show EQ = "EQ"
      show GT = "GT"

    class Eq a => Ord a where
      compare :: a -> a -> Ordering
      (<)     :: a -> a -> Bool
      a < b = -- <----- default implementation
        case compare a b of
          LT -> True
          _  -> False
      (<=)    :: a -> a -> Bool -- all below have similar default implementations based on COMPARE, elided
      (>)     :: a -> a -> Bool
      (>=)    :: a -> a -> Bool
      max     :: a -> a -> a
      min     :: a -> a -> a
  #+end_src

- now an instance of Ord would ONLY REQUIRE, a *compare* definition
  #+begin_src haskell
    instance Ord Word8 where
      compare a b
        | a == b = EQ
        | a == 0 = LT
        | b == 0 = GT
        | otherwise = compare (a - 1) (b - 1)
      max a b = a -- we could still override a default
  #+end_src

- {-# MINIMAL #-}

   - We could have provided a default *compare*, using (<=) on its implementation,
     leaving us to instanciate either of those.

   - BUT, if we don't want to end up on a infinite recursion we should use *MINIMAL*

   #+begin_src haskell
     class Eq a => Ord a where
       compare :: a -> a -> Ordering
       -- ...a compare and a (<=) default definitions are declared, each defined in terms of the other
     {-# MINIMAL compare | (<=) #-}
   #+end_src

*** ~DefaultSignatures~ (default)

- Example: we have a logging library, were we want to redact some information from logs

- We start by implementing a *type class*, without a default.

  #+begin_src haskell
    module DefaultSignaturesDemo where

    class Redacted a where
      redacted :: a -> String
  #+end_src

- We create a type *UserName*, we want it to implement both
  - *Show* for repl testing
  - *Redacted* for production

  #+begin_src haskell
    instance Show Username where
      show (UserName name) = name

    instance Redacted Username where
      redacted (Username name) = name
  #+end_src

- given that both have the same implementation,
  you could add *Show* as ~constraint~ to *Restricted*

  #+begin_src haskell
    class Show a => Redacted a where
      redacted :: a -> String
      redacted = show -- default implementation

    data UserName = UserName String

    instance Show UserName where -- we define show for it
     show (UserName userName) = userName

    instance Redacted UserName -- uses show
  #+end_src

- however there might be data, were we don't want to defined a *show*
  to not risk mistakenly printing a user's password in plaintext.

- ~DefaultSignature~ we add a *signature* to the default implementation
  where we also add a Show constraint.
  Which we don't have to respect if we override it.

  #+begin_src haskell
    {-# LANGUAGE DefaultSignatures #-}
    class Redacted a where                      -- we dropped the Show constraint
      redacted :: a -> String                   -- this should be ALWAYS respected
      default redacted :: Show a => a -> String -- this is a signature ONLY for the default
      redacted = show                           -- the default
  #+end_src

- as a result, a *Redacted* instance needs either
  - be an instance of "Show"
  - or define their own "redacted"
  #+begin_src haskell
    data Password = Password String

    instance Redacted Password where
      redacted _ = "<redacted>"
  #+end_src

*** ~TypeApplications~ (@_) extension to specify Type Class instances

- with this we can pass a /type name/ to a function, effectively changing how it gets run
  #+begin_src haskell
    >>> read @Integer "1"
      1
    >>> read @Float "1"
      1.0
  #+end_src

- You can also *partially apply* it
  #+begin_src haskell
    readInt   = read @Int   -- String -> Int
    readFloat = read @Float -- String -> Float
  #+end_src

- and also use it on functions with more than 1 type variable

  #+begin_src haskell
    showLeftRight :: (Read a, Read b) => String -> Either a b
    showLeftRight s
      | length s > 5 = Left  (read s)
      | otherwise    = Right (read s)

    >>> showLeftRight @Float @Int "3.1415" -- Left 3.1415
    >>> showLeftRight @Float @Int "321"    -- Right 321
    >>> showLeftRight @Float "3.14.15"     -- Left 3.1415 -- We only use "a" so we could just pass one type application
    >>> showLeftRight @_     @Int "123"    -- Right 123   -- We used @_ as a placeholder, to skip non-relevant type application
  #+end_src

*** ~ScopedTypeVariables~ (forall)

- some code is imposible to write without this extension
  this won't compile

  #+begin_src haskell
    adheresToReadShowContract val =
      let a = show . read . show $ val
          b = show val
      in a == b
  #+end_src

- Even (read "10") will fail since we don't know what type we want out of it
  (read "10" :: Int) will work

- Using this extension.

  We use the explicit ~universal quantification~ "forall a."
  More often called "explicit forall". Because without it the "forall" would be implicit.
  That will have the only effect of bring the type variable "a" into the scope on the body of the function..
  Effectively given context to the "read" for GHC to compile the program

  #+begin_src haskell
    adheresToreadShowContract :: forall a. (Read a, Show a) => a -> String
    adheresToReadShowContract val =
      let a = show . read @a . show $ val -- type annotation
          b = show val
      in a == b
  #+end_src

*** =print-explicit-foralls=

- needs >= GHC 9

- >>> :set -fprint-explicit-foralls
  >>> :t convertViaInt

- GHC tracks 2 different types of =type variables=
  1) specified types: when we manually write the type variables, aka on the function signature
  2) inferred types: when we have polymorphic type variales, which we never references, eg: in GHCI

- If we type annotate the function, we have a specified type variables

  #+begin_src haskell
    convertViaInt :: (Integral w, Num b) => w -> b
    convertViaInt a = fromIntegral $ fromIntegral @_ @Int a
    -- >>> :t convertViaInt
    -- convertViaInt :: forall w b. (Integral w, Num b) => w -> b
  #+end_src

- If a type variable is {surrounded} it means it was inferred

  #+begin_src haskell
  convertViaInt a = fromIntegral $ fromIntegral @_ @Int a
  -- >>> :t convertViaInt
  -- convertViaInt :: forall {w} {b}. (Integral w, Num b) => w -> b
  #+end_src

- We can control it with simple type annotation
  #+begin_src haskell
    >>> convertViaInt @Integer @Double 5
      error
    >>> (convertViaInt :: Integer -> Double) 5
      5.0
  #+end_src

- or mark a type variable to be explicit
  #+begin_src haskell
    convertViaInt :: forall {a} b. (Integral a, Num b) => a -> b
    convertViaInt input =
      fromIntegral $ fromIntegral @_ @Int input
  #+end_src

- where it will work the type application
  #+begin_src haskell
    >>> convertViaInt @Double 100
      100.0
    >>> convertViaInt @Int 100
      100
  #+end_src
*** Wrapping Types with =newtype= (Monoid/Semigroup)

- newtype
  - is simply a way to wrap an existing type
  - they are zero(0) cost abstractions
  - must have exactly 1(one) constructor
  - constructor must have 1(one) field

#+begin_src haskell
  newtype MyEither a b = MyEither (Either a b)
  newtype MyEither a b = MyEither { getEither :: Either a b } -- alternative record syntax
#+end_src

- There are 2 reasons, why you would want to add a type class to a newtype
  1) to avoid ~orphan instances~
  2) to support multiple type class instances for the underlying type

**** Orphan Instances

- is an instance of a typeclass, defined in a *module* where either of these are not defined on that *module*
  1) the typeclass
  2) the underlying type you are creating an instance of

- They trigger a warning.
- They are bad style.
- Are a risk to long term maintainability
  - because the module that defined either the typeclass or the underlying type
    might add an instance
    and given that in haskell you can only have 1 instance per type
    it will BREAK your code

**** Multiple type class instances

#+begin_src haskell
-- what
class Semigroup where
  (<>) :: a -> a
  GHC.Base.sconcat :: GHC.Base.NonEmpty a -> a
  GHC.Base.stimes :: Integral b => b -> a -> a
  {-# MINIMAL (<>) #-}

-- builds a SemiGroup by adding mempty, aka the initial or empty value
class Semigroup a => Monoid a where
  mempty :: a
  mappend :: a -> a -> a
  mconcat :: [a] -> a
  {-# MINIMAL mempty #-}
#+end_src

- We can see the behaviour of values and functions defined over typeclasses

  #+begin_src haskell
    >>> mempty @[Int]
      []
    >>> mempty @String
      ""
    >>> mempty @(Maybe [Int])
      Nothing
  #+end_src

- =mempty= is NOT a value particular to a type.
  - Is a value related to an *operation*
  - For Int we have >1 choice of how we would combine value: multiplication, addition...
  - Each of those choices give us different values for mempty

- (<>) defines an operation for a type
  mempty is the identity of that operation

- We then add a ~newtype~ for each new operation,
  and instances of Semigroup and Monoid for each newtype

  #+begin_src haskell
    newtype Product = Product { getProduct :: Int }
    newtype Sum = sum { getSum :: Int }

    instance Semigroup Product where
      (Product a) <> (Product b) = Product (a * b)

    instance Monoid Product where
      mempty = Product 1
  #+end_src
*** Understanding =Higher Kinded Types= and Polymorphism

- ~higher kinded types~ are types that accept type parameters

- a ~kind~ is a type of a type

- types with kind "*" are called ~fully saturated types~

- non-fully saturated types are called ~type constructors~

|----------------+-------------|
| type           | kind        |
|----------------+-------------|
| Int            | *           |
| Int -> String  | *           |
| Maybe Int      | *           |
| Maybe          | * -> *      |
| Either         | * -> * -> * |
| Either Int     | * -> *      |
| Either Int Int | *           |
|----------------+-------------|

- =Data.Kind.Type= is an alias for "*", it will allow us to make kind signatures look nicer (?)

- the type signature of fold,
  - shows a type constraint on "t"
  - and that "a" is being applied to "t"
  - "t" is a higher kind type (* -> *)
  #+begin_src haskell
    foldl :: Foldable t => (b -> a -> b) -> b -> t a -> b
    foldr :: Foldable t => (a -> b -> b) -> b -> t a -> b
  #+end_src

- In haskell we have the ability to be *polymorphic over paremetrized types*

- Example: We could convert this function that only works with lists to work with Data.List.NonEmpty lists

  #+begin_src haskell
    toCSV :: Show a => [a] -> String
    toCSV =
      let
        addField :: Show a => String -> a -> String
        addField s a = s <> ", " <> show a

        dropLeadingComma :: String -> String
        dropLeadingComma s =
          case s of
            ',':s' -> s'
            _      -> s
      in dropLeadingComma . foldl addField ""
  #+end_src

- To

  #+begin_src haskell
    {-# LANGUAGE KindSignatures #-}
    {-# LANGUAGE ExplicitForAll #-}
    module HKTDemo where
    import Data.Kind
    import qualified Data.List.NonEmpty as NonEmpty

    toCSV ::
      forall (t :: Type -> Type) (a :: Type) -- kinds, to be extra explicit, not necessary?
      . (Foldable t, Show a) -- constraint of "things that can be folded"
      => t a -> String -- "t" comes from Traversable, "f" is reserved for Functor
    toCSV = -- exact same code as before
      let
        addField :: Show a => String -> a -> String
        addField s a = s <> ", " <> show a

        dropLeadingComma :: String -> String
        dropLeadingComma s =
          case s of
            ',':s' -> s'
            _      -> s
      in dropLeadingComma . foldl addField ""
  #+end_src

- which means that you can call it with a lot of new things
  #+begin_src haskell
    toCSV Nothing   -- ""
    toCSV (Just 1)  -- "1"
    toCSV (Right 3) -- "3"
    toCSV (Left 4)  -- ""
  #+end_src

- You can use ~Higher Kinded Types~ with your own types and classes

- Example:
  like Foldable, Select will work with HKT,
  allowing us to create a typeclass that will work for any parametrized type class

  #+begin_src haskell
    {-# LANGUAGE KindSignatures #-}
    module Selector where
    import Data.Kind

    class Select (f :: Type -> Type) where
      empty :: f a
      pick :: f a -> f a -> f a
  #+end_src

- Example: instancing
  - instances use HKT, rather than fully saturated types like "Maybe a" or "[a]"
  - the typeclass and its instances expect to be implemented in terms of the shape of the data

  #+begin_src haskell
    instance Select Maybe where
      empty          = Nothing
      pick Nothing a = a
      pick a _       = a

    instance Select [] where
      empty = []
      pick  = (<>)
  #+end_src
*** Deriving Instances

- type classes allow you to create abstractions in your programs

#+begin_src haskell
  data Customer =
    Customer { name  :: String
             , mail  :: String
             , email :: String
             } deriving (Eq, Show, Ord)
#+end_src

- when *deriving* a record, all the types within the record must also have instances of the typeclass you are trying to derive

  #+begin_src haskell
    newtype Name = Name String
      deriving (Eq, Show, Ord)

    data Customer = Customer
                    { name :: Name
                    , mail :: String
                    }
                  deriving (Eq, Show, Ord)
  #+end_src

*** ~GeneralizedNewtypeDeriving~

- allows newtype wrappers to derive any type class *instances*
  that are implemented by the type they are wrapping.

- Applying the algorithm:
  1) unwrap the type
  2) apply the type class function
  3) rewrap the result

- So we go FROM code like this

  #+begin_src haskell
    newype USD = USD { getMillis :: Integer } deriving (Eq,Ord,Show)

    instance Num USD where
      (USD a) + (USD b) = USD (a + b)
      (USD a) * (USD b) = USD (a * b)
      abs (USD a)       = USD (abs a)
      signum (USD a)    = USD (signum a)
      fromInteger       = USD
      negate (USD a)    = USD (negate a)

    instance Real USD where
      toRational (USD a) = toRational a

    instance Enum USD where
      toEnum a         = USD (toEnum a)
      fromEnum (USD a) = fromEnum a

    instance Integral USD where
      quotRem (USD a) (USD b) =
        let (a',b') = quotRem a b
        in (USD a', USD b'
      toInteger (USD a) = a

  #+end_src

- TO code like this

  #+begin_src haskell
    {-# LANGUAGE GeneralisedNewtypeDeriving #-}
    newtype USD = USD { getMillis :: Integer }
      deriving (Eq, Ord, Show, Enum, Num, Real, Integral)
  #+end_src

*** ~DerivingVia~ a compatible type

- with it, you can use *newtypes* as a /template/ for how to define a *type class* for other types.
  reduces code, by allowing you to derive once and then re-use it in several ways

- Background:
  in "base" *Maybe* has an instance of *Monoid*, that allows you to combine the /underlying/ values
  #+begin_src haskell
    >>> (Just [1]) <> (Just [2]) <> Nothing <> (Just [3])
      Just [1,2,3]
  #+end_src

- Problem:
  it could be also useful if *Maybe* had another instance of *Monoid* that allowed
  to return the first available value.
  Eg: given several methods of contact, in the form of "Maybe String", it will return the first not-empty

- We could write our own *newtype* wrapper
  Since we can't add a new instance to an existing type, we'll use a typeclass called *MyMaybe* for which we can add an instance.
  #+begin_src haskell
    newtype MyMaybe a = MyMaybe (Maybe a)
      deriving Show

    instance Semigroup (MyMaybe a) where
      (MyMaybe Nothing) <> b = b
      a                 <> _ = a

    instance Monoid (MyMaybe a) where
      mempty = MyMaybe Nothing
  #+end_src

- Earlier, in this book, we wrote a class that implemented something similar to this.
  #+begin_src haskell
    class Select (f :: Type -> Type) where
      empty :: f a
      pick  :: f a -> f a -> a

    instance Select Maybe where
      empty          = Nothing
      pick Nothing a = a
      pick a _       = a
  #+end_src

- We could rewrite our *MyMaybe* instances to use *Select*
  The result is
  - nothing specific to MyMaybe or Maybe itself
  - instances are just doing unwrapping/wrapping, and using the underlying *Select* instance we have already defined for *Maybe*
  #+begin_src haskell
    instance Semigroup (MyMaybe f a) where
      (MyMaybe a) <> (MyMaybe b) = MyMaybe (pick a b)

    instance Monoid (MyMaybe f a) where
      mempty = MyMaybe empty
  #+end_src

- ~DerivingVia~
  1) You'll need to create a type with one or more instances, that will act as a template
  2) you can use *deriving via* to reuse the instances definitions for other types

- Example:
  - *Sel*, gets his name because it wraps the previously defined class ~Select~ and it has his same signature
  - *Sel*, is used as a template for how to derive the instances for *Semigroup* and *Monoid*
  - It will create an instance that converts our "MyMaybe" value into "Sel Maybe"
  - Then calls the appropiate type class functions, and converts the result back to "MyMaybe" value.

  #+begin_src haskell
    {-# LANGUAGE DerivingVia #-}
    newtype Sel (f :: Type -> Type) (a :: Type)
      = Sel (f a)

    instance (Select f) => Semigroup (Sel f a) where
      (Sel a) <> (Sel b) = Sel (pick a b)

    instance (Select f) => Monoid (Sel f a) where
      mempty = Sel empty

    newtype MyMaybe a = MyMaybe (Maybe a)
      deriving Show
      deriving (Semigroup, Monoid) via (Sel Maybe a) -- via
  #+end_src

- You are NOT limited to *deriving via* with types that already have an instance of the type class.
  Example: you can add Semigroup and Monoid to Int. By borrowing by the Data.Semigroup.Sum and .Product

  #+begin_src haskell
    {-# LANGUAGE DerivingVia #-}
    module MyNumericMonoids where
    import Data.Semigroup

    newtype MySum = MySum { getMySum :: Int }
      deriving (Eq, Show)
      deriving (Semigroup, Monoid) via (Sum Int)

    newtype MyProduct a = MyProduct { getMyProduct :: a }
      deriving (Eq, Show)
      deriving (Semigroup, Monoid) via (Product a)

    -- >>> mconcat $ map MySum [1..10]
    --   MySum {getMySum = 55}
    -- >>> mconcat $ map Product [1..10]
    --   Product {getProduct = 3628800}
  #+end_src

*** ~StandaloneDeriving~ to make it easier for us o see the vaule while we're testing things out
  #+begin_src haskell
    >>> :set -XStandaloneDeriving
    >>> deriving instance (Show (f a)) => Show (Sel f a)
    >>> a = Sel (Just 1)
    >>> b = Sel (Nothing)
    >>> a <> b
       Sel (Just 1)
    >>> b <> a
       Sel (Just 1)
    >>> (Sel [1,2]) <> (Sel [3,4,5])
       Sel [1,2,3,4,5]
  #+end_src
*** ~DeriveAnyClass~ + default definitions

- ~DeriveAnyClass~ with it we can *derive* any class, and GHC will add an empty instance declaration for us
 #+begin_src haskell
   {-# LANGUAGE DefaultSignatures #-}
   {-# LANGUAGE DeriveAnyClass #-}
   module AnyClassDemo where

   class Redacted a where
     redacted :: a -> String
     default redacted :: Show a => a -> String
     redacted = show
  #+end_src

- define the UserName newtype
  #+begin_src haskell
    newtype UserName = UserName String
      deriving (Show, Redacted)
  #+end_src

- Testing
  #+begin_src haskell
    >>> UserName "george"
      UserName "george"
    >>> redacted $ UserName "george"
      "UserName \"george\""
  #+end_src

- However if we try to DeriveAny *Redacted* without *Show* on a new *Password* type
  It will FAIL to compile.

  #+begin_src haskell
    newtype Password = Password String
      deriving (Redacted) -- ERROR
  #+end_src

*** ~DerivingStrategies~

- To solve interactions between different types of derives extensions

- By default GHC wil pick AnyClass over NewClass when deriving

#+begin_src haskell
  newtype UserName = UserName String
    deriving how
  instance Redacted UserName where
    redacted (UserName user) = "UserName: " <> user

  newtype AdminUser = AdminUser
    deriving stock Show       -- stock strategy
    deriving newtype Redacted -- newtype strategy
#+end_src

- stock, newtype, anyclass, via

** DONE 07 Understanding =IO=

- general IO vs IO actions vs IO type

- Haskell does "pure lazy IO".
  - Current approach exists since Haskell98
  - The =IO Type= is how we keep track of the state of the real world.
  - Being pure means that we can't just change the value of things,
    and that includes changing the external environment. Aka *side-effects*
  - Instead of changing an external value, we need to keep track
    of all the changes we want to make.
  - We call =IO actions= to things like "IO String",
    and use "IO a" to refer to any type of it
  - Since the performed /order/ of =IO actions= is really important *lazyness* becomes a problem.
    We can overcome it by ensuring each "IO" returned is used.
    We need a way to combine/sequence IO actions.
    Letting us represent them as a single larger IO action.

*** (>>=) andThen / bind

- This "sequencing" is directly represented by the type system. That is the type of the hole.
  #+begin_src haskell
    copyFile :: FilePath -> FilePath -> IO ()
    copyFile src dst =
      (readFile src) `_` (writeFile dst)

    -- if we replace the _ hole with "andThen"
    -- the ouput value "b" depends on evaluating "a"
    andThen :: IO a -> (a -> IO b) -> IO b
    andThen = (>>=) -- aka "bind"
  #+end_src

- to get a newIO, for example to return a "IO String" when something failed
  #+begin_src haskell
    noPassword :: FilePath -> IO String
    noPassword path =
      case path of
        "/etc/passwd" -> newIO "hey, that's a secret!"
        fname -> readFile fname

    showFile path = noPassword path `andThen` putStrLn

    newIO :: a -> IO a
    newIO = return
  #+end_src

- we can write functions that will take a pure value and turn into impure IO action and then combine it with bind (>>=)
  #+begin_src haskell
    ioRead :: String -> IO Int
    ioRead sumString = return $ read sumString

    ioShow :: Int -> IO String
    ioShow = return . show

    ioSucc :: Int -> IO Int
    ioSucc = return . succ
  #+end_src

- Using some functions from System.IO and >>=
  #+begin_src haskell
    doSomeFileStuff =
      openFile "/tmp/foo.txt" ReadMode
      >>= \handle -> hgetContents handle
      >>= \contents -> putStrLn contents
      >>= \_ -> hClose handle
  #+end_src

*** (>>) thenCall

- This still leaves unsolved, what if we only care about sequencing and do NOT care about the returned values?
 #+begin_src haskell
   -- will ERROR, because >>= wants something like "a -> IO b"
   putStrLn "hello world" >>= putStrLn "nice to meet you"
   -- we could avoid it with a lambda
   putStrLn "hello world" >>= \_ -> putStrLn "nice to meet you"
  #+end_src

- For that we can write a function like *thenCall*
  #+begin_src haskell
    thenCall :: IO a -> IO b -> IO b
    thenCall a b = a >>= \_ -> b
    --thenCall = (>>)
  #+end_src

*** (<$>) fmap

- the answer to, what to do when you have a function that doesn't know or care about IO?

- Whenever we see a ~return~ used with (>>=) it's a sign that you might want to refactor your code

  #+begin_src haskell
    main :: IO ()
    main =
      getArgs >>= return . sumArgs >>= print
  #+end_src

- ~fmap~ comes from the *Functor* type class and it helps us solve this problem giving us a way to apply pure functions to values inside an =IO action= without having to use (>>=).

- Works just like *map*, but for all instances of *Functor*
  #+begin_src haskell
    fmap :: Functor f => (a -> b) -> f a -> f b
    -- >>> fmap (+1) (return 1 :: IO Int) -- 2
    -- >>> fmap show (return 1 :: IO Int) -- "1"
  #+end_src

- We could make our previous main more clear
  #+begin_src haskell
    main :: IO ()
    main =
      fmap sumArgs getArgs >>= print -- or
      sumArgs <$> getArgs >>= print
  #+end_src

- We can also use ~fmap~ to handle *Maybe* and avoid if/else or pattern matching
  #+begin_src haskell
    import Text.Read (readMaybe)
    sumArgs :: [String] -> Maybe Int
    sumArgs strArgs =
      let intArgs = mapM readMaybe strArgs in
        fmap sum intArgs
  #+end_src

- where ~mapM~ is a function that converts, a "list of monads" into a "monad of lists"
  |-----------+----+-----------|
  |       <r> |    |           |
  | [Maybe a] | -> | Maybe [a] |
  |    [IO a] | -> | IO [a]    |
  |-----------+----+-----------|

*** Running IO in real applications (mapM, mapM_)

- TOPIC: =IO actions= impact on performance and stability

- In the same way that lazyness allowed this code to compile and run, returning "12"
  #+begin_src haskell
    ignoreUnevaluated :: Int
    ignoreUnevaluated =
      let infinity = sum [1..]
      in 12
  #+end_src

- this code will also compile and run, returning (), but NOT printing anything. As the IO of _putStrLn_ wil never become part of the history of the real world we are returning.
  #+begin_src haskell
    ignoreUnevaluatedIO :: IO ()
    ignoreUnevaluatedIO =
      let screamIntoTheVoid = putStrLn "quack" -- will not print anything
      in return ()
  #+end_src

- so will this, not raising the exception, but it will print the sideffect before >>
  #+begin_src haskell
    lazyIODemo :: IO ()
    lazyIODemo =
      let sayHello :: IO ()
          sayHello = putStrLn "Hello"
          raiseAMathError :: IO Int
          raiseAMathError = putStrLn "I'm part of raiseMathError" -- this gets evaluated
                            >> return (1 `div` 0) -- this does NOT
      in sayHello
      >> raiseAMathError
      >> sayHello
  #+end_src

- this won't work, due lazyness, since the program will run out of available OS file descriptors
  #+begin_src haskell
    makeAndReadFile :: Int -> IO String
    makeAndReadFile fnumber =
      let fname = "/tmp/test/" <> show fnumber
      in writeFile fname fname >> readFile fname -- will create the thunk, but won't read the file

    unsafe :: IO ()
    unsafe =
      let files = mapM makeAndReadFile [1..50000] :: IO [String]
      in files >>= (putStrLn . show) -- tries to run all the readFile's at once
  #+end_src

- we can make it work by
  - putting the make+print into his own helper function
    #+begin_src haskell
      makeAndShow :: Int -> IO
      makeAndShow n =
        makeAndReadFile n >> putStrLn
    #+end_src
  - changing the signature to IO [()] (CODE SMELL!!!)
    #+begin_src haskell
      safe :: IO [()]
      safe =
        mapM makeAndShow [1..500]
    #+end_src
  - or better
    #+begin_src haskell
      safe :: IO ()
      safe =
        foldl (\io id ->
                  io >> makeAndShow id
              ) (return ()) [1..500]
    #+end_src
  - or using the equivalent ~mapM_~
    #+begin_src haskell
      safe :: IO ()
      safe = mapM_ makeAndShow [1..500]
    #+end_src

** 08 Working with the Local System

- ABOUT: Ways to interact with the outside world.

*** Procedural Shell, Functional Core

- In traditional programming languages
  - you can do IO at any time, so programs do IO as needed
  - encapsulating the implementation details of what type of IO a function is doing means that the user doesn't need to know, or think about, any of those dtails.

- In Haskell this approach to designing applications can become a problem.
  - Once introduced some IO we can't go back to the world of normal pure functions
  - each call to IO is a potential failure scenario

- The solution is a "Procedural Shell" (aka on the outside), with a "Functional Core"
  - It also allows for modules that themselves have the same PSFC

*** Creating a Pager

src/Hcat.hs
app/main.hs

#+begin_src haskell-cabal
cabal-version:  2.4
name:           hcat
version:        0.1.0.0

library
  hs-source-dirs:     src
  exposed-modules:    HCat
  build-depends:      base
                    , bytestring
                    , text
                    , process
                    , directory
                    , time
  default-language:   Haskell2010

executable hcat
  hs-source-dirs:     app
  main-is:            Main.hs
  build-depends:      base, hcat
  default-language:   Haskell2010
#+end_src

*** Viewing the Contents of an ASCII or UTF8 Encoded Text File
**** get the filename from CLI arguments

#+begin_src haskell
import qualified System.Environment as Env

handleArgs :: IO FilePath -- FilePath is an alias for String
handleArgs =
  head <$> Env.getArgs -- head is a partial function, crashes with []
#+end_src

Safe way to get the arguments, we separate the pure and impure part with *where*.

#+begin_src haskell
handleArgs' :: IO (Either String FilePath)
handleArgs' =
  parseArgs <$> Env.getArgs
  where
    parseArgs argumentList =
      case argumentList of
        [arg] -> Right arg
        [] -> Left "no filename provided!"
        (_ : _) -> Left "too many arguments!"
#+end_src

We pretty print our Either

#+begin_src haskell
runHCat :: IO ()
runHCat =
  handleArgs' >>= displayMessage
  where
    displayMessage :: Either String Filename
    displayMessage parsedArgument =
      case parsedArgument of
        Left errMessage -> putStrLn $ "Error: " <> errMessage
        Right filename -> putStrLn $ "Opening file: " <> filename
#+end_src

**** reading the contents of the file (IOError)

replace on runHCat

#+begin_src haskell
Right filename -> readFile filename >>= putStrLn
#+end_src

handle IOError exception, by printing a friendlier msg

#+begin_src haskell
import qualified Control.Exception as Exception
import qualified System.IO.Error as IOError

runHCat :: IO ()
runHCat =
  Exception.catch (handleArgs' >>= displayMessage) handleErr
  where
    handleErr :: IOError -> IO () -- MANDATORY signature, compiler needs to know which one we capture
    handleErr e = putStrLn "I ran into an error: " >> print e
-- ...
#+end_src

alternative refactor, to keep the function focused on the main logic

#+begin_src haskell
runHCat :: IO ()
runHCat =
  withErrorHandling $
    handleArgs' >>= displayMessage
  where
    withErrorHandling :: IO () -> IO ()
    withErrorHandling ioAction = Exception.catch ioAction handleErr
-- ...
#+end_src

alternative refactor, converting Either to IOError and throwing/raising it
(calls to *throw* might not always evaluate predictable when dealing with IO actions)

#+begin_src haskell
eitherToErr :: (Show a) => Either a b -> IO b
eitherToErr either =
  case either of
    Right a -> return a
    Left e  -> IOError.ioerror . Exception.userError $ show e
-- OR          Exception.throwIO . Exception.userError $ show e
#+end_src

then we could just add it OR refactor to pipe through Either's

#+begin_src haskell
{-# LANGUAGE TypeApplications #-}
eitherToErr :: Show a => Either a b -> IO b
runHCat :: IO ()
runHCat =
  handleIOError $ -- handleIOError :: IO () -> IO ()
    handleArgs' -- handleArgs' :: IO (Either String FilePath)
      >>= eitherToErr -- eitherToErr :: Show a => Either a b -> IO b
      >>= readFile
      >>= putStrLn
  where
    handleIOError :: IO () -> IO ()
    handleIOError ioAction =
      Exception.catch ioAction $
        \e -> putStrLn "I ran into an error: " >> print @IOError e
#+end_src

**** reading the contents of the file (Text)

- functions in *bytestring* and *text* packages behave that the ones in System.IO but with Text and ByteString

#+begin_src haskell
{-# LANGUAGE TypeApplications #-}
import qualified Data.Text.IO as TextIO
runHCat :: IO ()
runHCat =
  handleIOError $ -- handleIOError :: IO () -> IO ()
    handleArgs' -- handleArgs' :: IO (Either String FilePath)
      >>= eitherToErr -- eitherToErr :: Show a => Either a b -> IO b
      >>= TextIO.readFile -- !!!
      >>= TextIO.putStrLn -- !!!
  where -- ...
#+end_src

*** Viewing Text One Page at a Time

SUMMARY: forward pagination + keyboad control + line wrapping?

**** line wrapping

we get a helper that will help us to go from lines of text to pagination

#+begin_src haskell
-- polymorphic enough to work with String and Text
-- we could return a "Maybe [[a]]" to handle "groupsOf 0" which will be infinite otherwise
groupsOf :: Int -> [a] -> [[a]]
groupsOf _ [] = []
groupsOf n elements =
  let (hd, tl) = splitAt n elements
   in hd : groupsOf n tl
#+end_src

=wordWrap= takes the maximum width of a line, and will return a list of rows of text, each at most that length

#+begin_src haskell
  wordWrap :: Int -> Text.Text -> [Text.Text]
  wordWrap lineLength lineText
    | Text.length lineText <= lineLength = [lineText] -- base case
    | otherwise =  -- hardwrapping
      let (wrapped, unwrapped) = Text.splitAt lineLength lineText
      in wrapped : wordWrap lineLength unwrapped
#+end_src

improved algorithm

#+begin_src haskell
  wordWrap :: Int -> Text.Text -> [Text.Text]
  wordWrap lineLength lineText
    | Text.length lineText <= lineLength = [lineText] -- base case
    | otherwise =  -- soft wrapping
        let
          (candidate, nextLines) = Text.splitAt lineLength lineText
          (firstLine, overflow) = softWrap candidate (Text.length candidate - 1)
        in
          firstLine : wordWrap lineLength (overflow <> nextLines)
    where
      softWrap hardwrappedText textIndex
        | textIndex <= 0 = (hardwrappedText,Text.empty) -- base case
        | Text.index hardwrappedText textIndex == ' ' = -- can we softwrap?
          let (wrappedLine, rest) = Text.splitAt textIndex hardwrappedText
          in (wrappedLine, Text.tail rest) -- Text.tail to drop the space
        | otherwise = softWrap hardwrappedText (textIndex - 1)

#+end_src

**** handling terminal dimensions

#+begin_src haskell
  data ScreenDimensions = ScreenDimensions
    { screenRows :: Int
    , screenColumns :: Int
    } deriving Show

  paginate :: ScreenDimensions -> Text.Text -> [Text.Text]
  paginate (ScreenDimensions rows cols) text =
    let
      unwrappedLines = Text.lines text
      wrappedLines = concatMap (wordWrap cols) unwrappedLines
      pageLines = groupsOf rows wrappedLines
    in
      map Text.unlines pageLines
#+end_src

*** Adding a Status Line with Metadata
*** Showing the Status Bar and Refactoring runHCat
** 09 Introducing =Monads=
** 10 Mutable Data in Real World
** 11 Serializing   Heterogenuos Data
** 12 Deserializing Heterogenuos Data
** 13 Building Applications with Many =Effects=
** 14 Building Efficient Programs
** 15 Programming with Types
