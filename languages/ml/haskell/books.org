* DONE Book: Seven Languages in 7 weeks
** Haskell
- "In Haskell, indentation is significant." (?
- on Haskell, IF is a function, not a control structure, it returns a value.
- "." for function composition
  second = head . tail
- On ghci console
  > :set +t
- A partial applied function is called ~section~
- ~where~ on function definition can define local functions too
- every function does have 1(one) parameter
  - the process of reducing a function of N parameters to N of 1 param is ~currying~
#+NAME: single-line vs multi-line pattern-matching vs guards
#+begin_src haskell
fact x = if x == 0 then 1 else fact (x - 1) * x

factorial :: Integer -> Integer
factorial 0 = 1
factorial x = x * factorial (x - 1)

factorio :: Integer -> Integer
factorio x
  | x > 1     = x * factorio (x - 1)
  | otherwise = 1
#+end_src
* Book: Haskell School of Music
** 1 Computer Music, Euterpea, and Haskell
*** 1.1 The Note versus Signal Dichotomy
- High/Low    level music concepts a.k.a.
  Note/Signal level music concepts
- Note: pitch and volume
- Bit depth: storage size of a single sample.
  Typically 16bits (2bytes) or 32bits (4bytes)
*** 1.2 Basic Principles of Programming
- Measures of success: correctness, efficiency, clarity
- Code often represents the author's thought process...A conventional
  musical score does not.
*** 1.3 Computation by Calculation
- In general, it is best to search first for an elegant (and correct!) solution to a problem, and later refine it for better performance.
  “Get it right first!”
- ~unfolding~ a function, is when we replace the arguments in the definition
  simple x y z = x * (y + z)
  simple 3 9 5
  > 3 * (9 + 5)
  > 42
- "simple 3 9 5 ~evaluates~ to 42"
*** 1.4 Expressions and Values
- note names are called pitch classes
- ~expressions~ entities that can be evaluated
- ~value~ are expressions that cannot be further evaluated.
  ex: 1,[1,2],(3,3),'C',"hello"
- ~diverging~ expressions are those that do not have an end
  ex: f x = f (x - 1)
  evaluate to "Bottom" value _|_
*** 1.5 Types
- Atomic or Structured
- Type Signature
  'D' :: Char
      :: reads as "has type"
   D  :: PitchClass
- Elements on a List are the same Type
- Elements on a Tuple could be different Types
*** 1.6 Function Types and Type Signatures
#+begin_src haskell
simple :: Int -> Int -> Int -> Int
simple x y z = x * (y + z)
#+end_src
- "it is a good habit to first write down the type of each function you
   are planning to define, as a first approximation to its full specification"
- f :: T1 -> T2 -- In mathematics T1 is the ~domain~ and T2 is the ~range~
- ~function application~ aka calling the funtion, has always higher precedence on application
- symbol based functions are usually called ~operators~ and are ~infix~
  - Are defined between parentheses
  - (+) :: Integer -> Integer -> Integer
- ' is a valid alphanumeric value, so f' and f'' are valid function names
*** 1.7 Abstraction, Abstraction, Abstraction
- “What are the three most important ideas in programming?" (see title)
**** 1.7.1 Naming
#+begin_src haskell
pi :: Double
pi = 3.1415
-- two definitions in one
concertA,a440 :: (PitchClass, Octave)
concertA = (A,4)
a440     = (A,4)
-- Vars
c = 42 -- is called a ~binding~
x    = let area = pi * r ** 2
       in f area + g area
#+end_src
- A4 is usually called "concert A" (because it is often used as a the note to which an orchestra
  tunes its intruments or "A440")
- {- MULTILINE COMMENT IN HASKELL -}
**** 1.7.2 Functional Abstraction
#+begin_src haskell
x = let areaF r = pi * r ** 2
    in f (areaF r1) + g (areaF r2)
note :: Dur -> Pitch -> Music Pitch
rest :: Dur -> Music Pitch
(:+:) Music Pitch -> Music Pitch -> Music Pitch -- Sequentially
(:=:) Music Pitch -> Music Pitch -> Music Pitch -- Simultanious
trans :: Int -> Pitch -> Pitch
-- Harmonizing each pN note with a third
qn = 1/4
mel = (note qn p1 :=: note qn (trans (-3) p1)) :+:
      (note qn p2 :=: note qn (trans (-3) p2)) :+:
      (note qn p3 :=: note qn (trans (-3) p3))
-- In a function
hNote :: Dur -> Pitch -> Music Pitch
hNote d p = note d p :=: note d (trans (-3) p)
-- applied
mel :: Music Pitch
mel = hNote qn p1 :+: hNote qn p2 :+: hNote qn p3
#+end_src
**** 1.7.3 Data Abstraction
- The order of ~associativity~ can be defined, either left, right or none.
- (:) operator has right associativity
#+begin_src haskell
hList          :: Dur -> [Pitch] -> Music Pitch
hList d []     = rest 0
hList d (p:ps) = hNote d p :+: hList d ps
--
mel = hList qn [p1,p2,p3]
#+end_src
*** 1.8 Haskell Equality versus Musical Equality
- 2 different melodies can be musically equivalent while being not equal by the language
- A melody can be interpreted either by his
  ~polyphonic~: grouping notes playing at the same time
  ~contrapuntal~: grouping by each voice
*** 1.9 Code Reuse and Modularity
- being able to re-use code is called ~modularity~
*** 1.10 [Advanced] Programming with Numbers 1
- Int data type is of size word (architecture dependent, 32 or 64 bits) (use Integer instead)
- In mathemathics, ~numerical analisys~ is concerned with numerical incongrueties
- If real-number acuraccy is important, be wary of floats
#+begin_src haskell
5 ∗ (−0.123456 + 0.123457)       :: Float ⇒ 4.991889e−6
5 ∗ (−0.123456) + 5 ∗ (0.123457) :: Float ⇒ 5.00679e−6
#+end_src
** 2 Simple Music
*** 2.1 Preliminaries
#+begin_src haskell
-- Type Synonyms
type Octave = Int
type Pitch  = (PitchClass, Octave)
type Dur    = Rational
-- Algebraic data type
data PitchClass = Cff | Cf | C | Dff | Cs | Df | Css | D | Eff | Ds
                | Ef | Fff | Dss | E | Ff | Es | F | Gff | Ess | Fs
                | Gf | Fss | G | Aff | Gs | Af | Gss | A | Bff | As
                | Bf | Ass | B | Bs | Bss
qn :: Dur
qn = 1/4
#+end_src
- data NAME = CONSTRUCTORS
  data Bool = False | True
*** 2.2 Notes, Music, and Polymorphism
#+begin_src haskell
-- (Value) Constructor
data Primitive = Note Dur Pitch |
                 Rest Dur
-- Type Constructor: more generic, polymorphic
data Primitive a = Note Dur a |
                   Rest Dur
-- Note :: Dur -> a -> Primitive a
-- Rest :: Dur ->      Primitive a
--
-- Another ~type constructor~, this time also recursive (aka inductive data type)
data Music a =
    Prim (Primitive a)
  | Music a :+: Music a
  | Music a :=: Music a
  | Modify Control (Music a)
-- Prim   :: Primitive a        -> Music a
-- (:+:)  :: Music a -> Music a -> Music a
-- (:=:)  :: Music a -> Music a -> Music a
-- Modify :: Control -> Music a -> Music a
#+end_src
- ~fixity declaration~
  infixr 5 :+:,:=:
- Data constructors
  - are still functions and have a type
  - are an example of polymorphic functions ~type abstraction~
#+begin_src haskell
data Control =
    Tempo      Rational          -- scale the tempo
  | Transpose  AbsPitch          -- transposition
  | Instrument InstrumentName    -- instrument label
  | Phrase     [PhraseAttribute] -- phrase attributes
  | KeySig     PitchClass Mode   -- key signature and mode
  | Custom     String            -- custom label
data Mode = Major | Minor | Ionian | Dorian | Phrygian | Lydian
             | Mixolydian | Aeolian | Locrian
             | CustomMode String
data InstrumentName = AcousticGrandPiano | BrightAcousticPiano ...
#+end_src
*** 2.3 Convenient Auxiliary Functions

*** 2.4 Absolute Pitches
- LIST !! N
  [C,D,E] !! 1 => D
** 3 Polymorphic and high order functions
- head, tail, length (examples of simple polymorphic types)
- map
- append (++)
- fold
  foldr, foldl: only difference is from which side is applied the operator, sometimes might be more performant from one side over the other
  foldr1, foldl1: versions that error on empty lists, so no init value needed
- `` functions into operator with backquotes
- () operator into a function with parentheses
- reverse, (algorithm with foldl)
- ~currying~
- currying simplification
  f x = g x
  f   = g
** 4
*** 4.2 Modules
- Module names are capitalized
  Can be hierachical
  import LIBRARY.FOLDER.MODULE
- module MODULE where
  module MODULE (EXPORT,EXPORT) where
*** 4.3 Transcribing a More Complex Score
**** 4.3.1 Auxiliary Functions
- Haskell does not permit pattern-matching against function applications.
  myFunction (Prim (Note d p)) = -- OK
  myFunction (note d p)        = -- FAIL
- times :: Int -> Music a -> Music a -- repeats
  addDur
  graceNote
- The only special cases that will not be handled using auxiliary functions are:
  1) the single staccato on note four of bar fifteen
  2) the single portamento on note three of bar sixteen.
  These situations will be addressed differently in a later chapter.
*** 4.4 Simple Algorithmic Composition
* Book: Real World Haskell
- Updated code version https://github.com/tssm/up-to-date-real-world-haskell/
- Real World Haskell outdated parts https://stackoverflow.com/questions/23727768/which-parts-of-real-world-haskell-are-now-obsolete-or-considered-bad-practice
- Online http://book.realworldhaskell.org/read/
** 6 Using Typeclasses
*** Defining
- Different implementation depending on the type of data given.
- Defining a new ~Typeclass~ named "BasicEq3".
  We can provide *default implementations* for Typeclasses, and make one depend on the other.
#+begin_src haskell
class BasicEq3 a where
  isEqual3 :: a -> a -> Bool
  isEqual3 x y = not (isNotEqual3 x y)

  isNotEqual3 :: a -> a -> Bool
  isNotEqual3 x y = not (isEqual3 x y)
#+end_src
- An ~Instance Type~ of this typeclass, is any type that implements the functions defined in it.
- isEqual :: BasicEq a => a -> a -> Bool
  Reads:
  "For all types of *a*,
   so long as *a* is an instance of BasicEq,
   isEqual takes two parameters of type *a* and returns Bool""
*** Type Instancing
#+begin_src haskell
instance BasicEq3 Color where
  isEqual3 Red   Red   = True
  isEqual3 Green Green = True
  isEqual3 Blue  Blue  = True
  isEqual3 _     _     = False
#+end_src
*** Build-in
- Show, and the function show which returns a string from something showable
  show :: (Show a) => a -> String
  (you can derive it or explicitly Type Instance it)
  - To define your own show redefine ~show~
- Read, and the function read which takes a string and returns something readable
  read :: (Read a) => String -> a
  e.g. (read readVar)::Double
  - To define your own parser redefine ~readsPrec~
** 7
- ~Type classes~ provide ad-hoc polymorphism
  - Can define default "implementations" for the class
- ~Types~ are made instances of a particular type class
- Typeclasses
  - Show: Used to display your custom types. ghci repl uses it.
    #+begin_src haskell
data Color = Red | Green | Blue

instance Show Color where
  show Red = "rojo"
  show Green = "verde"
  show Blue = "azul"
    #+end_src
* Book: The Haskell School of Expressive Language
** 3 Simple Graphics
*** 3.1 Basic Input/Output
- ~Standard Prelude~ and ~Standard Libraries~
- () is called ~unit type~, ans has only () as value
- IO
  There is a special kind of ~value~ called ~action~.
  It won't try to display it but it will take action.
  Ex: writing to a file or reading from keyboard.
  ~expressions~ or functions that evaluate to an action are called ~commands~
- IO () is often called a ~noop~, it is an action that returns ()
- putStr, putChar, writeFile, readFile, do, getLine
- ??? you can put actions on a list, but won't "do" anything unless on a do or a main ???
- sequence applied to IO has this signature
  sequence :: [IO a] -> IO ()

*** 3.2 Graphics Windows
- sierpinsky
#+begin_src haskell
fillTri :: Window -> Int -> Int -> Int -> IO ()
fillTri w x y size =
  drawInWindow w
  $ withColor Green
  $ polygon [(x,y), (x + size, y), (x, y - size), (x,y)]

minSize :: Int
minSize = 8

sierpinskiTri :: Window -> Int -> Int -> Int -> IO ()
sierpinskiTri w x y size
  | size <= minSize = fillTri w x y size
  | otherwise       = let size2 = size `div` 2
                      in do sierpinskiTri w x y size2
                            sierpinskiTri w x (y - size2) size2
                            sierpinskiTri w (x + size2) y size2
#+end_src
- david star:
  1) draw a equilateral triangle
  2) draw a new one rotated 180
  3) do 1 and 2 for each corner, but with 1/3 of a triangle size
** 4 Shapes II: Drawing shapes
- Many indirect graphics functions, to:
  1) being able to work with each shape properties
** 5 Polymorphic and High-order Funtions
* Book: Haskell Tutorial and Cookbook
** 1
#+begin_src haskell
module Main where
module Main (main) where
#+end_src
- : concatenates Char to [Char]
- !! for list index access
- ++ concatenate lists
- length of tuples will always be one (1)
|       |       |           | destructuring     |   |
|-------+-------+-----------+-------------------+---|
| tuple | (A,B) | fst/snd   | let (a,b)=('a',1) |   |
| list  | [T]   | head/tail |                   |   |
* Book: 2022 | Practical Haskell | Alejandro Serrano Mena
source https://github.com/Apress/practical-haskell
- Packages https://hackage.haskell.org/
- Packages https://www.stackage.org/ (subset of hackage)
- Installation Manager https://www.haskell.org/ghcup/
- GHCI https://wiki.haskell.org/GHC/GHCi
- library https://hackage.haskell.org/package/containers https://haskell-containers.readthedocs.io/en/latest/
- library https://www.yesodweb.com/book/persistent
- Package Version Policy https://pvp.haskell.org/
- Encyclopedia of Typeclasses https://wiki.haskell.org/Typeclassopedia
** 1 Going Functional
- Haskell:
  1) Functional
  2) Purity, separates code with side-effects
     - Expressions in haskell cannot have side effects by defaults. Are called pure.
     - Referential Transparency: https://en.wikipedia.org/wiki/Referential_transparency
       If it can be replaced with their corresponding value (and vice-versa) without changing the program's behavior.
       Requires a function to be pure.
  3) Laziness, *evaluation model*
  4) Statically Checked
     - Java and C#, need to perform extra type checking at runtime
     - Haskell, no more type checks are done once the program has been compiled. Increases Performance.
     - Type-Oriented Programming:
       programmers know the type of the functions they are developing and have a broad idea of the structure of the code
       then they fill the holes with expressions from the surrounding environment
  5) Polimorphism,
     - based on *parametricity* (like generics in Java and C#) (templates on c++?)
     - and *type classes* which groups different types witha common interface
- 1980 - Miranda was one of the most important lazy functional programming languages
- Haskell Versions: 98, 10
- $ ghcup install cabal
  $ ghcup install stack
  $ ghcup list
  $ ghcup install hls
  $ ghcup compile <TOOL_NAME>
- Emacs: lsp-mode, lsp-ui, lsp-haskell
- use ":{" and ":}" for multi-line blocks on ghci
  :?
  :show languag
  :quit
** 2 Declaring the Data Model
*** Characters, Numbers and Lists
|---------+-------------------------------------------+--------------------+------------------------|
| Char    | Contains one Unicode character            | 'a', '\97', '\x61' | import Data.Char       |
| Int     | Have the native width of the architecture |                    |                        |
| Integer | unbounded integral type                   |                    |                        |
| Ratio   |                                           | 1 % 3              | import Data.Ratio      |
| [Char]  |                                           | "Hello World!"     |                        |
| Bool    | has short-circuiting due laziness         | True, False        | and, or, not, ==, >, < |
|         |                                           |                    |                        |
|---------+-------------------------------------------+--------------------+------------------------|
- Data: Clients, Machines and Orders
- "Sometimes, ADTs and pattern mathcing lead to code that's not clear enough.
   Records introduce some syntactic forms that make values easier to create and modify"
- Haskell does not make numeric constants of a specific type.
  Uses Num and Fractional. Which are polymorphic.
- Like in most functional languages, lists in Haskell are *linked lists*
- Lists of lists do not need to be of the same dimension, so they are not equivalent to arrays of multiple dimensions.
  [] and [[]] are NOT equivalent
*** Creating a New Project (and module)
| name  | goals and features               | installation |             | repo     |
|-------+----------------------------------+--------------+-------------+----------|
| cabal |                                  | no           | name.cabal  | Hackage  |
| stack | reproducible builds + versioning | yes          | +stack.yaml | Stackage |
|-------+----------------------------------+--------------+-------------+----------|
- stack new project-name
  stack setup
  stack build
- cabal init --interactive
  cabal configure
  cabal build
- .cabal
  - case insensitive property name
  - stanzas begin with a header (eg: library or executable)
- Changing the Source Directory
  #+begin_src
  library
    hs-source-dirs: src
  #+end_src
- modules in Haskell
  - similar to packages in Java or namespaces in C#
  - each modulo defined on his own file
  -        Chapter2.Section2.Example goes in path Chapter2/Section2/Example.hs
  - module Chapter2.Section2.Example where
  - to compile it with cabal include it on some stanza
    #+begin_src
      library
        exposed-modules: Chapter2.Section2.Example
        -- OR
        other-modules: Chapter2.Section2.Example
    #+end_src
*** Defining Simple Functions
- tuples of different lengths are completely different types
- src/Chapter2/SimpleFunctions.hs
  #+begin_src haskell
    {- Multiline
       Comment -}
    firstOrEmpty :: [[Char]] -> [Char] -- Single Line Comment
    firstOrEmpty lst = if not (null lst) then head lst else "empty"
  #+end_src
- Use *local binding* to avoid recomputation
  - let vs where
    - let bindings before the main expressions, must end with an "in"
    - where does after the expression
- Haskell uses a *layout-based syntax*
- group blocks {;;}, discouraged!!!!
  #+begin_src haskell
    where { t = maxmin (tail list); t_max = fst t ; t_min = snd t }
  #+end_src
- ADTs, must have
  1) have a name
  2) a set of constructors
- Example: 3 different kinds of clients, using *auto-deriving* for Show
  #+begin_src haskell
    -- Goverments: need a name
    -- Companies: need a id number, contact person, position of the contact
    -- Individuals: name, surname, if they want spam
    data Client = GovOrg     String
                | Company    String Integer Person String
                | Individual Person Bool
                deriving Show
    data Person = Person String String Gender
                deriving Show
    data Gender = Male | Female | Unknown
                deriving Show
  #+end_src
- Types, constructors, type classes, and kinds must start with an UPPERCASE letter
- Inside a module all constructors MUST have a *different name*
- Data Types and Constructors live in *different namespaces* (? worlds
- All *types inside* a "showable" must derive Show too
- Functions that are not defined over the complete domain of their arguments are called *partial*
*** Working With Data Types
- Pattern Matching does *NOT backtrack* when something goes wrong in the body of a match
- You can pattern match on *let* and *where* but with only 1 pattern
  - instead of
    #+begin_src haskell
      let name = case companyName client of
                   Just n -> n
    #+end_src
  - with let pattern matching
    #+begin_src haskell
      let Just name = companyName client
    #+end_src
  - where
    #+begin_src haskell
      maxmin [x]    = (x,x)
      maxmin (x:xs) = ( if x > xs_max then x else xs_max
                      , if x < xs_min then x else xs_min
                      ) where (xs_max, xs_min) = maxmin xs
    #+end_src
- Is customary in Haskell
  1) to write the pattern matching on lists using a letter or a small word followed by the same identifier in plural
     - like "x" and "xs"
     - or "x:y:zs"
  2) to use the same identifier, but with (') (pronounced prime) afterward, to refer to a highly related binding
  3) With guards, using *otherwise* in the last pattern, when using guards is a common convention
     - Although it does NOT do anything
**** =as pattern=, allows you to *bind* some value in the match, while at the same time allowing you to match on inner components
  #+begin_src haskell
    -- instead of
    sorted []       = True
    sorted [_]      = True
    sorted (x:y:zs) = x < y && sorted (y:zs)
    -- you can use the "as patternW
    sorted []            = True
    sorted [_]           = True
    sorted (x : r@(y:_)) = x < y && sorted r
  #+end_src
**** =Guards!=
  - Anything that returns Boolean can be used, including our custom functions
  - A compact syntax can be used for checking several conditions on the same argument
    #+begin_src haskell
      specialMultiples n
        | multipleOf n 2 = show n ++ " is multiple of 2"
        | otherwise      = show n ++ " is a beautiful number"
      -- Instead of
      specialMultiples n | multipleOf n 2 = show n ++ " is multiple of 2"
      specialMultiples n | otherwise      = show n ++ " is a beautiful number"
    #+end_src
**** =View Patterns= (extension) to preprocess the value before matching
  function -> pattern
  which applies *function* to the value AND then matches the result with the *pattern*
  needs a *pragma*
  #+begin_src haskell
    {-# LANGUAGE ViewPatterns #-} -- in ghci do ":set -XViewPatterns"
    responsability :: Client -> String
    responsability (Company _ _ _ r) = r
    responsability _                 = "Unknown"

    specialClient :: Client -> Bool
    specialClient (clientName -> "Mr. Alejandro") = False
    specialClient (responsability -> "Director")  = True
    specialClient _                               = False
  #+end_src
**** =Records=
  - Regular Pattern matching on big structure may get unwierdly quickly, because:
    1) it forces to write long matches to retrieve just a single value
    2) and to re-create entire data structure merely to change just a single field
  - *Defining* using data declarations, instead of "types" for each parameter you
    #+begin_src haskell
      data ClientR = GovOrgR  { clientRName :: String }
                   | CompanyR { clientRName :: String
                              , companyId :: Integer
                              , person :: PersonR
                              , duty :: String }
                   | IndividualR { person :: PersonR }
                   deriving Show

      data PersonR = PersonR { firstName :: String
                             , lastName :: String
                             } deriving Show
  #+end_src
  - *Create*, either passing the values directly OR a list of each field name followed by (=) and the value
    #+begin_src haskell
      GovOrgR "NATO"
      IndividualR { person = PersonR { lastName = "Smith", firstName = "John" } }
    #+end_src
  - *Access*, special functions are automatically created to access those particular fields
    #+begin_src haskell
      > clientRName (GovOrgR "NATO")
        "NATO"
      > :t duty
        duty :: ClientR -> String
    #+end_src
  - *Pattern Matching*, do NOT need to write a binding or pattern for *each field* in it.
    #+begin_src haskell
      greet :: ClientR -> String
      greet IndividualR { person = PersonR { firstname = fn } } = "Hi, " ++ fn
      greet CompanyR    { clientRName = c }                     = "Hi, " ++ c
      greet GovOrgR     { }                                     = "Welcome"
    #+end_src
  - *Pattern Matching* =record puns=, creates a binding for the correspinding field availble *with the same name* in the body of hte match.
    #+begin_src haskell
      {-# LANGUAGE NamedFieldPuns #-}
      greet IndividualR { person = PersonR { firstname } } = "Hi, " ++ firstName
      greet CompanyR    { clientRName }                    = "Hi, " ++ clientRName
      greet GovOrgR     {  }                               = "Welcome"
    #+end_src
  - *Pattern Matching* automatically create bindings (..), while making some field obey a pattern
    #+begin_src haskell
      {-# LANGUAGE RecordWildCards #-}
      greet IndividualR { person = { PersonR { .. } } = "Hi, " ++ firstName
      greet CompnayR    { .. }                        = "Hi, " ++ clientRName
      greet GovOrgR     { }                           = "Welcome"
    #+end_src
  - *Updating* a record field
    #+begin_src haskell
      import Data.Char (toUpper)
      nameInCapitals :: PersonR -> PersonR
      nameInCapitals p@(PersonR { firstName = initial:rest }) =
        let newName = (toUpper initial):rest
        in p { firstName = newName } -- UPDATE!!!
      nameInCapitals p@(PersonR { firstName = "" }) =
        p
    #+end_src
  - Use case: *Default* values for functions calls.
    Instead of writing a function with a lot of arguments. Use a *record* for the default arguments.
    Provide this record as *constant* with sensible defaults.
    Changing defaults would mean just a record *update* as seen before
    Is better for maintainability, to forbid calling the constructor directly, forcing the use of the constant.
    #+begin_src haskell
      data ConnType = TCP | UDP
      data UseProxy = NoProxy | Proxy String
      data TimeOut  = NoTimeOut | TimeOut Integer
      data Connection = ... -- Definition ommited
      data ConnOptions = ConnOptions { connType      :: ConnType
                                     , connSpeed     :: Integer
                                     , connProxy     :: UseProxy
                                     , connCaching   :: Bool
                                     , connKeepAlive :: Bool
                                     , connTimeOut   :: Timeout
                                     }

      connect' :: String -> ConnOptions -> Connection
      connect' url options = ...

      connDefault :: ConnOptions
      connDefault = ConnOptions TCP 0 NoProxy False False NoTimeout

      > connect' "https://apress.com" connDefault { connType = UDP }
    #+end_src
**** Exercise on Guards: Binomial Coeficient
- of n and k
- This coefficient gives the *number of ways* in  which you can get =k= balls from a bag of =n= without repetition
- Solution: Using Pascal's Triangle
- ERROR: Without guards
  #+begin_src haskell
    binom _ 0 = 1
    binom x x = 1 -- ERROR: variables can appear only once
    binom n k = (binom (n-1) (k-1)) + (binom (n-1) k)
#+end_src
- With guards
  #+begin_src haskell
    binom _ 0          = 1
    binom x y | x == y = 1
    binom n k          = (binom (n-1) (k-1)) + (binom (n-1) k)

    ifibonacci n | n < 0 = Nothing
    ifibonacci 0         = Just 0
    ifibonacci 1         = Just 1
    ifibonacci n | otherwise = let Just f1 = ifibonacci (n-1)
                                   Just f2 = ifibonacci (n-2)
                               in Just (f1 + f2)
  #+end_src
**** Exercise 2-5: More Type Of Values
#+begin_src haskell
  data TimeMachine = TimeMachine String Int String Bool Bool Float
                   deriving Show
#+end_src
**** Exercise 2-5: The perfect match for your machines
  - Write a function that return the number of clients of each gender
    #+begin_src haskell
      data Result = Result Int Int Int
        deriving Show
      gender2Result :: Gender -> Result
      gender2Result Male    = Result 1 0 0
      gender2Result Female  = Result 0 1 0
      gender2Result Unknown = Result 0 0 1

      addResult :: Result -> Result -> Result
      (Result m1 f1 u1) (Result m2 f2 u2) = Result (m1+m2) (f1+f2) (u1+u2)

      clientsPerGender :: [Client] -> Result
      clientsPerGender []                                       = Result 0 0 0
      clientsPerGender (GovOrg _) : xs                          = clientsPerGender xs
      clientsPerGender (Company _ _ (Person _ _ gender) _) : xs = addResult (clientsPerGender xs) $ gender2Result gender
      clientsPerGender (Individual (Person _ _ gender) _)  : xs = addResult (clientsPerGender xs) $ gender2Result gender
    #+end_src
  - sale-off price of timemachines
    #+begin_src haskell
      saleOffPrice :: [TimeMachine] -> Float
      saleOffPrice []                                 = 0.0
      saleOffPrice (TimeMachine _ _ _ _ _ price) : xs = (price * 0.9) + saleOffPrice
    #+end_src
**** Exercise 2-6: More Matches and Guards
#+begin_src haskell
  ackerman :: Int -> Int -> Int
  ackerman 0 n                  = n + 1
  ackerman m 0 | m > 0          = ackerman (m-1) 1
  ackerman m n | m > 0 && n > 0 = ackerman (m-1) $ ackerman m (n-1)

  gunzip :: [(a,b)] -> ([a],[b])
  gunzip []           = ([],[])
  gunzip ((a,b) : xs) = (a : as, b : bs)
    where (as,bs) = gunzip xs
#+end_src
**** Exercise 2-7: Time Machine Records
#+begin_src haskell
  {-# LANGUAGE NamedFieldPuns #-}
  data TimeMachine = TimeMachine { manufacturer :: String
                                 , model        :: Int
                                 , name         :: String
                                 , backwards    :: Bool
                                 , forwards     :: Bool
                                 , price        :: Float
                                 } deriving Show

  saleOffPrice :: [TimeMachine] -> Float
  saleOffPrice []                           = 0.0
  saleOffPrice (TimeMachine { price }) : xs = (price * 0.9) + saleOffPrice xs
#+end_src
** 3 Increasing Code Reuse
*** Parametric Polymorphism
- Etymology
  multiple = poly
  types    = morphé is Ancient Greek for "shape"
- OTH, =Ad-Hoc Polymorphism= allows for functions to be applicable for just a subset of all types
- Polymorphis is also available in data types
  - Example: in tuples, you have multiple type variables
    #+begin_src haskell
      data Triple a b c = Triple a b c
      data SamePair a = SamePair a a
    #+end_src
  - Example: where the "clientId" can take many shapes
    #+begin_src haskell
      data Client i = GovOrg  { clientId :: i, clientName :: String }
                    | Company { clientId :: i, clientName :: String
                              , person :: Person, duty :: String }
                    | Individual { clientId :: i, person :: Person }
                    deriving (Show, Eq, Ord)

      data Person = Person { firstName :: String, lastName :: String }
                  deriving (Show, Eq, Ord)
    #+end_src
*** Funtions As Parameters (HoF)
- map, succ, filter, even
- Ommit warning when using numeric constants on polymorphics functions
  gci -fno-warn-type-defaults
- ($) both sides of this operator will be evaluated before f is applied to a. Therefore, you can omit a lot parentheses.
  f $ a = f a
- =Anonymous functions= are sometimes called "lambda abstractions" or simply "abstractions"
  - Recursion is forbidden
  - only 1(one) pattern can be matched (like on let/where?)
    - Unless you are using GHC LambdaCase extension
      #+begin_src haskell
        {-# LANGUAGE LambdaCase #-}
        sayHello names = map (\case "Alejandro" -> "Hello, writer"
                                    name        -> "Welcome, " ++ name
                             ) names
      #+end_src
- =Section= is just a specification, careful of commutativity and where you put the operator.
  double = map (*2)
- =Partial application= encourages a programming style where functions are combined without ever mentioning their parameters.
  This is called *point-free style* (because in mathematic, parameters to functios are called points)
- =Combinators= functions:
  #+begin_src haskell
    uncurry :: (a -> b -> c) -> (a,b) -> c
    uncurry f = \(x,y) ->

    curry :: ((a,b) -> c) -> a -> b -> c
    curry f = \x y -> f (x,y)

    flip :: (a -> b -> c) -> (b -> a -> c)
    flip f = \x y -> f y x
  #+end_src
  - from multiple-argument functions to single-argument functions which take a tuple of values.
  - =Curried=: functions that take a sequence of arguments
  - Use Case: you are given a list of pairs of numbers, and you cant to get the list of maximums of pairs.
    #+begin_src haskell
      > map (uncurry max) [(1,2),(2,1),(3,4)]
        [2,2,4]
    #+end_src
**** Exercise 3.2 - Working With Filters
#+begin_src haskell
  {-# LANGUAGE LambdaCase #-}
  filterOnes :: [Int] -> [Int]
  filterOnes = filter ((==) 1)

  filterANumber Int -> [Int] -> [Int]
  filterANumber n = filter ((==) n)

  filterNot :: (a -> Bool) -> [a] -> [a]
  filterNot f = filter (not . f)

  isGovOrg :: Client -> Bool
  isGovOrg (GovOrg _) = True
  isGovOrg _          = False

  filterGovOrgs :: [Client] -> [Client]
  filterGovOrgs = filter isGovOrg

  filterGovOrgs :: [Client] -> [Client]
  filterGovOrgs = filter (\case (GovOrg_) -> True
                                 _        -> False)
#+end_src
*** More Modules (exporting/importing)
- After the *module* declaration but before any other definitions
 | All Functions  | import Data.List                             | Do not bring into scope child modules |
 | explicit       | import Data.List (permutations, subsequence) |                                       |
 | hiding imports | import Data.List hiding (head, tail)         |                                       |
 | data types     | import Chapter3.ParamPoly (Client())         | only type, no constructors            |
 |                | import Chapter3.ParamPoly (Client(GovOrg))   | a subset of construct(s)              |
 |                | import Chapter3.ParamPoly (Client(..))       | all constructors                      |
 | qualified      | import qualified Data.List (filter)          | use it as Data.List.filter            |
 | renaming       | import qualified Data.List as L              | use it as L.filter                    |
 | e+q+r          | import qualified Data.List as L(filter)      |                                       |
- NoImplicitPrelude
- By default every single declaration is exported
- eg: export only "f" declaration
  #+begin_src haskell
    module M (f) where
    f = ...
    g = ...
  #+end_src
- eg: only export data type and default
  #+begin_src haskell
    module Chapter2.DataTypes (ConnOptions(), connDefault) where -- the Data Type and the constant
  #+end_src
**** =Smart Constructors=, hidding the constructors and giving the data type
  the idea is to provide a function that acts as the constructor and checks for invariants on the creation of the data types
  - Try 1: we fail to provide pattern match, since we don't export the constructor
   #+begin_src haskell
     module Chapter3.Ranges (Range(), range) where
     data Range = Range Integer Integer deriving Show
     range :: Integer -> Integer -> Range
     range a b = if a <= b then Range a b else error "a must be <= b"
  #+end_src
  - Try 2: create a *new data type* that encodes the observed value of that type.
    #+begin_src haskell
      data RangeObs = R Integer Integer deriving Show
      r :: Range -> RangeObs
      r (Range a b) = R a b
    #+end_src
    And then use =views= when pattern matching.
    #+begin_src haskell
      {-# LANGUAGE ViewPatterns #-}
      prettyRange :: Range -> String
      prettyRange rng = case rng of
                          (r -> R a b) -> "[" ++ show a ++ "," ++ show b ++ "]"
    #+end_src
  - Try 3: Create a =pattern synonym= which packages this form of building/deconstructing Range values
    Using a =bidirectional pattern=
    #+begin_src haskell
      {-# LANGUAGE PatternSynonyms #-}
      pattern R :: Integer -> Integer -> Range -- 1) coincides with the Range constructor
      pattern R a b <- Range a b               -- 2) the matcher, the equivalences
        where R a b = range a b                -- 3) makes it equivalent to the function call (range) our smart-constructor
    #+end_src
*** Diving into Lists (foldr,comprehensions)
- {} pattern can be used for matching a constructor regardless of the datatype elements.
- Individual{person = p1}
- can use *where* to define functions
  #+begin_src haskell
    companyDUtiesAnalytics :: [Client a] -> [String]
    companyDutiesAnalytics = map (duty . head) .
                             sortBy (\x y -> compare (length y) (length x)) .
                             groupBy (\x y -> duty x == duty y) .
                             filter isCompany
      where isCompany (Company {}) = True
            isCompany _            = False
  #+end_src
- The *initial* value on foldr, is also called *neutral* or *identity element* of the operation.
- Example: maximum, we define:
  1) a new polymorphic type to support infinity
  2) an initial value, considering the max of an empty list (the MinusInfinity), and the it shouldn't change the value of binary operation
  #+begin_src haskell
    data InfNumber a = MinusInfinity
                     | Number a
                     | PlusInfinity
                     deriving Show

    infMax :: InfNumber -> InfNumber
    infMax MinusInfinity x       = x
    infMax x MinusInfinity       = x
    infMax PlusInfinity _        = PlusInfinity
    infMax _ PlusInfinity        = PlusInfinity
    infMax (Number a) (Number b) = Number (max a b) -- call to max

    foldr infMax                        MinusInfinity [1,2,3] -- Error
    foldr infMax                        MinusInfinity $ map Number [1,2,3]
    foldr (\x y -> infMax (Number x) y) MinusInfinity [1,2,3]
  #+end_src
- ranges
  withPositions list = zip [1 .. length someList] list
**** foldr1 or foldl1
  - they do NOT take an intial value, but they take it from the first/last element of the list
    - used then handling an empty list is guarenteed not to happen
  - are know as "reduce" in other languages
  - example maximum
    #+begin_src haskell
      maximum' :: [Integer] -> Integer
      maximum' = foldr1 max
    #+end_src
**** Data.List
| partition     | on Data.List, returns a tuple of filter/(not filter)                       |               |
| find          | returns Maybe                                                              |               |
| dropWhile     | returns a list *from* the point in which predicate becomes False           |               |
| takeWhile     | returns a list of the initial elements *until* the predicate becomes False |               |
| span          | returns a tuple of dropWhile/takeWhile                                     |               |
| break         | like span, but negates the predicate first                                 |               |
| any           | "exists"                                                                   |               |
| all           | "for all"                                                                  |               |
|---------------+----------------------------------------------------------------------------+---------------|
|               | BINARY PREDICATES                                                          |               |
|---------------+----------------------------------------------------------------------------+---------------|
| nubBy         | returns a list, takes out elements, so no two elements are equivalent      |               |
| nub           | works with the default comparison of the type                              |               |
| union(By)     | from 2 lists                                                               |               |
| intersect(By) | from 2 lists                                                               |               |
| insert(By)    | adds one elements to a set,                                                |               |
| (\\)          | set difference                                                             |               |
| elem          | if element is on a list, boolean                                           |               |
|---------------+----------------------------------------------------------------------------+---------------|
| groupBy       | put 2 elements in the same group if True                                   | Data.List     |
| on            | when 2 elements are compared, AFTER using a functions                      | Data.Function |
| flip          | calling a 2-parameter functions with the arguments reversed                |               |
|---------------+----------------------------------------------------------------------------+---------------|
| zip           |                                                                            |               |
| unzip         |                                                                            |               |
| lookup        | Maybe associative list lookup                                              |               |
|               |                                                                            |               |
**** Ordering (sortBy,sort,compare)
- When *compare* function is defined, Haskell also provides impplementationd of the >,<,>=,<= operators
- Some types already come defined with adefault way in which to otder values.
  - numbers, characters
  - tuples, lists: if their contained elements have default comparison. Lexicographicly. Smaller lists first.
- For both clarity and performance reasons, ordering in haskell is NOT defined by returning a Bool,
  but by returning and *Ordering* Value. Which can be LT, EQ, GT.
  - Example: Ordering Clients by type and name
    #+begin_src haskell
      > sortBy compareClient listOfClients
      > sort [1,4,2,-3]
      > compare (1,2)                 => GT
      > compare "Hello" "Hello world" => LT
      > compare "This" "That"         => GT
      compareClient :: Client a -> Client a -> Ordering
      compareClient (Individual{person = p1}) (Individual{person = p2})
                                      = compare (firstName p1) (firstName p2)
      compareClient (Individual {}) _ = GT
      compareClient - (Individual {}) = LT
      compareClient c1 c2             = compare (clientName c1) (clientName c2)
    #+end_src
**** List Comprehensions
- They can be understand, either as a:
  - set expression
  - SQL expression
  - quey expression in C# 3.0
- Has 2 parts separated by (|) and wrapped by []
  1) =Expression=: defines the transformation sot apply
  2) =Qualifiers=: from whence the elements will come, and the contraints upon them
#+begin_src haskell
  dupicateOdds list = [ 2 * x | x <- list, odd x]
  -- generators can have a PATTERN stating that only values matching it will be included
  [ clientName x | x@(GovOrg _ _) <- listOfClients ]
  -- Might depends on other value in the comprehension
  [(x,y) | x <- [0 .. 6], y <- [x .. 6]]
  -- LIST OF LIST, might appear on the right hand side of the generator
  import Data.Char
  [ toUpper c | s <- ["A","list"], c <- ' ':s ]
  -- LET expressions, for readability of the code
  [ sqrt v | (x,v) <- [(1,2),(3,8)], let v = x*x+y*y ]
  -- GUARDS, are just a call to a predicate. Only those elements satisfying the guard will go in.
  [(x,y) | x <- [1 .. 6], y <- [1 .. 6], x <= y]
  -- EXTENSION, :set -XTransformListComp
  -- then (f), transforms the input list by applying the function to the result of the comprehension
  [x*y | x <- [-1,1,-2], y <- [1,2,3], then reverse ]
  -- then (f) by (v), transforms the list depending on the values in (v)
  import GHC.ext -- for sortWith
  [x*y | x <- [-1,2,-2], y <- [1,2,3]
       , then sortWith by x ]
  -- group by (e) using (f)
  -- In many cases, all grouped elements will be equal, so GHC provies a THE function that takes just 1 element form the list
  import GHC.ext -- for groupWith
  [ (the p, m) | x <- [-1,2,-2]
               , y <- [1,2,3]
               , let m = x*y
               , let p = m > 0
               , then group by p using groupWith ]
  -- PARALLEL Comprehension
  -- :set -XParallelListComp
  -- More than 1(one) branch of qualifiers can be stated, separated by (|)
  -- Instead of nesting iterations, the result of all branches will be "zipped"
  [ x*y | x <- [1,2,3] | y <- [1,2,3] ] -- [1,4,9]
#+end_src
***** Example
#+begin_src haskell
  companyAnalytics :: [Client a] -> [(String, [(Person, String)])]
  companyAnalytics clients = [ (the clientName, zip person duty)
                             | client@(Company { .. }) <- clients
                             , then sortWith by duty
                             , then group    by clientName using groupWith
                             , then sorWith  by length client
                             ]
#+end_src
**** TODO Exercise 3.3 - Your first folds
#+begin_src haskell
  -- Pattern Matching
  product :: [Integer] -> Integer
  product []     = 1
  product (x:xs) = x * product xs

  clientLength :: Client -> Integer
  clientLength GovOrg name                      = length name
  clientLength Company name _ _ _               = length name
  clientLength Individual (Person name _ _ _) _ = length name

  minimumClient :: [Client] -> Client
  minimumClient client : cs = min (clientLength client) $ minimumClient cs

  all :: [Bool] -> Bool
  product []     = True
  product (x:xs) = x && product xs
  -- folds
  product :: [Integer] -> Integer
  product = foldr1 (*)
  minimumClient :: [Client] -> Client
  all :: [Bool] -> Bool
  all = foldr1 (&&)
#+end_src
*** Haskell Origami (unfold)
- You can write almost all list functions using foldr
- How to ensure that one function using pattern matching and other using fold are equivalent?
  - =Induction= & =Equational Reasoning=
    - a technique for formally verifying code that manipulates equations between functions.
    - prove that works the same way for the *base case* (the empty list)
    - prove that they are equal for "xs", as well as for "x:xs", the *inductive step*
- Can define in terms of fold: filter, map
- =fusion law= for maps
  map f . map g = map (f . g)
**** unfoldr :: (b -> Maybe (a,b)) -> b -> [a]
- create a lists out of some seed
- *Nothing* signals that it should stop producing elements
  *Just (x,s)* attaches (x) to the new list, AND continues to process with a new seed (s)
- Example: enumUnfold
  #+begin_src haskell
    enumUnfold :: Int -> Int -> [Int]
    enumUnfold n m = unfoldr (\x -> if x > m then Nothing else Just (x, x+1)) n
  #+end_src
- Example: minSort
  #+begin_src haskell
    minSort :: [Integer] -> Integer
    minSort = unfoldr (\case [] -> Nothing
                             xs -> Just (m, delete m xs) where m = minimum xs)
  #+end_src
*** Summary
** 4 Using Containers and Type Classes
*** Using Packages
- A package is the *distribution unit of code* understood by Cabal and Stack
  - It includes a set of modules
- Stackage provides *snapshots* of Hackage (called *resolvers*) in which all pacakges are know to work well together.
  - Provides reproducibility
  - At the expense of not always containing the bleeding-edge version of the packages
- Add packages to =build-depends= property on your .cabal file
  - Can add it to both the "library" or in "executable" stanzas
- =Rule of Thumb=
  - add constraint requiring the MINIMUM version where you know that your package compiles and runs.
  - and another constraint to limit future versions to the next MAJOR one
  #+begin_src
    containers >= 0.6.0.1 && 0.7
  #+end_src
- Package Versioning Policy
  1) If any Function/DataType/TypeClass/Instance has been changed or its type or behavior removed,
     the major version (a.b) must be increased.
  2) Otherwise, for additions you can just increase the remaining components (x.x.c.d).
     Except in the case of a likely conflict with a module in another package
**** Cabal
- Cabal mutability landscape changed with the introduction of =sandboxes=
  - Packages were installed globally
  - Used to be an opt-in feature
  - IF you use the cabal commands starting with ~new-~ you use sandboxes
    They must run in a folder in which a .cabal file exists
- Cabal keeps a Hackage indes locally
  $ cabal update
  $ cabal build
- How to: Develop several packages at the same time, one depending of the other.
  - Avoids "global mutation" of packages
  - Put all the packages in a common folder
  - Create a ~cabal.project~ file
    packages: chapter4 wonderful
  - Build 1(one) package:
    $ cabal new-build chapter4
    $ cabal new-build wonderful
**** Stack
- stack.yaml
  extra-deps: is for packages not in Stackage, but in Hackage. Needs name and version.
  #+begin_src
    resolver: lts-19.6
    packages:
    - .
    extra-deps: []
    - wonderful-0.2.1.0
    - git: my.server/my.repo.git
      commit: a67bc8
  #+end_src
- $ stack init
  - creates the stack.yaml file
  - it treis to use the most recent LTS resolver in which all dependencies can be satisfied
- $ stack setup
  - downloads the corresponding vesion of GHC, if needed
  - the same compiler is used for all the packages using the same major LTS version
- $ stack build
  - take scare of updating the information about its repositories before downloading any dependencies
*** Containers: Maps, Sets, Trees, Graphs
- A =container= is any *Data Structure* whose purpose is to hold elements of other types in it.
  - Lists
  - Trees
**** Data.Map
- Special purpose map where integers are the keys (more performant), in *unordered-containers*
  IntMap
  HashMap (when the keys are NOT numbers but are mapped to)
- many of the functions in that module collide with name s from the built-in Prelude
  #+begin_src haskell
  import qualified Data.Map as M
  #+end_src
- Haskell has no special syntax for maps (like for lists with [], or [1,2])
  or for exporting any of its data constructors.
| M.assocs             | get an assoc list from a map                                |
| M.empty              | constructor                                                 |
| M.singleton          | constructor, eg: M.singleton "hello" 3                      |
| M.fromList           | constructor, eg: M.fromList [("hello",3)]                   |
| M.insert             | adding new value                                            |
| M.insertWith         | adding new value, to combine the old value with the new one |
| M.insertWithKey      | adding new value,                                           |
| M.null               | checks if map is empty                                      |
| M.member             | checks if key is avaible on map                             |
| M.lookup             | returns a Maybe                                             |
| M.findWithDefault    |                                                             |
| M.delete             | kelete key from map                                         |
| M.adjust             | takes a function to apply to the value in key               |
| M.alter              | insert/delete/adjust are wrappers of this one               |
|                      | takes a (Maybe a -> Maybe a)                                |
| M.union(With)        | by default, the first map takes precedence if repeated      |
| M.intersection(With) |                                                             |
| M.difference(With    |                                                             |
| M.map                |                                                             |
| M.foldr              |                                                             |
| M.foldl              |                                                             |
| M.filter             |                                                             |
| M.partition          |                                                             |
| M.find(Min/Max)      |                                                             |
| M.delete(Min/Max)    |                                                             |
| M.update(Min/Max)    |                                                             |
**** Data.Set
- Like lists but do not allow duplicates
- Sorts in ascending order
- Special purpose types for sets of integers, in *unordered-containers*
  IntSet
  HashSet (when the values are not integers, but are mapped to...)
- Elements in a set don't have a key
  #+begin_src haskell
    import qualified Data.Set as S
  #+end_src
- union/intersection/difference/member/map
| S.empty     | constructor |
| S.singleton | constructor |
| fromList    | constructor |
| toList      | set to list |
| insert      | add one     |
|             |             |
**** Data.Tree
#+begin_src haskell
  data Tree   a = Node { rootLabel :: a, subForest :: Forest a }
  type Forest a = [Tree a]
#+end_src
| Data.Tree     | flatten | pre-order traversal, just returns them as they are |
| Data.Tree     | levels  | BFS, returns each level as a list                  |
| Data.Foldable | foldr   |                                                    |
| Prelude       | fmap    |                                                    |
- *type* creates type synonyms
  *newtype* does NOT create type equivalents
- composed of nodes, which hold a vlaue and may have other trees as children
  - Those children are represented as bare list of trees (a forest)
- This implementation is not specialized for any particular purpose
  - TreeStructures, AvlTree, RBTree
- ways to visit nodes in a tree
  1) DFS pre-order  (visiting the value before any subtree)
  2) DFS post-order (visiting the value after all subtrees are visited)
  3) BFS
- preorder example
  #+begin_src haskell
    import Data.Tree
    preORder :: (a -> b) -> Tree a -> [b]
    preOrder f (Node v subtrees) -- TRY concatMap
      = let subtreesTraversed = concat $ map (preOrder f) subtrees
        in f v : subtreesTraversed
  #+end_src
**** Data.Graph
| graphFromEdges   | constructor, gets a list of triplets, returns also 2 lookup functions |
| buildG           | constructor, gets a tuple and a list of tuples                        |
|------------------+-----------------------------------------------------------------------|
| vertices         |                                                                       |
| edges            |                                                                       |
| reachable        | every vertex reachable from vertex                                    |
| path             | boolean, path between vertex names                                    |
| scc              | strongly connected components                                         |
| stronglyConnComp | a special type SCC is used for repsenting each component              |
| flattenSCC       | returns a printable version of SCC                                    |
- graphs are vertices joined via a set of edges
- on this implementation
  - nodes are always integers
  - edges are directed
  - without weights
- Example: find the partitions of *strongly connected components* and filter out the one with only 1 node, due being built with buildG
  #+begin_src haskell
    filter (\(Node { subForest = s }) -> s /= []) $ scc timeMachineTravel
  #+end_src
*** =Ad-Hoc Polymorphism=: Type Classes
- M.insert :: Ord k => k -> a -> M.Map k a -> M.map k a
  - Ord =type class=
  - Ord k, used to constrain the set of possible types that k type variable can take
- You can express that certain types exhibit a common behavior
- Declaring a type class, aka class
  #+begin_src haskell
    class ClassName variable where
      oneFunction :: oneType
  #+end_src
- =Instance= of a type class, that type supports the operation of the typeclass
  In OO, it means a concreate value of a class
  In Haskell, it refers to the implementaion of a class by a type
  #+begin_src haskell
    instance ClassName Type where
      oneFunction = ... -- Implementation
    instance Nameable (Client i) where
      name Individual { person = Person { firstName = f, lastName = n } }
        = f ++ " " ++ n
  #+end_src
- Is NOT possible to prevent an instance declaration from being imported.
  import Module () -- would then import the instance declarations
- Haskell is able to *derive* instances for only some type classes, which are hard-coded in the compiler
  - Generic Programming, provides ways to write functions that depend on the *structure* of data types
- to use *read*, haskell needs to know which instance of Read should be used
- Ord, Eq
  - Type Classes
  - Encode the "default comparisons" and "default equivalences" for lists
  - Eq has *default definitions* for (==) and (/=) you need to implement just one.
    For a minimal complete definition.
- =restrictions for instantiating a type class=,
  - eg: an instance of Eq for any possible list type in a generic way.
    - in this case we require the inner elements also implement the Eq class
    #+begin_src haskell
      instance Eq a => Eq [a] where
        []     == []     = True
        (x:xs) == (y:ys) = x == y && xs == ys
        _      == _      = False
    #+end_src
  - eg : Ord
    - Prerequisite it's being a member of Eq
      - Eq is a =superclass= of Ord
    - minimal complete definitions, is either implementing *compare* or *<=*
    #+begin_src haskell
      class Eq a => Ord a where
        compare              :: a -> a -> Ordering
        (<), (<=), (>), (>=) :: a -> a -> Bool
        max, min             :: a -> a -> a
        compare x y = if x == y then EQ
                      else if x <= y then LT
                           else GT
        x < y   = case compare x y of { LT -> True; _ -> False }
        x <= y  = case compare x y of { GT -> False; _ -> True }
        x > y   = case compare x y of { GT -> True; _ -> False }
        x >= y  = case compare x y of { LT -> False; _ -> True }
        max x y = if x <= y then y else x
        min x y = if x <= y then x else y
    #+end_src
- Constants are polymorphic
- Number related type classes
 | Num                     | +,-,*,negate,abs,signum,fromInteger               |
 | Num>Real                | toRational                                        |
 | Num>Real>Integral       | quot, rem, quotRem AND div, mod, divMod           |
 | Num>Fractional          | /, recip, fromRational                            |
 | Num>Fractional>Floating | pi, e, aqrt, log, exp, **, trigonometry functions |
- Example: *Complex* type class instance of Num (already defined on Data.Complex module)
  1) i^2 = -1
  2) absolute |x| and argument 0x
  #+begin_src haskell
    data Complex = C Double Double deriving (Show, Eq)
    instance Num Complex where
      (C a1 b2) + (C a2 b2) = C (a1 + a2) (b1 + b2)
      (C a1 b2) - (C a2 b2) = C (a1 - a2) (b1 - b2)
      (C a1 b2) * (C a2 b2) = C (a1*a2 - b1*b2) (a1*b2-b1*a2)
      negate (C a b)        = C (negate a) (negate b)
      fromInteger           = C (fromInteger n) 0
      abs (C a b)           = C (sqrt $ a*a+b*b) 0
      signum c@(C a b)      = let C n _ = abs c
                              in C (a / n) (b / n)
  #+end_src
- =Data.Default= module has a TypeClass (Default) for abstract the default values idiom
  in the *data-default* package
  with a member *def*
  #+begin_src haskell
    instance Default ConnOptions where
      def = ConnOptions TCP 0 NoProxy Flase False NoTimeout
  #+end_src
**** Exercise 4-4 Prices for the store
#+begin_src haskell
  data Guide = Guide { price :: Double, to :: String }
  data Tool  = Tool  { price :: Double, name :: String}
  class Priceable where
    price :: Double
  instance Priceable Guide where
    price (price = p) = p
  instance Priceable Tool where
    price (price = p) = p

  totalPrice :: Priceable p => [p] -> Double
  totalPrice = foldr (\x y -> price x + price y)
  totalPrice = sum . map price
#+end_src
**** TODO Exercise 4-5 The same client
- Eq for "Person" and "Client i" types
#+begin_src haskell
#+end_src
**** TODO Exercise 4-6 Ordering clients
- Should compare the name of the client
- Individuals first and Companies later, and Organizations at the end.
- Might be add other comparisions for other fields
#+begin_src haskell
#+end_src
*** Binary Trees for the Minimum Price (=Monoid=)
#+begin_src haskell
  data TravelGuide = TravelGuide { title :: String
                                 , authors :: [String]
                                 , price :: Double }
                   deriving (Show, Eq, Ord)
#+end_src
- Designing a custom container to be used for the discount module of the timemachines example
  - Cheapest elements in the container
  - Will hhold travel guides
- Binary trees
  1) has *logaritmic* complexity for lookups
  2) each node holds a value and 2(two) *references* to subtrees
  3) any node in the *left subtree* will hold only those value smaller than the on in the node
**** Step 1 - Simple Binary Trees
#+begin_src haskell
  data BinaryTree = Node1 TravelGuide BinaryTree1 BinaryTree1
                  | Leaf1
                  deriving Show

  treeFind1 :: TravelGuide -> BinaryTree1 -> Maybe TravelGuide
  treeFind1 t (Node1 v l r) = case compare t v of
                                EQ -> Just v
                                LT -> treeFind1 t l
                                GT -> treeFind1 t r
  treeFind1 _ Leaf1         = Nothing

  treeInsert1 :: TravelGuide -> BinaryTree1 -> BinaryTree1
  treeInsert1 t n@(Node1 v l r) = case compare t v of
                                    EQ -> n
                                    LT -> Node1 v (treeInsert1 t l) r
                                    GT -> Node1 v l (treeInsert1 t r)
  treeInsert1 t Leaf1           = Node1 t Leaf1 Leaf1
#+end_src
**** Step 2 - Polymorphic Binary Trees
- While it is possible encode the restriction of the class elements that the binary tree may hold directly in the data declaration.
  It's not recommended.
  The best way is to encode the restriction in each of the operation that work on the structure.
  In order to impose this restriction, you must hide the Node2 and Leaf2 constructors from public consuption.
#+begin_src haskell
  data BinaryTree2 a = Node2 a (BinaryTree2 a) (BinaryTree2 a)
                     | Leaf2
                     deriving Show
  treeFind2 :: Ord a => a -> BinaryTree2 a -> Maybe a
  treeFind2 t (Node2 v l r) = case compare t v of
                                EQ -> Just v
                                LT -> treeFind2 t l
                                GT -> treeFInd2 t r
  treeFind2 _ Leaf2         = Nothing
#+end_src
**** Step 2.1 - Problem: order of the TravelGuide is NOT by default by price
  - You CANNOT override the default with "instance Ord TravelGuide where"
  - Naive solution would be creat a new field with a single field
    #+begin_src haskell
      data TGByPRice = TGByPrice TravelGuide
      instance ORd TGByPrice where . . .
    #+end_src
  - =newtype= used to declare another name for an already existing type
    NOT as a synonym, byt as a completely unrelated type.
    #+begin_src haskell
      newtype TGByPrice = TGByPrice TravelGUide deriving Eq
      instance Ord TGByPrice where
        (TGByPrice (TravelGuide t1 a1 p1)) <= (TGByPrice (TravelGuide t2 a2 p2)) =
          p1 < p2 || (p1 == p2 && (t1 < t2 || (t1 == t2 && a1 <= a2)))
    #+end_src
***** TODO Exercise 4-7 More operations on generic trees
After Step 2
1) treeInsert for BinaryTree2
2) concatenation of ninary trees, by repeatedly inserting all the elements in one of the binary trees
**** Step 3 - Binary Trees with Monoidal Cache
- New Problem: finding the smalles price still takes some time (going into the left subtree until you reach a leaf)
  Solution: include a cache in evey node. Stores the price of the smalles in the tree.
#+begin_src haskell
  data BinaryTree3 v c = Node3 v c (BinaryTree3 v c) (BinaryTree3 v c)
                       | Leaf3
                       deriving (Show, Eq, Ord)

  treeInsert3 :: (Ord v, Ord c)
              => v
              -> c
              -> BinaryTree3 v c
              -> BinaryTree3 v c
  treeInsert3 v c (Node3 v2 c2 l r)
    = case compare v v2 of
        EQ -> Node3 v2 c2 l r
        LT -> Node3 v2 (min c c2) (treeInsert3 v c l) r
        GT -> Node3 v2 (min c c2) l (treeInsert3 v c r)
  treeInsert3 v c Leaf3 = Node3 v c Leaf3 Leaf3
#+end_src
**** Step 3.1 Monoid and Semigroup (<>)
- Properties of the function to cache on the Binary Tree.
  An associative binary operation with an eelement that does not affect the outcome.
  A =Monoid=.
  1) Same type inputs and outputs: c -> c -> c
  2) Operation must be associative. Structure of the BT might not be the same.
  3) neutral element
     f e x = f x e = x
- =Data.Monoid=
  #+begin_src haskell
    class Monoid a where
      mempty  :: a           -- neutral element
      mappend :: a -> a -> a -- associative binary operation
      mconcat :: [a] -> a
  #+end_src
- Since GHC 8.4 Monois is subclass of a more general notion called
  =Semigroup= which *drops the neutral element* requirement and just includes the associative binary operation.
  #+begin_src haskell
    class Semigroup a where
      (<>) :: a -> a -> a
    class Semigroup a => Monoid a where ... -- since GHC 8.4
  #+end_src
- Examples of monoidal structures
  1) All with && and True
  2) All with || and False
  3) numbers, with Sum with addition and 0,
  4) numbers, with Product with multiplication and 1
**** Step 3.2 New version, using Monoid as a restriction
#+begin_src haskell
  treeInsert :: (Ord v, Monoid c)
             => v
             -> c
             -> BinaryTree3 v c
             -> Binarytree3 v c
  treeInsert4 v c (Node3 v2 c2 l r)
    = case compare v v2 of
        EQ -> Node3 v2 c2 l r
        LT -> let newLeft = treeInsert4 v c l
                  newCache = c2 <> cached newLeft <> cached r
              in Node3 v2 newCache newLeft r
        GT -> let newRight = treeInsert4 v c r
                  newCache = c2 <> cached l <> cached newRight
              in Node3 v2 newCache l newRight
  treeInsert4 v c Leaf3 = Node3 v c Leaf3 Leaf3

  cached :: Monoid c
         => BinaryTree v c
         -> c
  cached (Node3 _ c _ _) = c
  cached Leaf3           = mempty
  #+end_src
- Semigroup/Monoid instance and newtype needed for cache insertion algorithm to work
  #+begin_src haskell
    newtype Min = Min Double deriving Show
    instance Semigroup Min where
      Min x <> Min y = Min $ min x y
    instance Monoid Min where
      mempty  = Min infinity where infinity = 1/0
      mappend = (<>) -- use the definition from Semigroup
  #+end_src
*** Container-Related Type Classes (=Functors/Foldables=)
- Thinking about the commonalities between different containers.
  Lead to discover some useful type class.
**** Functors
- All on "Example 1" apply a function inside a data structure.
- A data type supporting  afunction like *map* is called a =functor=
  Notice how the types that are to be functions should take one type parameter (f a)
  Eg: IntSet cannot be used, even though conceptually is a Functor
  #+begin_src haskell
    class Functor f where
      fmap :: (a -> b) -> f a -> f b
  #+end_src
- =Kind system=
  - Is used for the haskell compiler to check the correct application of *type parameters*
  - Types themselves are also *categorized* based on the level of application
    1) Basic types have kind "*"
    2) Types that need one parameter to be fully applied such as Maybe, have kind "* -> *"
       So, the final kind for "Maybe Integer" is indeed "*"
- *Set* cannot be made an instance of Functor. Mapping functions would need to have an Ord restriction.
- There are other users that are not related to containers.
  - (->) r
  - aka functions of the form "r -> a"
  - The corresponding fmap type would be
    #+begin_src haskell
      fmap :: (a -> b)
           -> (r -> a)
           -> (r -> b)
    #+end_src
  - The instance would be
    #+begin_src haskell
      instance Functor ((->) r) where
        fmap f g = f . g
    #+end_src
***** Example 1: modifying  a value on a list/Map/Tree
#+begin_src haskell
  modifyTravelGuidePrice
    :: Double
    -> [TravelGuide]
    -> [TravelGuide]
  modifyTravelGuide m = map (\tg -> tg { price = m * price tg})

  modifyTravelGuidePriceMap
    :: Double
    -> M.Map a TravelGuide
    -> M.Map a TravelGuide
  modifyTravelGuidePriceMap m = M.map (\tg -> { price = m * price tg })

  modifyTravelGuidePriceTree
    :: Double
    -> T.Tree TravelGuide
    -> T.Tree TravelGuide
  modifyTravelGuidePriceTree m = fmap (\tg -> tg { price = m * price tg })
  #+end_src
***** Example 2: more general way to modify a container (fmap)
#+begin_src haskell
  modifyTravelGuidePrice'
    :: Functor f
    -> Double
    -> f TravelGuide
    -> f TravelGuide
  modifyTravelGUidePrice' m = fmap (\tg -> tg { price = m * price tg })
#+end_src
***** Exercise 4-8 Functor fun!
- Write the corresponding Functor instance for both Maybe and the binary trees from the previous section.
  - You will need to create a new type for Maybe value sin order to make the compiler happy.
  - Choose BinaryTree2 as the type for instantiating Functor
#+begin_src haskell
  instance Functor Maybe a where
    fmap _ Nothing  = Nothing
    fmap f (Just v) = (Just f v)
  instance Functor BinaryTree2 a where
    fmap f Leaf2         = Leaf2
    fmap f (Node2 v l r) = Node2 (f v) (fmap f l) (fmap f r)
#+end_src
**** Foldables
#+begin_src haskell
  class Foldable t where
    foldMap :: Monoid m => (a -> m) -> t a -> m
    foldr   :: (a -> b -> b) -> b -> t a -> b
    fold    :: Monoid m => t m -> m
    foldr'  :: (a -> b -> b) -> b -> t a -> b
    foldl   :: (a -> b -> a) -> a -> t b -> a
    foldl'  :: (a -> b -> a) -> a -> t b -> a
    foldr1  :: (a -> a -> a) -> t a -> a
    foldl1  :: (a -> a -> a) -> t a -> a
#+end_src
- =Data.Foldable= has the =Foldable= type class
- You can define a Foldable as either, both valid ways
  1) The *foldr* version: A combining function + an initial value.
  2) The *foldMap* version: where you thinking as a Monoid
- Eg: maximum, elem
- Prelude has functions specialized for lists by default. For beginners.
  - "You should aim for the largest degree of abstraction that you can achieve"
- Extensions: =DeriveFunctor= and =DeriveFoldable= are automatic derivation of these type classes.
***** Exercise 4-9 Foldable Fun!
- Write Foldable for Maybe and Binary Trees. See 4-9 restrictions.
  #+begin_src haskell
    instance Foldable Maybe a where
      foldr f i Nothing   = i
      foldr f i (Maybe a) = f i a
    instance Foldable BinaryTree2 a where
      foldr _ i Leaf2 = i
      foldr f i (Node2 v l r) = f leftValue rightValue
        where newValue   = f i v
              leftValue  = foldr f newValue l
              rightValue = foldr f newValue r
  #+end_src
** 5 Laziness and Infinite Structures
*** An infinite Number of Time Machines
- Each TimeMachine has a year that is ONLY allowed to travel
  #+begin_src haskell
    data TimeMachine = TM { manufacturer :: String, year :: Integer }
                     deriving (Eq, Show)
  #+end_src
- Haskell *infinite list ranges*, means all elements "larger than", NOT infinite
  > zip allNumbers "abcd"
  > zip [1 .. ] "abcd"
  [(1,'a'),(2,'b'),(3,'c'),(4,'d')]
  > [False ..]
  [False, True]
- Some operations might enter into an infinite computation and will never return.
**** Example: A function to return all the time machines from a year *n* on.
#+begin_src haskell
  timeMachinesFrom :: String -> Integer -> [TimeMachine]
  timeMachinesFrom mf y = TM mf y : timeMachinesFrom mf (y+1)

  timelyIncMachines :: [TimeMachine]
  timelyIncMachines = timeMachinesFrom "Timely Inc." 100
  #+end_src
**** Example: All integer numbers
#+begin_src haskell
  allNumbers :: [Integer]
  allNumbers = allNumbersFrom 1
  allNumbersFrom :: Integer -> [Integer]
  allNumbersFrom n = n : allNumbersFrom (n+1)
  #+end_src
**** Example: Infinite Fibonacci numbers, using infinite lists
#+begin_src haskell
  fibonacci :: [Integer]
  fibonacci = 0 : 1 : zipWith (+) fibonacci (tail fibonacci)
  -- > import Data.List
  -- > fibonacci !! 20
  -- 6765
#+end_src
**** Example: Infinite TimeMachine, =repeat=
#+begin_src haskell
  infinite2020Machines :: [TimeMachine]
  infinite2020Machines = TM "Timely Inc." 2020 : infinite2020Machines
  infinite2020Machines = repeat $ TM "Timely Inc." 2020 -- or using repeat
#+end_src
**** Example: Infinite TimeMachine list of a certain order, =cycle=
#+begin_src haskell
  specialOffer :: [TimeMachine]
  specialOffer = cycle [TM m 2005, TM m 1994, TM m 908]
    where m = "Timely Inc."
#+end_src
**** Example: Infinite Fibonacci tuples, =iterate=
- itarate, applies the functions to a value to obtain the 2nd value, applies again to obtain the 3rd...
  iterate f x = [x, f x, f (f x), f (f (f x)), ...]
  #+begin_src haskell
    fibonacci2 :: [Integer]
    fibonacci2 = map fst $ iterate (\(n,n1) -> (n1,n+n1)) (0,1)
  #+end_src
**** Exercise 5-1 The sieve of Eratosthenes
#+begin_src haskell
  primes :: [Integer]
  primes = primes' [2..]

  primes' :: [Integer] -> [Integer]
  primes' (x:xs) = x : (primes' $ filter (`isPrime` x) xs)

  isPrime :: Integer -> Integer -> Bool
  isPrime a b | a `rem` b == 0 = False
              | otherwise      = True
#+end_src
- Algorithm for getting the list of all the primes
  1) Start with a list of all the numbers from 2 on
  2) take the first number, drop the the list all his multiples
  3) take the next number, drop all the multiples
  4) repeat previous step with the first number left in the previous one
*** Lazy Evaluation Model
**** Understainding Evaluation in Haskell
- Most programming languages follow a *strict evaluation model*
  1) whenever a compound expression if found it's _immediately_ transformed into a simpler version
  2) arguments to a function are evaluated _before_ the control flow enters the body of the function
- *non-strict or lazy evaluation*
  - Haskell tries to evaluate the expressions as late as possible.
  - Haskell evaluates an expression only _until_ a constructor is found
  - =Thunk= is the unevaluated code's placeholder
  - This also means that these thunks can be reused in the evaluation of other parts of the program
    - This does NOT mean a memoization of values happens, only expressions
    - Side effects make it impossible to apply sharing optimizations
**** Problems with Laziness
**** Pattern Matching and Laziness
**** Profiling with GHC
*** Strictness annotations
