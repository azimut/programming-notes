- https://www.simplehaskell.org/
- https://github.com/Gabriella439/post-rfc/blob/main/sotu.md
- https://lokathor.gitbooks.io/using-haskell/content/opengl/
- https://evanrelf.com/haskell-libraries-i-love
- Styleguide
  https://github.com/tibbe/haskell-style-guide/blob/master/haskell-style.md
  https://kowainik.github.io/posts/naming-conventions
- Mailing List https://mail.haskell.org/mailman/listinfo/haskell-cafe
- https://www.schoolofhaskell.com/school/advanced-haskell/beautiful-concurrency/3-software-transactional-memory
- https://github.com/prathyvsh/category-theory-resources
- https://work.njae.me.uk/2021/12/21/advent-of-code-2021-day-19/
- http://sordina.github.io/blog/2021/01/03/1609638326-advent19b.html
- Usage Examples of Haskell https://homepages.inf.ed.ac.uk/wadler/realworld/
- Memory Usage https://stackoverflow.com/questions/459725/how-to-reduce-memory-usage-in-a-haskell-app
- FPGA Clash Talks https://unsafeperform.io/talks/
- https://crypto.stanford.edu/~blynn/haskell/
- http://www.cis.syr.edu/~sueo/cis252/emacs.html
- https://hoogle.haskell.org/
- https://github.com/graninas/software-design-in-haskell
- https://en.wikipedia.org/wiki/Dependent_type
- https://en.wikipedia.org/wiki/Generalized_algebraic_data_type

* Language

** deriving - types that can be derived
|---------+---------------------------------------|
|         | for types that...                     |
|---------+---------------------------------------|
| Bounded | with finite upper and lower *bounds*  |
| Eq      | can be compared for *equality*        |
| Ord     | have a total *ordering*               |
| Ix      | support indexing into a range         |
| Read    | can be parsed from strings            |
| Show    | can be converted into strings         |
| Enum    | can be converted to and from integers |
|---------+---------------------------------------|
** pragmas
|----------+----------------------------------------------------------------------------------------------------|
| LANGUAGE | to enable language extensions                                                                      |
| MINIMAL  | to define the minimal functions that should be defined on a *class*, comma separated, supports (¦) |
|----------+----------------------------------------------------------------------------------------------------|
** module
|--------------------------------------+---------------------------------------------|
| module ModuleName where              | exports all                                 |
|--------------------------------------+---------------------------------------------|
| module ModuleName (                  | exports foo                                 |
| foo                                  |                                             |
| TypeFoo(TypeFooConst, fieldSelector) |                                             |
| ) where                              |                                             |
|--------------------------------------+---------------------------------------------|
| module ModuleName (                  | exports all constructors and fieldselectors |
| TypeFoo(..)                          | of TypeFoo                                  |
| ) where                              |                                             |
|--------------------------------------+---------------------------------------------|
| module ModFoo                        | re-exporting ModBar,                        |
| ( module Baz                         | using the local alias "Baz"                 |
| )                                    | could have used the full name instead       |
| where                                |                                             |
| import Other.ModBar as Baz           |                                             |
|--------------------------------------+---------------------------------------------|
** imports
https://wiki.haskell.org/Import
|------------+----------------------------------------+-----------------------------------|
| import ALL | import Data.List                       | brings everything in              |
| import     | import Data.List (intercalate)         | brings ONLY specific things       |
| as         | import Data.ByteString as BS           | brings everything in AND into BS. |
| as         | import qualified Data.ByteString as BS | brings into BS.                   |
| hiding     | import Prelude hiding (foldl, foldr)   | import all except ...             |
|------------+----------------------------------------+-----------------------------------|
** operators
|------+---------------------------+--------------------+--------------+-------------------|
| ($)  | function application      | map ($ 10) [(+ 1)] |              |                   |
| (.)  | function composition      | printLn . show     |              |                   |
| (++) | append lists              | [1,2] ++ [3,4]     |              | [a] -> [a] -> [a] |
| (<>) | append strings (mappend)  | "foo" <> "bar"     |              | m   -> m   -> m   |
| (!!) | list indexing             | [1,2] !! 0         |              |                   |
| (:)  | list consing, preppending | 1 : [2, 3]         | [1,2,3] : [] |                   |
|------+---------------------------+--------------------+--------------+-------------------|

#+begin_src haskell
  class Semigroup a where
    (<>) :: a -> a -- sufficient for a "minimal complete definition"
#+end_src

|     |                       <r> |               |                          |
|-----+---------------------------+---------------+--------------------------|
| <$> |                      fmap | Functor f     | (a -> b) -> f a -> f b   |
|-----+---------------------------+---------------+--------------------------|
| >>= |                      bind | Monad m       | m a -> (a -> m b) -> m b |
| >>  |                      then | Monad m       | m a ->       m b  -> m b |
|-----+---------------------------+---------------+--------------------------|
| <¦> |       Control.Alternative | Alternative f | f a -> f a -> f a        |
|-----+---------------------------+---------------+--------------------------|
| <*> |                     apply | Applicative f | f (a -> b) -> f a -> f b |
| *>  |  left "facing bird"/shark | Applicative f | f a        -> f b -> f b |
| <*  | right "facing bird"/shark | Applicative f | f a        -> f b -> f a |
|-----+---------------------------+---------------+--------------------------|
** types primitives
|---------+-------+--------------------------------------|
| Bool    |  True | boolean                              |
| Integer |     2 | signed integer, unbounded            |
| Int     |     2 | signed integer, 32/64 bit            |
| Word    |     2 | unsigned integer, 32/64 bit          |
| Float   |   1.2 | IEEE single-precision floating-point |
| Double  |   1.2 | IEEE double-precision floating-point |
| Char    |   'A' | an unicode code point                |
| String  | "foo" | list characters                      |
|---------+-------+--------------------------------------|
** types complex
| instancing    | possible definition        | name              | description                            |
|---------------+----------------------------+-------------------+----------------------------------------|
| [1,2]         | [Int]                      | linked list       |                                        |
| "foo"         | type A = String            | type alias        |                                        |
|---------------+----------------------------+-------------------+----------------------------------------|
| A "foo"       | newtype A = A String       | type "safe" alias | can have only 1 type                   |
|               |                            |                   | no alternatives                        |
|---------------+----------------------------+-------------------+----------------------------------------|
| C "foo"       | data A a                   | data              | can have >1 type per construct         |
|               | = C String Int             |                   |                                        |
|               | ¦ D a                      |                   | can have alternatives with ¦           |
|---------------+----------------------------+-------------------+----------------------------------------|
| C {foo = 1}   | data A = C { foo :: Int }  | data records      | automatically creates getters          |
|               |                            |                   | avoid clashes by prefixing field names |
|               |                            |                   | syntax to update a field               |
|               |                            |                   | x1 {foo = 2}                           |
|---------------+----------------------------+-------------------+----------------------------------------|
| Tuple 2 "foo" | data Tuple a b = Tuple a b | data tuple        | we are able to plug differen types     |
| (2, "foo")    |                            |                   | polymorphic definition                 |
|---------------+----------------------------+-------------------+----------------------------------------|
| Left "Hello"  | data Either a b            |                   | useful for modeling errors             |
| Right 17      | = Left a                   |                   | Right = we got what we wanted          |
|               | ¦ Right b                  |                   | Left  = we got an error                |
|---------------+----------------------------+-------------------+----------------------------------------|
#+TBLFM: $2=Left a
** language extensions

https://ghc.gitlab.haskell.org/ghc/doc/users_guide/exts.html
https://github.com/i-am-tom/haskell-exercises

- NOTE: some extensions are better enabled globally or prohibited altogether
  enabling some extensions on a module-by-module basis
  can end up causing maintenance burden on the application long term
  since applciations that use it ned to be careful.
- in cabal: by adding it to *default-extensions* enables it across the target
- in repl: *:set -XTypeApplications* or :seti to enable it only for interactive code
- in source: using a ~language pragma~
   *{-# LANGUAGE TypeApplications, QuasiQuotes #-}*
|----------------------------+-------------------------------------------------------------------------------------------------------+-----|
|                            |                                                                                                       | 21  |
|----------------------------+-------------------------------------------------------------------------------------------------------+-----|
| RecordWildCards            | RecName {..} automatically captures each field by the name, OR creates a new record                   | -   |
| NamedFieldPuns             | Rec1Name { fieldname1 = Rec2Name { fieldname2 } }                                                     | -   |
|----------------------------+-------------------------------------------------------------------------------------------------------+-----|
| BlockArguments             | use just (do) in places where you would use ($ do)                                                    |     |
| LambdaCase                 | (\case PAT1 -> RET1)                                                                                  |     |
| PatternSynonyms            |                                                                                                       |     |
| QuasiQuotes                | alternate form of string literal                                                                      |     |
| TemplateHaskell            |                                                                                                       |     |
| ViewPatterns               | (f -> PATTERN) applies "f" to value and then matches the result, on function pattern matching         |     |
|----------------------------+-------------------------------------------------------------------------------------------------------+-----|
| AllowAmbiguousTypes        |                                                                                                       | -   |
| BangPatterns               | makes pattern matching and let bindings strict, instead of lazy, by adding a (!) before the varname   | yes |
| ConstraintKinds            |                                                                                                       | yes |
| DataKinds                  |                                                                                                       | -   |
| DefaultSignatures          | allow us to add a *type signature* to the default implementation of function in a type class          | -   |
| DeriveAnyClass             | to use any typeclass (with no methods), to be used on a "derive", it will create the no-body instance | -   |
| DerivingStrategies         | helps resolve conflicts when different derivings extension are enabled stock/anyclass/newtype         | -   |
| DerivingVia                | to use newtype's as a template for how to define a typeclass for other types                          | -   |
| ExistentialQuantification  |                                                                                                       | yes |
| ExplicitForAll             | allows us to make explicit use of *forall*                                                            | yes |
| FlexibleContexts           |                                                                                                       | yes |
| FlexibleInstances          |                                                                                                       | yes |
| FunctionalDependencies     |                                                                                                       | -   |
| GADTs                      |                                                                                                       | -   |
| GeneralizedNewtypeDeriving | to derive typeclass instance based on the underlying type                                             | yes |
| KindSignatures             | allows us to write the kind signatures for types in our type annotations                              | yes |
| MultiParamTypeClasses      |                                                                                                       | yes |
| OverloadedStrings          |                                                                                                       | -   |
| PolyKinds                  |                                                                                                       | yes |
| QuantifiedConstraints      |                                                                                                       | -   |
| RankNTypes                 |                                                                                                       | yes |
| ScopedTypeVariables        | allows type applications to refer to type variables rather that ONLY the concrete type                | yes |
| TupleSections              |                                                                                                       | yes |
| TypeApplications           | (@TYPE) to specify a type argument for polymorphic functions                                          | yes |
| TypeFamilies               |                                                                                                       | -   |
| TypeOperators              |                                                                                                       | yes |
| UndecidableInstances       |                                                                                                       | -   |
| NoStarIsType               |                                                                                                       | -   |
| PolyKinds                  |                                                                                                       | yes |
| StandadaloneDeriving       | allows us to write stand-alone "deriving" declarations, useful for GHCI                               | yes |
| ApplicativeDo              | allows us to use "do notation" for non Monads and use it for Applicative                              | ?   |
| NoImplicitPrelude          | signals we would not be making use of the standard ~Prelude~ module from the ~base~ package           |     |
|----------------------------+-------------------------------------------------------------------------------------------------------+-----|
- "21?" column stands for GHC2021 and means,
  if the extension is enabled by default on that version of Haskell (aka GHC 9.4)
** Standard Library
- https://packages.ubuntu.com/bionic/amd64/ghc/filelist
*** Prelude.hs functions
https://www.cse.chalmers.se/edu/year/2018/course/TDA452_Functional_Programming/tourofprelude.html#init
| fn         | returns     | description                                                      |
|------------+-------------+------------------------------------------------------------------|
| all        | Bool        |                                                                  |
| any        | Bool        |                                                                  |
| concatMap  | [a]         | map + concat                                                     |
| dropWhile  | [a]         | drops from head while fn is True                                 |
| filter     | [a]         |                                                                  |
| uncurry    | (a,b) -> c  | takes a fn that takes 2 args, and returns a fn that takes a pair |
| curry      | a -> b -> c | takes a fn that takes a pair, and returns a fn that takes 2 args |
| flip       | b -> a -> c | returns the same function with argumnts flipped                  |
| foldl      | a           | folds left                                                       |
| foldl1     | a           | folds left over NON EMPTY lists                                  |
| foldr      | a           | folds right                                                      |
| foldr1     | a           | folds right over NON EMPTY lists                                 |
| iterate    | [a]         | returns the infinity list of applying [fn x, fn (fn x),...]      |
| map        | [b]         |                                                                  |
| span       | ([a],[a])   | split list into 2 tuple, pivot when fn returns False             |
| break      | ([a],[a])   | split list into 2 tuple, pivot when fn returns True              |
| takeWhile  | [a]         | returns elems from head, while fn returns True                   |
| until      | [a]         | returns elems from head, until fn returns False                  |
| zipWith    | [c]         | applies a binary function and two list                           |
|------------+-------------+------------------------------------------------------------------|
| repeat     | [a]         | repeats an infinite list of the value provided                   |
| replicate  | [a]         | repeats N list of the value provided                             |
|------------+-------------+------------------------------------------------------------------|
| concat     | [a]         | flattens a list of lists                                         |
| head       | a           | first element on a NON EMPTY list                                |
| tail       | [a]         | aka cdr                                                          |
| last       | a           | last element on a NON EMPTY list                                 |
| init       | [a]         | aka butlast                                                      |
| sort       | [a]         | sorts in ascending order                                         |
| reverse    | [a]         | reverse a list                                                   |
| maximum    | a           | returns max element on a NON EMPTY list                          |
| minimum    | a           | returns min element on a NON EMPTY list                          |
| length     | int         |                                                                  |
| null       | Bool        | true if empty list                                               |
| and        | Bool        | applied to a list of booleans                                    |
| or         | Bool        | applied to a list of booleans                                    |
| product    | int         | aka reduce #'*                                                   |
| sum        | int         | aka reduce #'+                                                   |
|------------+-------------+------------------------------------------------------------------|
| ++         | [a]         | append 2 lists                                                   |
| zip        | [(a,b)]     | applied to 2 lists, returns a list of pairs                      |
|------------+-------------+------------------------------------------------------------------|
| elem       | Bool        | aka exists? on list                                              |
| notElem    | Bool        | aka NOT exists? on list                                          |
| !!         | a           | indexing a list                                                  |
| splitAt    | ([a],[a])   | splits at index                                                  |
| take       | a           | aka subseq 0 N                                                   |
| drop       | [a]         | aka nthcdr                                                       |
|------------+-------------+------------------------------------------------------------------|
| lines      | [String]    | split String by new line                                         |
| unlines    | String      | list of strings into string                                      |
| words      | [String]    |                                                                  |
| unwords    | String      |                                                                  |
| digitToInt | Int         | char to int                                                      |
| chr        | Char        | takes an integer                                                 |
| ord        | Int         | ascii code for char                                              |
| toLower    | Char        |                                                                  |
| toUpper    | Char        |                                                                  |
| compare    | Ordering    |                                                                  |
| error      | a           | takes a string and errors                                        |
| max        | a           | max between 2 elements                                           |
| succ       | a           | next value on an Enum, error if last                             |
| pred       | a           | previous value on an Enum, error if first                        |
|------------+-------------+------------------------------------------------------------------|
| fst        | a           | first element on a two element tuple                             |
| snd        | b           | second element on a two element tuple                            |
|------------+-------------+------------------------------------------------------------------|
| maybe      | b           | applied fn to Maybe value, or the default value provided         |
|------------+-------------+------------------------------------------------------------------|
| print      | IO ()       | prints showable                                                  |
| putStr     | IO ()       | prints string                                                    |
| show       | String      |                                                                  |
|------------+-------------+------------------------------------------------------------------|
| isSpace    | Bool        |                                                                  |
| isAlpha    | Bool        | if char is alphabetic                                            |
| isDigit    | Bool        | if char is a number                                              |
| isLower    | Bool        |                                                                  |
| isUpper    | Bool        |                                                                  |
|------------+-------------+------------------------------------------------------------------|
| ceiling    |             | smallest integer, not less than argument                         |
| floor      |             | greatest integer, not greater than argument                      |
| round      |             | nearest integer                                                  |
| truncate   |             | drops the fractional part                                        |
|------------+-------------+------------------------------------------------------------------|
| mod        |             |                                                                  |
| quot       |             |                                                                  |
| rem        |             |                                                                  |
|------------+-------------+------------------------------------------------------------------|
| **         | Floating    | raises, arguments must be Floating                               |
| ^          | Num         | raises, Num by Integral                                          |
| ^^         | Fractional  | raises, Fractional by Integral                                   |
|------------+-------------+------------------------------------------------------------------|
*** base
- https://hackage.haskell.org/package/base
- https://hackage.haskell.org/package/base-4.14.0.0/docs/Prelude.html#g:5
|-------------------------+------------------------------------------------------------|
| Control.Applicative     |                                                            |
| Control.Arrow           |                                                            |
| Control.Category        |                                                            |
| Control.Concurrent      |                                                            |
| Control.Exception.Safe  | tryAny :: IO a -> IO (Either SomeException a)              |
| Control.Monad           | sequence :: (Traversable t, Monad m) => t (m a) -> m (t a) |
|                         | sequence_ :: (Foldable t, Monad m) => t (m a) -> m ()      |
| Data.Bifoldable         |                                                            |
| Data.Bifoldable1        |                                                            |
| Data.Bifunctor          |                                                            |
| Data.Bitraversable      |                                                            |
| Data.Bits               |                                                            |
| Data.Bool               |                                                            |
| Data.Char               | isPrint                                                    |
| Data.Coerce             |                                                            |
| Data.Complex            |                                                            |
| Data.Data               |                                                            |
| Data.Dynamic            |                                                            |
| Data.Either             |                                                            |
| Data.Eq                 |                                                            |
| Data.Fixed              |                                                            |
| Data.Foldable           |                                                            |
| Data.Foldable1          |                                                            |
| Data.Function           |                                                            |
| Data.Functor            |                                                            |
| Data.IORef              |                                                            |
| Data.Int                |                                                            |
| Data.Ix                 |                                                            |
| Data.Kind               |                                                            |
| Data.List               | permutations                                               |
| Data.Maybe              |                                                            |
| Data.Monoid             |                                                            |
| Data.Ord                |                                                            |
| Data.Proxy              |                                                            |
| Data.Ratio              |                                                            |
| Data.STRef              |                                                            |
| Data.Semigroup          |                                                            |
| Data.String             |                                                            |
| Data.Traversable        |                                                            |
| Data.Tuple              |                                                            |
| Data.Typeable           |                                                            |
| Data.Unique             |                                                            |
| Data.Version            |                                                            |
| Data.Void               |                                                            |
| Data.Word               |                                                            |
| Foreign.*               |                                                            |
| System.CPUTime          |                                                            |
| System.Console          |                                                            |
| System.Environment      | getArgs :: IO [String]                                     |
| System.Exit             |                                                            |
| System.IO               | openFile :: FilePath -> IOMode -> IO Handle                |
|                         | hClose :: Handle -> IO ()                                  |
|                         | hGetContents :: Handle -> IO String                        |
|                         | hputStrLn :: Handle -> IO ()                               |
|                         | putStrLn :: String -> IO ()                                |
|                         | stdout :: Handle                                           |
| System.Info             |                                                            |
| System.Mem              |                                                            |
| System.Posix            |                                                            |
| System.Timeout          |                                                            |
| Text.ParserCombinators  |                                                            |
| Text.(Read/Printf/Show) |                                                            |
|-------------------------+------------------------------------------------------------|
*** non base
|------------------+-----------------------------------+------------------------------------------------------|
| array            | Data.Array                        | https://hackage.haskell.org/package/array            |
| containers       | Data.Graph                        | https://hackage.haskell.org/package/containers       |
|                  | Data.IntMap                       | https://haskell-containers.readthedocs.io/en/latest/ |
|                  | Data.IntSet                       |                                                      |
|                  | Data.Map                          |                                                      |
|                  | Data.Sequence                     |                                                      |
|                  | Data.Set                          |                                                      |
|                  | Data.Tree                         |                                                      |
| binary           | Data.Binary                       | https://hackage.haskell.org/package/binary           |
| bytestring       | Data.ByteString                   | https://hackage.haskell.org/package/bytestring       |
| deepseq          | Control.DeepSeq                   | https://hackage.haskell.org/package/deepseq          |
| directory        | System.Directory                  | https://hackage.haskell.org/package/directory        |
| exceptions       | Control.Monad.Catch               |                                                      |
| filepath         | System.(FilePath/OsPath/OsString) | https://hackage.haskell.org/package/filepath         |
| haskeline        | System.Console                    | https://hackage.haskell.org/package/haskeline        |
| *hoopl           | Compiler.Hoopl                    | https://hackage.haskell.org/package/hoopl            |
| hpc              | Trace.Hpc                         | https://hackage.haskell.org/package/hpc              |
| integer-gmp      | GHC.Integer.GMP                   |                                                      |
| libiserv         |                                   |                                                      |
| mtl              | Control.Monad.Accum               |                                                      |
|                  | Control.Monad.Cont                |                                                      |
|                  | Control.Monad.Except              |                                                      |
|                  | Control.Monad.Identity            |                                                      |
|                  | Control.Monad.RWS                 |                                                      |
|                  | Control.Monad.Reader              |                                                      |
|                  | Control.Monad.Select              |                                                      |
|                  | Control.Monad.State               |                                                      |
|                  | Control.Monad.Trans               |                                                      |
|                  | Control.Monad.Writer              |                                                      |
| parsec           | Text.Parsec                       |                                                      |
|                  | Text.ParserCombinators.Parsec     |                                                      |
| pretty           | Text.PrettyPrint                  | https://hackage.haskell.org/package/pretty           |
| process          | System.Cmd                        | https://hackage.haskell.org/package/process          |
|                  | System.Process                    |                                                      |
| terminfo         | System.Console.Terminfo           | https://hackage.haskell.org/package/terminfo         |
| template-haskell | Language.Haskell.TH               | https://hackage.haskell.org/package/template-haskell |
| text             | Data.Text, more efficient unicode |                                                      |
|                  | Text                              | type                                                 |
|                  | pack                              | from String to Text                                  |
| time             | Data.Time                         | https://hackage.haskell.org/package/time             |
| transformers     | Control.Monad.Trans               | https://hackage.haskell.org/package/transformers     |
| stm              | Control.Concurrent.STM            |                                                      |
|                  | Control.Monad.STM                 |                                                      |
| unix             | System.Posix                      | https://hackage.haskell.org/package/unix             |
| xhtml            | Text.XHtml                        | https://hackage.haskell.org/package/xhtml            |
|------------------+-----------------------------------+------------------------------------------------------|

* Emacs Setup
  - https://github.com/haskell/haskell-ide-engine
  - https://github.com/soupi/minimal-haskell-emacs (setup)
  - https://github.com/ndmitchell/ghcid "flymake"
  - https://github.com/ndmitchell/hlint "flycheck"
  - https://github.com/chrisdone/hindent "gofmt"

* Codebases

- https://github.com/omelkonian/AlgoRhythm (music)
- Project
  https://github.com/reanimate/reanimate
  https://github.com/xmonad/xmonad
- exercises https://github.com/effectfully-ou/haskell-challenges
- https://github.com/jappeace/cut-the-crap/
  ffmpeg based, cut video silences
- A Haskell library that simplifies access to remote data, such as databases or web-based services.
  - source https://github.com/facebook/Haxl
  - they created ApplicativeDo extension
- 2012 game https://github.com/nikki-and-the-robots/nikki
- dead game studio https://github.com/keera-studios

* Snippets

** Hello World

#+CMD: $ runhaskell hello-world.hs
#+begin_src haskell
  module Main (main) where
  import qualified System.IO as IO
  main = IO.putSTrLn "hello world!"
#+end_src

* Personalities
- Simon Peyton-Jones
- Philip Wadler
