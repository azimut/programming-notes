#+TITLE: OCaml's reference
#+DATE: <2020-11-24 mar>

|-------------+------------------------------------------------------------------|
| wiki        | https://en.wikipedia.org/wiki/OCaml                              |
| manual      | https://ocaml.org/manual/index.html                              |
| manual (04) | https://caml.inria.fr/pub/old_caml_site/ocaml/htmlman/index.html |
|-------------+------------------------------------------------------------------|

- 1996-
- Authors:
  - Xavier Leroy, Jerome Voiullon, Damien Doligez, Didier Remy, Ascander Suarez

* Language
- there are mutable values, but NOT mutable variables
- .ml  = Data Structure
- .mli = Data Abstraction
** Types
*** record

#+begin_src
  type [type param] <record-name> =
    { <field> : <type>;
      <field> : <type>;
      ...
    }
#+end_src

*** variant (sum type)

#+begin_src
type <variant> =
  | <TagOrConstructor> [of <type> [* <type>]...]
  | <TagOrConstructor> [of <type> [* <type>]...]
  | ...
#+end_src

- We can also *use the type* name when matching for variant types, in this case "color" is the type name
  #+begin_src ocaml
    let extended_color_to_int : extended_color -> int = function
      | `RGBA (r,g,b,a) -> 256 + a + (b * 6) + (g * 36) + (r * 216)
      | #color as color -> color_to_int color
  #+end_src

*** simple
- Int
- Float
- String
*** complex
|------------+------------------------+---------+-----------+---------------------------------+--------+----------------|
| Type       | Init                   | Access  | Modifying | Pattern Matching                | Adding | Appending      |
|------------+------------------------+---------+-----------+---------------------------------+--------+----------------|
| ~Unit~     | ()                     |         |           |                                 |        |                |
| ~Bool~     | x = true,false         |         |           |                                 | &&,¦¦  |                |
| ~Option~   | Some a, None           |         |           |                                 |        |                |
| ~String~   | "abcd"                 | .[2]    | <-        |                                 |        | ^              |
| variant    |                        |         |           |                                 |        |                |
| mutable    |                        |         | <-        |                                 |        |                |
| refs       | ref <expr>             | !x      | :=        |                                 |        |                |
|------------+------------------------+---------+-----------+---------------------------------+--------+----------------|
| ~Array~    | [¦ a ; b ¦]            | .(2)    | <-        | let [¦ a ; b ¦] = some_array    |        |                |
| ~Bigarray~ |                        | .{2}    | <-        |                                 |        |                |
| tuples     | (a , b)                | fst snd |           | let (x , y)  =                  |        |                |
| ~List~     | [a ; a]                | List.hd |           | let (x :: y) =                  | ::     | @, List.append |
| struct     | struct let foo = 3 end |         |           |                                 |        |                |
|------------+------------------------+---------+-----------+---------------------------------+--------+----------------|
| record     | {a = VAL ; b = VAL}    | .a      |           | let { x = x_pos ; y = y_pos } = |        |                |
|            | a=VAL; B=VAL; {a ; b}  |         |           | let { x ; y } =                 |        |                |
|            | type foo = { a: int }  |         |           | let v1 = v1.x + v2.y            |        |                |
|------------+------------------------+---------+-----------+---------------------------------+--------+----------------|
** Modules
- capitalized
- can be ~open~ locally
|----------------------------+--------------------------------|
|                            | code                           |
|----------------------------+--------------------------------|
| new                        | module M = struct              |
|                            | ..let x = 3                    |
|                            | end                            |
|----------------------------+--------------------------------|
| type                       | module type MT = sig           |
|                            | ..type t                       |
|                            | ..val is_empty : t -> bool     |
|                            | end                            |
|----------------------------+--------------------------------|
| type+new                   | module M : sig                 |
|                            | ..type t                       |
|                            | end = struct                   |
|                            | ..type t = string              |
|                            | end                            |
|----------------------------+--------------------------------|
|                            | module newM : MT = M           |
|----------------------------+--------------------------------|
| new functor                | module fM (M:MT) : MT = struct |
|                            | ..let x = M.x + 1              |
|                            | ..let f i = M.g i              |
|                            | end                            |
|----------------------------+--------------------------------|
| instance/use functor       | module newM = functorM(M)      |
|----------------------------+--------------------------------|
| instance functor           | module newM =                  |
| +                          | ..functorM(struct              |
| anonymous module           | ..type t = int                 |
|                            | ..let compare = Int.compare    |
|                            | end)                           |
|----------------------------+--------------------------------|
| include                    | module newM = struct           |
|                            | ..include M                    |
|                            | ..let f x = x                  |
|                            | end                            |
|----------------------------+--------------------------------|
| include with type          | module newM = sig              |
| (multiple)                 | ..type t                       |
|                            | ..include M1 with type t := t  |
|                            | ..include M2 with type t := t  |
|                            | end                            |
|----------------------------+--------------------------------|
| new module with type       | module type MT =               |
| "sharing constraint"       | ..MT with type T1 = T2         |
|----------------------------+--------------------------------|
| new functor with type      | module fM(M:MT1)               |
| "sharing constraint"       | ..: (MT2 with type T1 = M.t)   |
|                            | = struct                       |
|                            | ..type T1 = M.t                |
|                            | end                            |
|----------------------------+--------------------------------|
| new module with type :=    | module type MT =               |
| "destructive substitution" | ..MT with type T1 := T2        |
|----------------------------+--------------------------------|
| new functor with type :=   | module fM(M:MT1)               |
| "destructive substitution" | ..: MT2 with type T1 := T2 =   |
|                            | struct                         |
|                            | end                            |
|----------------------------+--------------------------------|
  #+TBLFM: $2=struct
** Style
- guide https://www.cs.cornell.edu/courses/cs3110/2016fa/handouts/style.html
- Modules
- variables, functions, recordtypes
** Functions

#+begin_src ocaml
  let plusone = (fun x -> x + 1) ;;
  let plusone x = x + 1 ;;
#+end_src

- _exn denotes functions that return an exception
- =assert false= can be used on a branch that isn't suppose to happen
- optional type annotation
- type variables support for parametric polymorphism
- implicit =match= of an invisible last argument when using =function=
- lexically scoped (with let)
- optional arguments
  - begin with ?
    - ?sep ?(sep="")
    - ~sep:":"
  - passed as =Option=
  - useful when is a wrapper to another function that takes an optional
- labeled arguments (ME: aka keyword args)
  - at any position of arguments
  - defining: ~num
  - passing arguments
    - ~num:3
    - ~num   - with label punning if a variable with the same name exists
    - ~f:String:Length
  - when is unclear just from the type signature
    - booleans
    - more than one value of the same type
** Operators
- default polymorphic operators considered problematic
|-----+---------------------------------------------------|
| ^   | concatenate strings                               |
| ¦>  | pipeline, left assoc                              |
| ^>  | pipeline, right assoc                             |
| ==  | physical equality                                 |
| !=  | physical inequality                               |
| =   | structural equality (aka contents), or assignment |
| <>  | structural inequality                             |
| >>= | Option.bind                                       |
| >>¦ | Option.map                                        |
| ;   | to sequence imperative code                       |
|-----+---------------------------------------------------|
** Standard Library
- https://v2.ocaml.org/manual/stdlib.html
- example module url https://v2.ocaml.org/api/Seq.html
|----------------+------------------------------------------------------------|
| =Module=       | =Description=                                              |
|----------------+------------------------------------------------------------|
| Arg            | parsing of command line arguments                          |
| Array          | array operations                                           |
| ArrayLabels    | array operations (with labels)                             |
| Atomic         | atomic references                                          |
| Bigarray       | large, multi-dimensional, numerical arrays                 |
| Bool           | boolean values                                             |
| Buffer         | extensible buffers                                         |
| Bytes          | byte sequences                                             |
| BytesLabels    | byte sequences (with labels)                               |
| Callback       | registering OCaml values with the C runtime                |
| Char           | character operations                                       |
| Complex        | complex numbers                                            |
| Condition      | condition variables to synchronize between threads         |
| Domain         | Domain spawn/join and domain local variables               |
| Digest         | MD5 message digest                                         |
| Effect         | deep and shallow effect handlers                           |
| Either         | either values                                              |
| Ephemeron      | Ephemerons and weak hash table                             |
| Filename       | operations on file names                                   |
| Float          | floating-point numbers                                     |
| Format         | pretty printing                                            |
| Fun            | function values                                            |
| Gc             | memory management control and statistics; finalized values |
| Hashtbl        | hash tables and hash functions                             |
| In_channel     | input channels                                             |
| Int            | integers                                                   |
| Int32          | 32-bit integers                                            |
| Int64          | 64-bit integers                                            |
| Lazy           | deferred computations                                      |
| Lexing         | the run-time library for lexers generated by ocamllex      |
| List           | list operations                                            |
| ListLabels     | list operations (with labels)                              |
| Map            | association tables over ordered types                      |
| Marshal        | marshaling of data structures                              |
| MoreLabels     | include modules Hashtbl, Map and Set with labels           |
| Mutex          | locks for mutual exclusion                                 |
| Nativeint      | processor-native integers                                  |
| Oo             | object-oriented extension                                  |
| Option         | option values                                              |
| Out_channel    | output channels                                            |
| Parsing        | the run-time library for parsers generated by ocamlyacc    |
| Printexc       | facilities for printing exceptions                         |
| Printf         | formatting printing functions                              |
| Queue          | first-in first-out queues                                  |
| Random         | pseudo-random number generator (PRNG)                      |
| Result         | result values                                              |
| Runtime_events | Runtime event tracing                                      |
| Scanf          | formatted input functions                                  |
| Seq            | functional iterators                                       |
| Set            | sets over ordered types                                    |
| Semaphore      | semaphores, another thread synchronization mechanism       |
| Stack          | last-in first-out stacks                                   |
| StdLabels      | include modules Array, List and String with labels         |
| String         | string operations                                          |
| StringLabels   | string operations (with labels)                            |
| Sys            | system interface                                           |
| Uchar          | Unicode characters                                         |
| Unit           | unit values                                                |
| Weak           | arrays of weak pointers                                    |
|----------------+------------------------------------------------------------|
** Changelog
- https://github.com/ocaml-multicore/awesome-multicore-ocaml
  https://v2.ocaml.org/releases/5.0/manual/parallelism.html
  https://v2.ocaml.org/releases/5.0/manual/effects.html
* Tools

- profiling https://github.com/ocaml-bench/notes/blob/master/profiling_notes.md
- profiler https://github.com/imandra-ai/ocaml-tracy
- Github Action: build docs
  https://github.com/smimram/monadic-synth/blob/master/.github/workflows/build.yml

** Editor
- editor https://tarides.com/blog/2022-12-21-advanced-merlin-features-destruct-and-construct
- https://github.com/ocaml-ppx/ocamlformat/blob/main/doc/editor_setup.mld
- https://github.com/Gopiandcode/gopcaml-mode
  https://www.youtube.com/watch?v=vy6oGSk7A3s
  - needs emacs packages: merlin, ocp-indent, and tuareg
* Codebases
- https://soap.coffee/~lthms/news/CFTSpatialShell.html
