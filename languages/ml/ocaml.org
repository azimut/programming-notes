- https://batsov.com/articles/2022/08/29/ocaml-at-first-glance/
  https://lobste.rs/s/dwt32y/ocaml_at_first_glance
- https://www.cl.cam.ac.uk/teaching/1617/L28/materials.html
- Promises https://cs3110.github.io/textbook/chapters/ds/promises.html?highlight=async
- https://smlfamily.github.io/
- Style guide https://www.cs.cornell.edu/courses/cs3110/2016fa/handouts/style.html
- Github Action: build docs
  https://github.com/smimram/monadic-synth/blob/master/.github/workflows/build.yml
- Manual https://ocaml.org/manual/index.html
- Manual https://caml.inria.fr/pub/old_caml_site/ocaml/htmlman/index.html
- Tutorial:
  https://o1-labs.github.io/ocamlbyexample/
  https://github.com/o1-labs/ocamlbyexample
- Tutorial: https://ocaml.org/learn/tutorials/up_and_running.html
- Tutorial: https://web.archive.org/web/20091214115026/http://www.ocaml-tutorial.org/streams
- Tutorial: http://xahlee.info/ocaml/ocaml_basics.html
- Tutorial: https://lambdafoo.com/posts/2021-10-29-getting-started-with-ocaml.html
- Tutorial: Cheatsheet https://github.com/OCamlPro/ocaml-cheat-sheets
- Tutorial: 2006 - OCaml for the Skeptical https://www2.lib.uchicago.edu/keith/ocaml-class/class-01.html
- Tutorial: 2016 https://github.com/caiorss/Functional-Programming/tree/master/ocaml
- Tutorial: 2019 https://github.com/alhassy/OCamlCheatSheet
- Tutorial: 2019 https://github.com/lindig/ocaml-style
- Course: Dan Ghica's Foundations of Computer Science https://vimeo.com/user8856528/videos
- Course: John Whitington’s Videos https://vimeo.com/user20888710/videos
- Course: 2013 - Washington University https://homes.cs.washington.edu/~djg/teachingMaterials/gpl/lectures/
- Course: Columbia Proffesor http://www.cs.columbia.edu/~sedwards/classes/
- Course: 2021 - Singapore - Introductory Data Structures and Algorithms
  https://ilyasergey.net/YSC2229/index.html
  Example https://github.com/ysc2229/ocaml-graphics-demo
  Code https://github.com/ysc2229/
  Student? https://tanrobby.github.io/teaching/ync_algo_intro/index.html
- Course: 2016 - MOOC - Introduction to Functional Programming in OCaml
  https://www.fun-mooc.fr/en/courses/introduction-functional-programming-ocaml/
  https://archive.org/details/fun_ocaml_mooc
  MKV https://archive.org/compress/fun_ocaml_mooc/formats=MATROSKA&file=/fun_ocaml_mooc.zip
  CODE https://github.com/smeruelo/mooc-ocaml
  SLIDES https://archive.org/download/fun_ocaml_mooc/slidesAndCode.zip
- Excercises
  https://ocaml.org/learn/tutorials/99problems.html
  https://github.com/VictorNicollet/99-Problems-OCaml
  https://github.com/janestreet/learn-ocaml-workshop
* Makefile
  #+begin_src
.PHONY: dev release deps test clean run install

dev:     ; opam exec -- dune build
release: ; opam exec -- dune build --profile release --build-dir _build_release

deps:  ; opam install . --deps-only --with-test
test:  ; opam exec -- dune runtest
clean: ; opam exec -- dune clean ; rm -rf _build_release _build
run:   ; opam exec -- dune exec ./src/main.exe

install: release
	install _build_release/default/src/main.exe $(HOME)/.newsboat/feeds/sql2rss
  #+end_src
* Articles
- Roguelike with effect handlers
  https://hackmd.io/@yF_ntUhmRvKUt15g7m1uGw/Bk-5NXh15
  https://hackmd.io/@yF_ntUhmRvKUt15g7m1uGw/BJBZ7TMeq
- https://tarides.com/blog/2019-05-09-an-introduction-to-ocaml-ppx-ecosystem
- https://discuss.ocaml.org/t/plans-to-choose-an-official-package-project-manager/8620
- https://markkarpov.com/post/haskell-vs-ocaml.html
- 2022 https://linoscope.github.io/writing-a-game-boy-emulator-in-ocaml/
- 2020 Leaving OCAML https://medium.com/darklang/leaving-ocaml-fce7049a2a40
- 2014 https://roscidus.com/blog/blog/2014/06/06/python-to-ocaml-retrospective/
- 2013 https://roscidus.com/blog/blog/2013/06/20/replacing-python-round-2/
** 2018 What I wish I knew when learning OCaml
   https://baturin.org/docs/ocaml-faq/
- you can also produce Javascript from OCaml Bytecode (js_of_ocaml)
*** let ... and
  allows mutually recursive binding
  example: define *even* and *odd* mutually recursive
  #+begin_src ocaml
let rec even x =
  match x with
  | 0 -> true
  | _ -> odd (x - 1)
and odd x =
  match x with
  | 0 -> false
  | _ -> even (x - 1)
  #+end_src
*** abstract types
- reasons
  1) abstract implementation details
  2) prevent invariant violations
* Editor
- https://github.com/ocaml-ppx/ocamlformat/blob/main/doc/editor_setup.mld
- https://github.com/Gopiandcode/gopcaml-mode
  https://www.youtube.com/watch?v=vy6oGSk7A3s
  - needs emacs packages: merlin, ocp-indent, and tuareg
* Book: 2022 - Real World Ocaml
- Book:
  https://dev.realworldocaml.org/toc.html
  https://github.com/realworldocaml/book/
** Types
|-----------+------------------------+--------+-----------+---------------------------------+--------+----------------|
| Type      | Init                   | Access | Modifying | Pattern Matching                | Adding | Appending      |
|-----------+------------------------+--------+-----------+---------------------------------+--------+----------------|
| Unit      | ()                     |        |           |                                 |        |                |
| bool      | x = true,false         |        |           |                                 | &&,¦¦  |                |
| Tuples    | (a , b)                |        |           | let (x , y) =                   |        |                |
| List      | [a ; a]                | L.hd   |           | let (x :: y) =                  | ::     | @, List.append |
| Option    | Some a                 |        |           |                                 |        |                |
| String    | "abcd"                 | .[2]   | <-        |                                 |        | ^              |
| Record    | {a = VAL ; b = VAL}    | .a     |           | let { x = x_pos ; y = y_pos } = |        |                |
|           | a=VAL; B=VAL; {a ; b}  |        |           | let { x ; y } =                 |        |                |
|           |                        |        |           | let v1 = v1.x + v2.y            |        |                |
| Variant   |                        |        |           |                                 |        |                |
| Array     | [¦ a ; b ¦]            | .(2)   | <-        |                                 |        |                |
| Big Array |                        | .{2}   | <-        |                                 |        |                |
| Mutable   |                        |        | <-        |                                 |        |                |
| Refs      | ref <expr>             | !x     | :=        |                                 |        |                |
| struct    | struct let foo = 3 end |        |           |                                 |        |                |
|-----------+------------------------+--------+-----------+---------------------------------+--------+----------------|
- ^ provided by Pervasives module
- Ref shorthands probided by Base
- ¦ used in place of |
** Modules
  |----------------------------+--------------------------------|
  | new                        | module M = struct              |
  |                            | ..let x = 3                    |
  |                            | end                            |
  |----------------------------+--------------------------------|
  | type                       | module type MT = sig           |
  |                            | ..type t                       |
  |                            | ..val is_empty : t -> bool     |
  |                            | end                            |
  |----------------------------+--------------------------------|
  | type+new                   | module M : sig                 |
  |                            | ..type t                       |
  |                            | end = struct                   |
  |                            | ..type t = string              |
  |                            | end                            |
  |----------------------------+--------------------------------|
  |                            | module newM : MT = M           |
  |----------------------------+--------------------------------|
  | new functor                | module fM (M:MT) : MT = struct |
  |                            | ..let x = M.x + 1              |
  |                            | ..let f i = M.g i              |
  |                            | end                            |
  |----------------------------+--------------------------------|
  | instance/use functor       | module newM = functorM(M)      |
  |----------------------------+--------------------------------|
  | instance functor           | module newM =                  |
  | +                          | ..functorM(struct              |
  | anonymous module           | ..type t = int                 |
  |                            | ..let compare = Int.compare    |
  |                            | end)                           |
  |----------------------------+--------------------------------|
  | include                    | module newM = struct           |
  |                            | ..include M                    |
  |                            | ..let f x = x                  |
  |                            | end                            |
  |----------------------------+--------------------------------|
  | include with type          | module newM = sig              |
  | (multiple)                 | ..type t                       |
  |                            | ..include M1 with type t := t  |
  |                            | ..include M2 with type t := t  |
  |                            | end                            |
  |----------------------------+--------------------------------|
  | new module with type       | module type MT =               |
  | "sharing constraint"       | ..MT with type T1 = T2         |
  |----------------------------+--------------------------------|
  | new functor with type      | module fM(M:MT1)               |
  | "sharing constraint"       | ..: (MT2 with type T1 = M.t)   |
  |                            | = struct                       |
  |                            | ..type T1 = M.t                |
  |                            | end                            |
  |----------------------------+--------------------------------|
  | new module with type :=    | module type MT =               |
  | "destructive substitution" | ..MT with type T1 := T2        |
  |----------------------------+--------------------------------|
  | new functor with type :=   | module fM(M:MT1)               |
  | "destructive substitution" | ..: MT2 with type T1 := T2 =   |
  |                            | struct                         |
  |                            | end                            |
  #+TBLFM: $2=struct
** Functions
- List
  (_exn for exception is possible)
- In_channel.fold_lines
  In_channel.stdin
- Core.Sys.is_file_exn
  Core.Sys.ls_dir
  Core.Filename.concat
- Time.now
  Time.diff
  Time.Span.to_ms
- https://ocaml.janestreet.com/ocaml-core/latest/doc/base/Base/List/index.html
  List.append
  List.concat (like flatten)
  List.concat_map (like flatten-map)
  List.dedup_and_sort
  List.filter
  List.filter_map (filter and transform, takes a function that returns Option)
  List.fold
  List.hd_exn
  List.iter
  List.is_empty
  List.map
  List.map2_exn
  List.partition_tf (returns 2 lists, _tf for one list has the true arguments and the other the false ones)
  List.range
  List.reduce (special case of .fold, with no initial value and 'a -> 'a -> 'a function, and Option return)
  List.sort
  List.tl_exn
- List.Assoc.find
  List.Assoc.add
- String.make
  String.concat
  String.length
  String.comparator_witness
** 1 Guided Tour
- Modules are Capitalized
  #+begin_src ocaml
let ratio x y =
  Float.of_int x /. Float.of_int y ;;
  #+end_src
- Modules can be *opened* locally
  #+begin_src ocaml
let ratio x y =
  let open Float.O in
  of_int x / of_int y ;;

let ratio x y =
  Float.O.(of_int x / of_int y) ;;
  #+end_src
- = operator works as both an assigment and a comparison
  #+begin_src ocaml
let even x =
  x % 2 = 0 ;;
  #+end_src
- Optional type annotation
  #+begin_src ocaml
let sum_if_true (test : int -> bool) (x : int) (y : int) : int =
  (if test x then x else 0)
  + (if test y then y else 0) ;;
  #+end_src
- =Type Variables= are used when there is *NO* enough context to identify the type
  *Parametric Polymorphism* (similar to generics in C# or Java)
  #+begin_src ocaml
let first_if_true test x y =
  if test x then x else y
;;
val first_if_true : ('a -> bool) -> 'a -> 'a -> 'a <fun>
  #+end_src
- =Type Errors= (at compile time) vs =Exceptions= (at runtime)
- =Tuples=
  - can have different type
  - * is used for cartesian product, between the sets
- Lists, same type, immutable (?)
- Base vs stdlib
  - Base has **. and **, while stdlib has only **, but as a float
- *Labeled Argument* like Common Lisp keyword arguments
  - Can happen at ANY position, even before mandatory arguments
  ~f:String:Length
- Use Match for Lists
  #+begin_src ocaml
let my_favorite_language languages =
  match languages with
  | hd :: tl -> hd
  | [] -> "Ocaml" ;;
  #+end_src
- *let rec* Recursive functions, have logic divided into a *base case* and *inductive cases*
  #+begin_src ocaml
let rec remove_sequential_duplicates list =
  match list with
  | [] -> []
  | [hd] -> [hd]
  | hd1 :: hd2 :: tl ->
    let new_tl = remove_sequential_duplicates (h2 :: tl) in
    if hd1 = hd2 then new_tl else hd1 :: new_tl
  #+end_src
- *let VAR = VAL in*, defines a =scope= where the binding will live
- *Option* (None/Some), can the thoughts as "specialized" list, that only can have zero or one element
  #+begin_src ocaml
let divide x y =
  if y = 0 then None else Some (x / y);;

let downcase_extension filename =
  match String.rsplit2 filename ~on:'.' with
  | None -> filename
  | Some (base,ext) ->
    base ^ "." ^ String.lowercase ext;;
  #+end_src
- ^ operator to concatenate String
- OCAML default polymorphics operators are know the *problematic*
- ";" semi-colons are necessary when dealing with Imperative code
*** Declaring =Records=
  #+begin_src ocaml
  type point2d = { x : float ; y : float}
  type circle_desc  = { center: point2d; radius: float }
  type rect_desc    = { lower_left: point2d; width: float; height: float }
  type segment_desc = { endpoint1: point2d; endpoint2: point2d }
      #+end_src
*** Declaring =Variant Types=: combine multiple objects, so the type can be EITHER one of them
  #+begin_src ocaml
  type scene_element =
    | Circle  of circle_desc (* Circle is 1 case of 3 of the variant *)
    | Rect    of rect_desc
    | Segment of segment_desc
  let is_inside_scene_element point scene_element =
    let open Float.O in
    match scene_element with
    | Circle { center; radius } ->
      distance center point < radius
    | Rect   { lower_left; width; height } ->
      point.x > lower_left.x && point.x < lower_left.x + width
    && point.y > lower_left.y && point.y < lower_left.y + height
    | Segment _ -> false;;
  #+end_src
*** Declaring =Lambdas=
  #+begin_src ocaml
  let is_inside_scene point scene =
    List.exists scene
      ~f:(fun el -> is_inside_scene_element point el)
  #+end_src
*** Mutable =Record= fields
- Declaring
  #+begin_src ocaml
type running_sum =
  { mutable sum: float;
    mutable sum_sq: float;
    mutable samples: int;
  }
  #+end_src
- Modifying a mutable record field
  #+begin_src ocaml
  (* operators *)
  let mean sum = rsum.sum /. Float.of_int rsum.samples
  let stdev sum =
    Float.sqrt (rsum.sum_sq /. Float.of_int rsum.samples -.
            (rsum.sum /. Float.of_int rsum.samples) **. 2.) ;;
  (* init and update *)
  let create () = { sum = 0. ; sum_sq = 0.; samples = 0 }
  let update rsum x =
    rsum.samples <- rsum.samples + 1;
    rsum.sum     <- rsum.sum     +. x;
    rsum.sum_sq  <- rsum.sum_sq  +. x *. x ;;
  (* Using *)
  let rsum = create () ;;
  List.iter [1.;3.;2.;-7.;4.;5.;] ~f:(fun x -> update rsum x);;
  #+end_src
*** =Refs=
  1) shorthand for a Mutable Record with a single field called *contents*
  2) default way to "simulate" traditional mutable variables
     No the most "Idiomatic" way
     #+begin_src ocaml
     let sum list =
       let sum = ref 0 in
       List.iter list ~f:(fun x -> sum := sum! + x);
       !sum ;;
     #+end_src
*** Defining =Operators=
  #+begin_src ocaml
  type 'a ref = { mutable contents : 'a } ;; (* defines a polymorphic type *)
  let ref x = { contents = x };;
  let (!) r = r.contents;; (* they are defined between parenthesis *)
  let (:=) r x = r.contents <- x;;
  #+end_src
*** Loops
**** for  (for-to-do-done)
#+begin_src ocaml
let permute array =
  let length = Array.length array in
  for i = 0 to length - 2 do
    let j = i + Random.int (length - i) in
    let tmp = array.(i) in
    array(i) <- array.(j);
    array(j) <- tmp
  done
let ar = Array.init 20 ~f:(fun x -> x)
permute ar
ar
#+end_src
**** while (while-do-done)
#+begin_src ocaml
let find_first_negative_entry array =
  let pos = ref 0 in
  while !pos < Array.length array && array.(!pos) >= 0 do
    pos := pos + 1
  done
  if !pos = Array.length array then None else Some !pos
#+end_src
*** Executable with dune
- sum.ml example
   #+begin_src ocaml
open Base
open Stdio

let rec read_and_accumulate accum =
  let line = In_channel.input_line In_channel.stdin in
  match line with
  | None -> accum
  | Some x -> read_and_accumulate (accum +. Float.of_string x)

let () =
  printf "Total: %F\n" (read_and_accumulate 0.)
   #+end_src
- dune
  #+begin_src
(executable
  (name sum)
  (libraries base stdio))
  #+end_src
- compilation: dune build sum.exe
** 2 Variables and Functions
- There are *mutable values* in ocaml, but no *mutable variables*
- =assert=, can be used to complete a *match* branch that is impossible to happen
  #+begin_src ocaml
  let upcase_first_entry line =
    match String.split ~on:',' line with
    | [] -> assert false
    | first :: rest -> String.concat ~sep:"," (String.uppercase first :: rest )
  #+end_src
- The OCaml syntax to define functions, is a syntactic sugar over defining lambdas
  #+begin_src ocaml
  let plusone = (fun x -> x + 1) ;;
  let plusone x = x + 1 ;;
  #+end_src
- The parameter to a function as a variable *VS* a variable bound to the value being passed by the caller
  Are equivalent.
  #+begin_src ocaml
  (fun x -> x + 1) 7 ;;
  let x = 7 in x + 1 ;;
  #+end_src
- Currying and Partial Application
  - there is no additional cost (consing) using a tuple as an argument for afunction, but is not idiomatic
- for/while constructs are only useful when using the imperative features of ocaml
- =match= accepts disjunction of multiple values on a branch separated by "|"
- =let= can define mutually recursive definitions by using *and*, works like CL's labels (?)
- Infix vs Prefix functions, using parens to make infix into prefix
  - You need a space before and after any operator that begins and ends with =*=
  - You need to use parentheses for negation. Negation has lower precedence than function application.
- Pipeline Operators
  #+begin_src ocaml
  let (|>) x f = f x (* left  asocciative *)
  let (^>) x f = f x (* right asocciative *)
  #+end_src
- Declaring a function with =function=, has implicit match
  #+begin_src ocaml
  let some_or_zero = function
    | Some x -> x
    | None -> 0
  (* same as *)
  let some_or_zero num_opt =
    match num_opt with
    | Some x -> x
    | None -> 0
  (* alternatively you can mix with a regular argument *)
  let some_or_default default = function
    | Some x -> x
    | None -> default
  #+end_src
- Defining =Labeled Argument= function
  - when is unclear just based on the type signature
  - like with boolean values
  - or when there are more than 1 value of the same type
  - gives flexible order of passed arguments
    - except when the function is being passed
  #+begin_src ocaml
  let ratio ~num ~denom = Float.of_int num /. Float.of_int denom ;;
  (* using *)
  ratio ~num:3 ~denom:4
  (* or using LABEL PUNNING *)
  let num = 3 in
  let denom = 4 in
  ratio ~num ~denom
  #+end_src
- Defining =Optional Argument= function, beginning with ? the argument is marked as an *Option*
  Concision VS Explicitness
  - when the extra concision of omitting the argument outweights the explicitness
  - not use them on the functions internal to a module
  #+begin_src ocaml
  (* defun *)
  let concat ?sep x y =
    let sep = match sep with None -> "" | Some s -> s in
    x ^ sep ^ y
  (* defun shorthand syntax, to avoid the explicit match *)
  let concat ?(sep="") x y = x ^ sep ^ y ;;
  (* using it *)
  concat ~sep:":" "foo" "bar"
  (* using it, passing argument as optional, explicitly passing Option *)
  concat ?sep:(Some ":") "foo" "bar"
  (* useful whe defun a wrapper *)
  let uppercase_concat ?sep a b = concat ?sep (String.concat a) b
  #+end_src
** 3 Lists and Patterns
- match pattern matching will cause shadowing of reuse variables NOT a equality test (like in Erlang)
  - instead use a *if* for those cases
  - generated bytecode for match, usually jump directly to the matching condition (not just checking each one)
  - can take care of redundancy and completness in the compilation
  - can have subpatterns *|* within a large pattern
    #+begin_src ocaml
    let is_ocaml_source s =
      match String.rsplit2 s ~on:'.' with
      | Some (_, ("ml"|"mli")) -> true
      | _ -> false
    #+end_src
  - can use *as* to bind the whole matched clause
    #+begin_src ocaml
    (* naive *)
    let rec destutter list =
      match list with
      | [] -> []
      | [hd] -> hd
      | hd :: hd' :: tl ->
        if hd = hd' then destutter (hd' :: tl)
        else hd :: destutter (hd' :: tl)
    (* using as and function *)
    let rec destutter list = function
      | [] | [_] as l -> l
      | hd :: (hd' :: _ as tl) ->
        if hd = hd' then destutter tl
        else hd :: destutter tl
    #+end_src
  - can use *when* as a guard, we lost exaustive and redundant checks
    #+begin_src ocaml
    let rec destutter list = function
      | [] | [_] as l -> l
      | hd :: (hd' :: _ as tl) when hd = hd' -> destutter tl
      | hd :: tl -> hd :: destutter tl
    #+end_src
- corebench
  #+begin_src ocaml
#require "core_bench"
open Core_bench

let rec sum l =
  match l with
  | [] -> 0
  | hd :: tl -> hd + sum tl

let rec sum_if l =
  if List.is_empty l then 0
  else List.hd_exn l + sum_if (list.tl_exn 1)

let numbers = List.range 0 1000 in
[ Bench.Test.create ~name:"sum_if" (fun () -> sum_if numbers)
; Bench.Test.create ~name:"sum" (fun () -> sum numbers)]
|> Bench.bench
  #+end_src
- String.concat vs ^
  - .concat allocates 1 string
  - ^ allocates a new string every time it runs
- Tail-Call optimized function example, when the caller doesn't do anything with the value of the calle, except return it
  #+begin_src ocaml
  let rec length_plus_n n l =
    match l with
    | [] -> n
    | _ :: tl -> length_plus_n tl (n + 1)
  #+end_src
- =Base.Poly=, has polymorphic operators (like =)
  - Can't build your own
  - doesn't work on functions
  - doesn't work with heap values (like C values)
  - not recommended
** 4 Files, Modules, and Programs
- files correspond to modules
- List.Assoc, module for associative lists [(aka list; of tuples)]
- freq.ml
  #+begin_src ocaml
open Base
open Stdio

let build_counts () =
  In_channel.fold_lines In_channel.stdin ~init:[] ~f:(fun counts line ->
    let count =
      match List.Assoc.find ~equal:String.equal counts line with
      | None -> 0
      | Some x -> x
    in
    List.Assoc.add ~equal:String.equal counts line (count + 1)
  )

let () =
  build_counts ()
  |> List.sort ~compare:(fun (_,x) (_,y) -> Int.descending x y)
  |> (fun l -> List.take l 10)
  |> List.iter ~f:(fun (line,count) -> printf "%3d: %s\n" count line)
  #+end_src
- let () =, takes the role of the main function
- Building, ocamlfind is like pkgconf for ocaml
  $ ocamlfind ocamlopt -linkpkg -package base -package stdio freq.ml -o freq
- dune
  $ vim dune
  $ dune build freq.exe
  $ dune exec ./freq.exe
- Compilers
  |------------+------------|
  | ocamlopt   | ocamlc     |
  |------------+------------|
  | nativecode | bytecode   |
  | .exe       | .bc        |
  |            | +vm        |
  |            | +multiarch |
  |            | +debugging |
  | slower     | quicker    |
  | production | dev        |
  |------------+------------|
- ocamlc bytecode needs *-custom* flag to embeed the runtime
- Declaring an =Signature= Interface for a module, in a .mli file, using =val=
  val <identifier> : <type>
  #+begin_src ocaml
  open Base
  (* bump the frequency count for a given list *)
  val touch : (string * int) list -> string -> (string * int) list
  #+end_src
- =Abstract Type= (Interface) of a module, to remove dependencies and allow us to modify it freely
  - "Give you more control over how values are:
    *created* and *accessed*,
    makes it easier to enforce *invariants* beyond what is enforced by the type."
  - Minting Abstract Type for different classes of identifiers is an affective way to avoid issues
  #+NAME: counter.mli
  #+begin_src ocaml
  open Base (* frequency count = FC *)
  type t (* a collection of string FC *)
  val empty : t (* empty set of FC *)
  val touch : t -> string -> t (* bump the FC for the string *)
  val to_list : t -> (string * int) list (* FC to alist *)
  #+end_src
  #+NAME: counter.ml
  #+begin_src ocaml
  open Base
  type t = (string * int) list
  let empty = []
  let to_list x = x
  let touch counts line =
    let count =
      match List.Assoc.find ~equal:String.equal counts line with
      | None -> 0
      | Some x -> x
    in
    List.Assoc.add ~equal:String.equal counts line (count + 1)
  #+end_src
  #+NAME: freq.ml
  #+begin_src ocaml
  open Base
  open Stdio

  let build_counts () =
    In_channel.fold_lines In_channel.stdin
      ~init:Counter.empty
      ~f:Counter.touch

  let () =
    build_counts ()
    |> Counter.to_list
    |> List.sort ~compare:(fun (_,x) (_,y) -> Int.descending x y)
    |> (fun counts -> List.take counts 10)
    |> List.iter ~f:(fun (line,count) -> printf "%3d: %s\n" count line)
  #+end_src
- Refactor counter.ml, with a different datatype, Map.t
  #+begin_src ocaml
  open Base
  type t = (string,int,String.comparator_witness) Map.t
  let empty = Map.empty (module string)
  let to_list t = Map.to_alist t
  let touch t s =
    let count =
      match Map.find t s with
      | None -> 0
      | Some x -> x
    in
    Map.set t ~key:s ~data:(count + 1)
  #+end_src-
 =Concrete Types=, we define a custom type for the 2 possible return values
  "Let you expose more detail and structure to the *client*,
  in a lightweight way."
  #+Name: counter.ml
  #+begin_src ocaml
  type median = | Median of string
                | Before_and_after of string * string
  let median t =
    let sorted_string =
      List.sort (Map.to_alist t)
        ~compare(fun (_,x) (_,y) -> Int.descending x y)
    in
    let len = List.length sorted_strings in
    if len = 0 then failwith "median: empty frequency count";
    let nth n = fst (List.nth_exn sorted_strings n) in
    if len % 2 = 1
    then Median (nth (len/2))
    else Before_and_after (nth (len/2 - 1), nth(len/2))
  #+end_src
  #+Name: counter.mli
  #+begin_src ocaml
  type media = | Median of string
               | Before_and_after of string * string
  val median : t -> median
  #+end_src
- Multiple =module= per file, multiple signatures
  module <name> : <signature> = <implementation>
  #+NAME: Option 1
  #+begin_src ocaml
  open Base
  module Username : sig
    type t
    val of_string: string -> t
    val to_string: t -> string
    val (=) : t -> t -> bool
  end = struct
    type t = string
    let of_string x = x
    let to_string x = x
    let (=) = String.(=)
  end
  #+end_src
  module type <TYPE> = <signature>
  module <INAME> = <implementation>
  module <MODULE1> : <TYPE> = <INAME>
  module <MODULE2> : <TYPE> = <INAME>
  #+NAME: Option 2
  #+begin_src ocaml
  open Base
  module Time = Core.Time

  module type ID = sig
    type t
    val of_string : string -> t
    val to_string : t -> string
    val (=) :t -> t -> bool
  end

  module String_id = struct
    type t = string
    let of_string x = x
    let to_string x = x
    let (=) = String.(=)
  end

  module Username : ID = String_id
  module Hostname : ID = String_id

  type session_info = { user: Username.t;
                        host: Hostname.t;
                        when_started: Time.t;
                      }

  let sessions_have_same_user s1 s2 =
    Username.(=) s1.user s2.user
  #+end_src
- =open= (aka :use)
  - is a trade-off between terseness and explicitness (like CL's :use)
  - open sparingly, only those designed to be opened
  - open locally
- =let module <ALIAS> = <MODULE> in= (aka :local-nicknames)
- =include= (aka extending a "class"), to add new identifies to it
  #+NAME: interval.ml
  #+begin_src ocaml
  module Interval = struct
    type t = | Interval of int * int
             | Empty
    let create low high =
      if high < low then Empty else Interval (low,high)
  end
  #+end_src
  #+NAME: extended_interval.ml
  #+begin_src ocaml
  module Extended_interval = struct
    include Interval
    let contains t x =
      match t with
      | Empty -> false
      | Interval (low,high) -> x >= low && x <= high
  end
  #+end_src
- dune might detect cyclical module dependencies
*** Designing with modulesp
1) Expose Concrete Types Rarely:
   - Abstract Type
     allow *flexibity* of design,
     and makes it possible to inforce *invariants* on the use of the module
   - Concrete types allow pattern-matching
2) Designing for the Call Site:
   - labeled arguments
   - good function names
   - variant tags
   - record fields
3) Create Uniform Interfaces:
   - A module for every type, named t
   - Functions first argument is M.t
   - Extension _exn for functions that can return exception
4) Interfaces before implementations:
   - type-oriented approach to software design, type definitions
   - also at the module level aka write the .mli before the .ml

** TODO 5 Records
- =Parametric Types=, which then we can use to define =Polymorphic functions=
  #+begin_src ocaml
  type 'a with_line_num = { item: 'a ; line_num: int }
  #+end_src
- Pattern matching might not be detail each field, but is recommended.
  - #warning "+9"
    will enable the compiler warning for not exaustive pattern match of records
  - _ as the last pattern matched field, will override the warning and match everything else
- Building: Warning Help
  $ ocaml -warn-help | egrep '\b9\b'
- Building:
  - Enable warnings as errors
    -w @A-4-33-40-41-42-43-34-44
  - Default warnings as errors
    -warn-error -a+31 (only warning 31 is fatal).
  - Default warnings
    -w +a-4-7-9-27-29-30-32..42-44-45-48-50-60-66..70.
- Problems with matching field names across multiple record types
  - Functions might confuse the type of an argument, without type annotations
  - Could be solved by creating a new Module for each record type,
    Also using =type-directed constructor disambiguation=
    #+NAME: defining new records
    #+begin_src ocaml
type log_entry =
  { session_id: string;
    time: Time_ns.t;
    important: bool;
    message: string;
  }
type heartbeat =
  { session_id: string;
    time: Time_ns.t;
    status_message: string;
  }
type logon =
  { session_id: string;
    time: Time_ns.t;
    use: string;
    credentials: string;
  }
    #+end_src
    #+NAME: defining new records, module encapsulated
    #+begin_src ocaml
module Log_entry = struct
  type t =
    { session_id: string;
      time: Time_ns.t;
      status_message: string;
    }
end
module Heartbeat = struct
  type t =
    { session_id: string;
      time: Time_ns.t;
      user: string;
      credentials: string;
    }
end
module Logon = struct
end
    #+end_src
    #+NAME: instantiating new encapsulated record
    #+begin_src ocaml
let create_log_entry ~session_id ~important message : Log_entry.t =
  { time = Time_ns.now (); session_id; important; message; }
    #+end_src
    #+NAME: pattern matching encapsulated record
    #+begin_src ocaml
let message_to_string ({ important; message; _} : Log_entry.t) =
  if important then String.uppercase message else message
    #+end_src
    #+NAME: accesing a field of a encapsulated record
    #+begin_src ocaml
let is_important (t:Log_entry.t) = t.important
    #+end_src
- =with= aka OCaml's functional update syntax,
  Creates a new record using the other provided record as template, changing a field.
  Downside: The compiler 
  { <record> with <field> = <value>;
      <field> = <value>;
      ...
  }
  #+NAME: Example 1
  #+begin_src ocaml
let register_heartbeat t hb =
  { t with last_heartbeat_time = hb.Heartbeat.time }
  #+end_src
- fieldslib https://github.com/janestreet/fieldslib
  generate helpers for records
  - Automatically generate record =accessors=
    #+begin_src ocaml
#require "ppx_jane"
module Logon = struct
  type t =
    { session_id: string;
      time: Time_ns.t;
      user: string;
      credentials: string;
    }
    [@@deriving fields]
end
  #+end_src
  - Generates a submodule Field, with functions:
    .name, name of a field
    .get, content of a field
    .fset, functional update of field
    .setter, returns Option with Some f if it is mutable
- Fn.id, part of the *base* repo
- TODO
** TODO 6 Variants
#+begin_src
type <variant> =
  | <TagOrConstructor> [of <type> [* <type>]...]
  | <TagOrConstructor> [of <type> [* <type>]...]
  | ...
#+end_src
- Simple, no data, like enums
  #+begin_src ocaml
  type basic_color =
    | Black | Red | Green | Yellow | Blue | Magenta | Cyan
  #+end_src
- With data
  #+begin_src ocaml
  type weight = Regular | Bold
  type color =
    | Basic of basic_color * weight (* basic colors, regular and bold *)
    | RGB   of int * int * int (* 6x6x6 color cube *)
    | Gray  of int (* 24 grayscale levels *)
  #+end_src
- We are NOT sending a tuple, it might look like
  RGB (200,0,200)
- Multiple Argument Variant ~VS~ Variant Containing a Tuple
  Differer in memory allocation. MAV has a single allocation in memory, VCT have heap memory.
  With and Without parens
  #+begin_src ocaml
  type color1 = RGB of int * int   (* cannot take a tuple *)
  type color2 = RGB of (int * int) (* can take a tuple *)
  #+end_src
- =Avoid catch-all cases in pattern matches=,
  to have the compiler help on refactoring
  they supress compiler exhaustive checks
  aka the | _ ->
- *match*, we can use the type name when matching
  in this case "color" is the type name
  #+begin_src ocaml
    let extended_color_to_int : extended_color -> int = function
      | `RGBA (r,g,b,a) -> 256 + a + (b * 6) + (g * 36) + (r * 216)
      | #color as color -> color_to_int
  #+end_src
*** ADT =Algebraic Data Types= (Variant/Record/Tuples)
1) Product types:
   - record and tuples
   - conjuctions
   - combine multiple different types together
   - similar to cartesian products
2) Sum types:
   - variants
   - combine multiple different possibilities into one type
   - similar to disjoint unions
**** Separate
#+begin_src ocaml
  module Time_ns = Core.Time_ns
  module Log_entry = struct
    type t =
      { session_id: string;
        time: Time_ns.t;
        important: bool;
        message: string;
      }
  end
  module Heartbeat = struct
    type t =
      { session_id: string;
        time: Time_ns.t;
        status_message: string;
      }
  end
  module Logon = struct
    type t =
       { session_id: string;
         time: Time_ns.t;
         user: string;
         credentials: string;
       }
  end
  type client_message = | Logon of Logon.t
                        | Heartbeat of Heartbeat.t
                        | Log_entry of Log_entry.t
#+end_src
**** Tuple of shared fields and non-shared
#+begin_src ocaml
  module Log_entry = struct
    type t = { important: bool;
               message: string;
             }
  end
  module Heartbeat = struct
    type t = { status_message: string; }
  end
  module Logon = struct
    type t = { user: string;
               credentials: string;
             }
  end
  type details = | Logon of Logon.t
                 | Heartbeat of Heartbeat.t
                 | Log_entry of Log_entry.t
  module Common = struct
    type t = { session_id: string;
               time: Time_ns.t;
             }
  end
#+end_src
**** Embedded records, if we don't need to pass the record types outside the variant
- More memory efficient
- The inlined record CANNOT be treated as its own free-standing object
#+begin_src ocaml
type details =
  | Logon of { user: string; credentials: string; }
  | Heartbeat of { status_message: string; }
  | Log_entry of { important: bool; message: string; }
#+end_src
*** TODO Variants and Recursive Data Structurs
- Example: Boolean Expression Language, used for filters
  Parametrized bya polymorphic type 'a
  #+begin_src ocaml
  type 'a expr =
    | Base  of 'a
    | Const of bool
    | And   of 'a expr list
    | Or    of 'a expr list
    | Not   of 'a expr
  let rec eval expr base_eval =
    let eval' expr = eval expr base_eval in
    match expr with
    | Base  base  -> base_eval base
    | Const bool  -> bool
    | And   exprs -> List.for_all exprs ~f:eval'
    | Or    exprs -> List.exists  exprs ~f:eval'
    | Not   expr  -> not (eval' expr)
  #+end_src
*** Polymorphic Variants (`)
- More flexible, syntactically lightweight than variants
- Can be used without an explicit type declaration
- Style: The tag name matched the type name (`Int and int)
- Lets us reuse tags between different variant types
  - """Type cohersion"""
- match
  - Explict match of a PV ends up with an *upper* bound (<)
  - Catch all on a PV ends up with *lower* bound (>)
    - Be Extra cautious
**** | > | open     | "these tags or more" | lower bounds |
#+begin_src ocaml
let three = `Int 3
(* val three : [> `Int of int ] = `Int 3 *)
let four = `Float 4.
(* val four : [> `Float of float ] = `Float 4. *)

(* Combining the variants *)
[three; four]
(* - : [> `Float of float | `Int of int ] list *)
#+end_src
**** | < | close    | "these tags or less  | upper bounds |
#+begin_src ocaml
  let is_positive = function
    | `Int x   -> x > 0
    | `Float x -> Float.(x > 0.)
(* val is_positive : [< `Float of float | `Int of int ] -> bool *)
#+end_src
**** |   | exact    |                      | both         |
#+begin_src ocaml
  let exact = List.filter ~f:is_positive [tree;four]
(* val exact: [ `Float of float | `Int of int ] list = [`Int 3; `Float 4.] *)
#+end_src
**** |   | distinct |                      | distinct     |
#+begin_src ocaml
List.filter [three;four] ~f:(fun x ->
  match is_positive x with
  | Error _ -> false
  | Ok    b -> b)
(* [< `Float of float | `Int of int | `Not_a_number > `Float `Int ] list = *)
#+end_src
*** Example: Terminal Colors
**** PV with functions
    #+begin_src ocaml
let basic_color_to_int = function
  | `Black -> 0 | `Red     -> 1 | `Green -> 2 | `Yellow -> 3
  | `Blue  -> 4 | `Magenta -> 5 | `Cyan  -> 6 | `White  -> 7
let color_to_int = function
  | `Basic (basic_color,weight) ->
    let base = match weight with | `Bold -> 8 | `Regular -> 0 in
    base + basic_color_to_int basic_color
  | `RGB (r,g,b) -> 16 + b + g * 6 + r * 36
  | `Gray i -> 232 + 1
let extended_color_to_int = function
  | `RGBA (r,g,b,a) -> 256 + a + b * 6 + g * 36 + r * 216
  | (`Basic _ | `RGB _ | `Gray _) as color -> color_to_int
  #+end_src
**** PV with type extensions
#+NAME: color.mli
#+begin_src ocaml
  open Base
  type basic_color =
    [ `Black | `Blue | `Cyan | `Green
      `Magenta | `Red | `White | `Yellow ]
  type color =
    [ `Basic of basic_color * [ `Bold | `Regular ]
    | `Gray of int
    | `RGB of int * int * int ]
  type extended_color = (* extends color *)
    [ color
    | `RGBA of int * int * int * int ]
  val color_to_int : color -> int
  val extended_color_to_int : extended_color -> int
#+end_src
** DONE 7 Error Handling
- "Use exceptions for exceptional conditions", if the error is rare
| Errors             | Omnipresent | Acceptable | Foreseeable |   |
|--------------------+-------------+------------+-------------+---|
| Exceptions         |             | Yes        |             |   |
| Error-aware return | No          |            | Yes         |   |
*** Error-aware return type
**** =Option=
1) propagate error
   #+begin_src ocaml
 let compute_bounds ~compare list =
   let sorted = List.sort ~compare: list
   match List.hd sorted, List.last sorted with
   | None,_ | _,None -> None
   | Some x, Some y -> Some (x,y)
   #+end_src
2) Or and error might be acceptable and have not need to propagate it
**** =Result=, like an Option augmented with the ability to store other information
  #+begin_src ocaml
module Result : sig
  type ('a,'b) t = | Ok of 'a
                 | Error of 'b
end
  #+end_src
**** =Bind= aka >>=, for sequencing error producing function until one return an error
  For smaller examples (like the ones showed here, direct match of Option is generally better than bind)
  #+NAME: bind definition
  #+begin_src ocaml
let bind option f =
  match option with
  | None -> None
  | Some x -> f x
  #+end_src
  #+NAME: example 1, Option.bind
  #+begin_src ocaml
let compute_bounds ~compare list =
  let sorted = List.sort ~compare list in
  Option.bind (List.hd sorted) ~f:(fun first ->
    Option.bind (List.last sorted) ~f:(fun last ->
      Some (first,last)))
  #+end_src
  #+NAME: example 2, Option.Monad_infix, >>=
  #+begin_src ocaml
let compute_bounds ~compare list =
  let open Option.Monad_infix in
  let sorted = List.sort ~compare list in
  List.hd sorted   >>= fun first ->
  List.last sorted >>= fun last  ->
  Some (first,last)
  #+end_src
  #+NAME: example 3, Option.Let_syntax, let%bind
  #+begin_src ocaml
#require "ppx_let"
let compute_bounds ~compare list =
  let open Option.Let_syntax in
  let sorted = list.sort ~compare list in
  let%bind first = List.hd sorted in
  let%bind last  = List.last sorted in
  Some (first,last)
  #+end_src
**** =Option.both=, takes 2 Option values and returns None or a Some pair (tuple)
  #+begin_src ocaml
let compute_bounds ~compare list =
  let sorted = List.sort ~compare list in
  Option.both (List.hd sorted) (List.last sorted)
  #+end_src
*** Base.Error
- =Error.t=, defines a type for errors
- Base.Or_error.
  - error_s [%message "something was wrong" (a:string) (b: int list)]
    #+begin_src ocaml
let a = "foo" and b = ("foo",[3;4])
Or_error.error_s
  [%message "Something went wrong" (a:string) (b: string * int list)]
    #+end_src
  - Error.tag
    Error.of_list
    Error.of_string
    Error.create "Unexpected character" 'c' Char.sexp_of_t
    Error.t_of_sexp [%sexp ("List is too long",[1;2;3] : string * int list)]
*** Exceptions
- Define your own =exception/raise=
  #+begin_src ocaml
exception Key_not_found of string
raise (Key_not_found "a")
  #+end_src
- Exceptions are ordinary values, can be on a list
- Use the _exn extension on functions that return one
- Of *open* type =exn= (aka not fully defined on 1 place, extendable)
  - You can *never* exhaustive match on an =exn=
    #+begin_src ocaml
let exceptions = [ Division_by_zero; Key_not_found "b" ]
List.filter exceptions ~f:(function
  | Key_not_found _ -> true
  | _ -> false)
    #+end_src
**** =[@@deriving sexp]=, used on the type (record) AND the exception to get more exception information
  #+begin_src ocaml
  type 'a bounds = { lower: 'a; upper: 'a } [@@deriving sexp]
  exception Crossed_bounds of int bounds [@@deriving sexp]
  Crossed_bounds { lower=10; upper=0 }
  #+end_src
**** =Base.failwith=
  #+begin_src ocaml
let failwith msg = raise (Failure msg)
  #+end_src
**** =Base.assert=, to indicate a bug
  #+NAME: assert false, always triggger
  #+begin_src ocaml
let merge_lists xs ys ~f =
  if List.length xs <> List.length ys then None
  else
    let rec loop xs ys =
      match xs, ys with
      | [],[] -> []
      | x::xs, y::ys -> f x y :: loop xs ys
      | _ -> assert false
    in
    Some (loop xs ys)

merge_lists [1;2;3] [-1;1;2] ~f:(+) (* Some [0;3;5] *)
merge_lists [1;2;3] [-1;1] ~f:(+)   (* None *)
  #+end_src
**** =try/with=, and =match/exception= respond and recover from an exception
#+begin_src ocaml
try <expr> with
| <pat1> -> <expr1>
| <pat2> -> <expr2>
  #+end_src
- if uncaught the exception goes up the stack
  if still uncaught the program terminates
- Exceptions might get masked (you won't know where they exactly happened)
  if:
  - Avoid relying on the identity of an exception, to know the nature of the failure
  - Narrow the scope of the exception handler
    #+begin_src ocaml
let lookup_wieght ~compute_weight alist key =
  try
    let data = find_exn alist key in
    compute_weight data
  with
  Key_not_found _ -> 0.
      #+end_src
  - do this with MATCH
    #+begin_src ocaml
let lookup_weight ~compute_weight alist key =
  match find_exn alist key with
  | exception _ -> 0.
  | data -> compute_weight data
      #+end_src
  - or better avoid _exn, for and *option*
    #+begin_src ocaml
let lookup_weight ~compute_weight alist key =
  match List.Assoc.find ~equal:String.equal alist key with
  | None -> 0.
  | Some data -> compute_weight_data
      #+end_src
**** =Exn.protect= (like try/finally on other languages, always runs the finally fun)
  #+NAME: open a file without leadking FD
  #+begin_src ocaml
let load filename =
  let inc = In_channel.create filename in
  Exn.protect
    ~f:(fun () -> In_channel.input_lines inc |> List.map ~f:parse_line)
    ~finally:(fun () -> In_channel.close inc)
  #+end_src
  #+NAME: using build in with_file
  #+begin_src ocaml
let load filename =
  In_channel.with_file filename ~f:(fun inc ->
    In_channel.input_lines inc
    |> List.map ~f:parse_line)
  #+end_src
**** =Option.try_with= or =Or_error.try_with=, exception to option/error
  #+begin_src ocaml
let find alist key =
  Option.try_with (fun () -> find_exn alist key)
let find alist key =
  Or_error.try_with (fun () -> find_exn alist key)
  #+end_src
**** =Or_error.ok_exn=, raised exception if error
  #+begin_src ocaml
  Or_error.ok_exn (find ["a",1;"b",2] "b") (* 2 *)
  Or_error.ok_exn (find ["a",1;"b",2] "c") (* Exception: Key_not_found("c") *)
  #+end_src
*** Backtraces
- Build:
  - disabled by default
  - with =open Base= backtraces and debugging information are enabled
  - turn off backtraces
    $ OCAMLRUNPARAM=b=0 dune exec -- ./blow_up.exe
- Code:
  Backtrace.Exn_most_recent         -- backtrace of most recent exception
  Backtrace.Exn.set_recording false -- turn off backtraces
- Benchmarks with
  - Core_bench
    $ dune exec -- ./exn_cost.exe -ascii -quota 1 -clear-columns time cycles
** TODO 8 Imperative Programming
- Returning a unit () is common for imperative code
- =let () = <expr>= is equivalent to =<expr>;=
- Tip: Do the side-effect ops at the end of the function.
       Minimizes the chance that the op will be interrupted with an exception.
- Cyclic Data Structures, different general purpose cyclic DS require mutation
  #+begin_src ocaml
let rec endless_loop = 1 :: 2 :: 3 :: endless_loop
(* val endless_loop : int list = [1;2;3;<cycle>] *)
  #+end_src
- =begin/end= sometimes the precedence of =match= or =if= would make the it necessary
  #+begin_src ocaml
let insert_first t value =
  let new_elt = { prev = None; next = !t; value } in
  begin match !t with
  | Some old_first -> old_first.prev <- Some new_elt
  | None -> ()
  end;
  t := Some new_elt;
  new_elt
  #+end_src
*** Arrays
- Array.set
  Array.blit
- Exception on "out of bound" indexing
*** Strings
- Are just *byte arrays*, but immutable
- string VS Char.t array
  string is more memory efficient
- You can create mutable strings
  #+begin_src ocaml
  let b = Bytes.of_string "foobar" in
  Bytes.set b 0 (Char.uppercase (Bytes.get b 0));
  Bytes.to_string b
  #+end_src
*** Big Arrays
- Outside the OCaml heap
- To communicate with C/Fortran
*** Benign *effects*
**** laziness =lazy/force=
- Lazy.lazy <expr>
  wraps the type returned by expr into *lazy_t* type
- Lazy.force <var>
  performs the computation of variable only once
**** memoization/dynamic programming
- Dynamic Programming: bottom-up, calculations done before computing
  Memoizations       : top-down,  calculations are done when needed
- example: simplest, single argument, returns a functions memoized
  #+begin_src ocaml
let memoize m f =
  let memo_table = Hashtbl.create m in
  (fun x ->
    Hashtbl.find_or_add memo_table x ~default:(fun () -> f x))
  #+end_src
- example: timing function
  #+begin_src ocaml
let time f =
  let open Core in
  let start = Time.now() in
  let x = f () in
  let stop = Time.now () in
  printf "Time: %F ms\n" (Time.diff stop start |> Time.Span.to_ms);
  x
  #+end_src
- example: memoize fibbonacci using our simplest code
  #+begin_src ocaml
let rec fib i =
  if i <= 1 then i else fib (i - 1) + fib (i - 2)

time (fun () -> fib 40)
let fin = memoize (module Int) fib
time (fun () -> fib 40) (* still as slow the naive version *)
time (fun () -> fib 40) (* now it will be fast *)
    #+end_src
- problem: we need to insert the memoization before the recurse calls within fib
- example: we unwrap the fib, into =fib_norec=
  #+begin_src ocaml
let fib_norec fib i =
  if i <= 1 then i
  else fib (i - 1) + fib (i - 2)
  #+end_src
- example: we generalize the fib reclaration, into =make_rec=
  #+begin_src ocaml
(* instead of *)
let rec fib i = fib_norec fib i

(* we generalize *)
let make_rec f_norec =
  let rec f x = f_norec f x in
  f
let fib = make_rec fib_norec
  #+end_src
- example: lazy_memo_rec
  #+begin_src ocaml
  let lazy_memo_rec m f_norec x =
    let rec f = lazy (memoize m (fun x -> f_norec (force f) x)) in
    (force f) x

  time (fun () -> lazy_memo_rec (module Int) fib_norec 40)
  #+end_src
**** Limits of =let rec=
- Only allows on the right handside of =
  1) a function definition
  2) a constructor
  3) a lazy keyword
** TODO 9 GADT (Generalized Algebraic Data Types)
- Extension of variants
  - more expresive
  - harder to use and less intuitive
- Easier to work with ~Existential Types~, of a specific but unknown type
- They NEED type declaration when used
- Inference of GATDs does NOT play well with recursive calls
*** Example: Variant approach, a lot of work left to runtime
#+begin_src ocaml
open Base
exception Ill_typed
type value =
  | Int of int
  | Bool of bool
type expr =
  | Value of value
  | Eq of expr * expr
  | Plus of expr * expr
  | If of expr * expr * expr
let rec eval expr =
  match expr with
  | Value v -> v
  | If (c,t,e) ->
    (match eval c with
     | Bool b -> if b then eval t else eval e
     | Int _ -> raise Ill_typed)
  | Eq (x,y) ->
    (match eval x, eval y with
     | Bool _,_ | _,Bool _ -> raise Ill_typed
     | Int f1, Int f2 -> Bool (f1 = f2))
  | Plus (x,y) ->
    (match eval x, eval y with
     | Bool _,_ | _,Bool _ -> raise Ill_typed
     | Int f1 Int f2 -> Int (f1 + f2))
#+end_src
*** Example: Variant approach, *Phantom Type*
- Phantom Type:
  - A type that doesn't show up in the body of the definition of t.
  - Free to take on any value.
  - Still allows some wrong expressions to run and fail at runtime
    let expr = Typesafe_lang.(eq (bool true) (bool false))
    Exception: Ill_typed
- signature
  #+begin_src ocaml
  module type Typesafe_lang_sig = sig
    type 'a t
    (* functions for constructing expressions *)
    val int : int -> int t
    val bool : bool -> bool t
    val if_ : bool t -> 'a t -> 'a t -> 'a t
    val eq : 'a t -> 'a t -> bool t
    val plus : int t -> int t -> int t
    (* Evalation functions *)
    val int_eval : int t -> int
    val bool_eval : bool t -> bool
  end
#+end_src
- implementation
  #+begin_src ocaml
  module Typesafe_lang : Typesafe_lang_sig = struct
    type 'a t = expr (* Phantom type *)

    let int x = Value (Int x)
    let bool x = Value (Bool x)
    let if_ c t e ) = If (c,t,e)
    let eq x y = Eq (x,y)
    let plus x y = Plus (x,y)

    let int_eval expr =
      match eval expr with
      | Int x -> x
      | Bool _ -> raise Ill_typed
    let bool_eval expr =
      match eval expr with
      | Bool x -> x
      | Int _ -> raise Ill_typed
  end
#+end_src
*** Example: Variant approach, type parameter
- sig
  #+begin_src ocaml
  type 'a value =
    | Int of 'a
    | Bool of 'a
  type 'a expr =
    | Value of 'a value
    | Eq of 'a expr * 'a expr
    | Plus of 'a expr * 'a expr
    | If of bool expr * 'a expr * 'a expr
  #+end_src
- testing
  problem: the type fo the outer expression is always just equal ot the type of the inner expression
  #+begin_src ocaml
  let i x = Value (Int x)
  and b x = Value (Bool x)
  and (+:) x y = Plus (x,y)

  i 3
  b false
  i 3 +: i 4
  #+end_src
*** Example: GADT (:)
- The (:) to the right of the tag is what tells you is s GADT
- Each tag has a type constructor "function"
- Code
  #+begin_src ocaml
  type _ value =
    | Int  : int  -> int  value
    | Bool : bool -> bool value
  type _ expr =
    | Value : 'a value -> 'a expr
    | Eq   : int expr * int expr -> bool expr
    | Plus : int expr * int expr -> int expr
    | If : bool exp * 'a expr * 'a expr -> 'a expr
  #+end_src
- Now the evaluator does not needs any type check on runtime
  #+begin_src ocaml
let eval_value : type a. a value -> a = function
  | Int x -> x
  | Bool x -> x
let rec eval : type a. a expr -> a = function
  | Value v -> eval_value v
  | If (c,t,e) -> if eval c then eval t else eval e
  | Eq (x,y) -> eval x = eval y
  | Plus (x,y) -> eval x + eval y
  #+end_src
*** Different eval_value
  #+begin_src ocaml
  let eval_value : type a. a value -> a = function
    | Int x -> x
    | Bool x -> x
  (* Using a Locally Abstracted Type *)
  let eval_value (type a) (v: a value) : a =
    match v with
    | Int x -> x
    | Bool x -> x
#+end_src
*** Different eval
- Does not work with Locally Abstracted Types, due being recursive
    #+begin_src ocaml
  (* ocaml syntactic sugar *)
  let rec eval : type a. a expr -> a = function
    | Value v -> eval_value v
    | If (c,t,e) -> if eval c then eval t else eval e
    | Eq (x,y) -> eval x = eval y
    | Plus (x,y) -> eval x + eval y
  (* desugar: Marking it as Polymorphic *)
  let rec eval : 'a. 'a expr -> 'a =
    fun (type a) (x : a expr) ->
      match x with
      | Value v -> eval_value v
      | If (c,t,e) -> if eval c then eval t else eval e
      | Eq (x,y) -> eval x = eval y
      | Plus (x,y) -> eval x + eval y
    #+end_src
*** Use: Varying your return type
- A ~List.Find~ that is configurable in how it handles when does not find the item, either
  1) throw and exception
  2) return None
  3) return a default value
- Without GATDs we will always need to wrap the return into an *option*
- With GATDS, one type for the type of the list and other for the return type
  #+begin_src ocaml
  module If_notfound = struct
    type (_,_) t =
      | Raise       : ('a,'a) t
      | Return_none : ('a,'a option) t
      | Default_to  : 'a -> ('a,'a) t
  end
  let rec flexible_find
   : type a b. f:(a -> bool) -> a list -> (a,b) If_not_found.t -> b =
   fun ~f list if_not_found ->
     match list with
     | [] ->
       (match if_not_found with
       | Raise -> failwith "no matching item found"
       | Return_none -> None
       | Default_to x -> x
     | hd :: tl ->
       if f hd
       then (
         match if_not_found with
         | Raise -> hd
         | Return_none -> Some hd
         | Default_to _ -> hd)
       else flexible_find ~f tl if_not_found
  #+end_src
*** Use: ~Universally Quantified~ vs ~Existentially Quantified~
- We want instead of being compatible with ALL types,
  the type represents a particular but unknown type
- 'a is E.Q. if it shows on the left of (->), but not on the right
- Stringable
  #+begin_src ocaml
  type stringable =
    Stringable : { value: 'a; to_string: 'a -> string } -> stringable
  let print_stringable (Stringable s) =
    Stdio.print_endline (s.to_string s .value)
  #+end_src
- A function trying to return such value, would NOT typecheck
*** Use: Abstracting computational machines (combinators)
- Example is "Pipelines", with added functionality from (|>)
  - Profiling, of how long each step took
  - Control, allow pause midway through and restart it later
  - Error Handling, custom recovery for example
- Attempt 1: Functor
  #+begin_src ocaml
  module type Pipeline = sig
    type ('input, 'output) t
    val ( @> ) : ('a->'b) -> ('b,'c) t -> ('a,'c)
    val empty  : ('a,'a) t
  end
  (* Using it on a Functor *)
  module Example_pipeline (Pipeline : Pipeline) = struct
    open Pipeline
    let sum_file_sizes =
      (fun () -> Sys.ls_dir ".")
      @> List.filter ~f:Sys.is_file_exn
      @> List.map ~f:(fun file_name -> (Unix.lstat file_name).st_size)
      @> List.sum (module Int) ~f:Int64.to_int_exn
      @> empty
  end
  #+end_src
- Attempt 1.1: as function application
  #+begin_src ocaml
  module Basic_pipeline : sig
    include Pipeline
    val exec : ('a,'b) t -> 'a -> 'b
  end = struct
    type ('input,'output) t = 'input -> 'output
    let empty = Fn.id
    let ( @> ) f t input = t (f input)
    let exec t input = t input
  end
  #+end_src
- Attempt 2 GATDs
  Abstractly represent the piplene we want, build it after
  #+begin_src ocaml
  type (_,_) pipeline =
    | Step
      : ('a -> 'b) * ('b,'c) pipeline
      -> ('a,'c) pipeline
    | Empty
      : ('a,'a) pipeline
  let ( @> ) f pipeline = Step (f,pipeline)
  let empty = Empty
  let rec exec : type a b. (a,b) pipeline -> a -> =
  #+end_src
** 10 Functors
- Are functions from modules to modules.
- Use cases
  1) Dependency Injection: swappable for testing
  2) Auto-extension of modules: deriving
  3) Instantiating modules with state: can contain mutable state, is useful have multiple instance of the same module
- The input module might have extra fields,
  than the module type specified as input,
  they will be dropped.
- Idiom: comparation functions return
  - 0 if equal
  - >1 if first is bigger than the second one
  - <1 if second is bigger than first one
*** Abstracting a functor
- FROM
  #+begin_src ocaml
  module Make_interval(Endpoint : Comparable) = struct
    type t = | Interval of Endpoint.t * Endpoint.t
             | Empty
  ...
  #+end_src
- TO
  - adding return module type
  - adding type *endpoint* which is defined on the output module signature
  #+begin_src ocaml
  module Make_interval(Endpoint : Comparable) : Interval_intf = struct
    type endpoint = Endpoint.t
    type t = | Interval of Endpoint.t * Endpoint.t
             | Empty
    ...
  #+end_src
- It is not good enough because *endpoint* is not exposed
**** Use =sharing constraint=, expose the fact that a given type
  is equal to some other type.
  <Module_type> with type <type> = <type'>
  #+begin_src ocaml
  module Make_interval(Endpoint : Comparable)
    : (Interval_intf with type endpoint = Endpoint.t)
  = struct
    type endpoint = Endpoint.t
    type t = | Interval of Endpoint.t * Endpoint.t
             | Empty
  #+end_src
**** Use =Destructive Substitution=
  <Module_type> with type <type> := <type'>
** 11 First Class Modules
- create, module to value
  #+begin_src ocaml
  let simple = (module Mod1 : Modt_1)
             = [simple; (module Mod1)]
             = [simple; (module struct let x = 4 end)]
  #+end_src
- unpack, value to module
  #+begin_src ocaml
  let to_int m =
    let module M = (val m : Modt_1 ) in
    M.x;;

    (* OR using pattern patching *)
  let to_int (module M : Modt_1) = M.x
  #+end_src
- using =locally abstract type= on a function, to take and an abstract type as an argument
  along with a first-class modules polymorphically
  #+begin_src ocaml
  let bump_list
        (type a) (* locally abstract type *)
        (module Bumper : Bumpable with t = a)
        (l : a list) (* locally abstract type *)
  #+end_src
** ? Async
- A middle road between a event-callback and threads
*** Async functions
  | Function             | input      | output     |                                          |
  |----------------------+------------+------------+------------------------------------------|
  | Reader.file_contents | Deferred.t |            |                                          |
  | Deferred.peek        | Deferred.t | option     |                                          |
  | Deferred.bind        | Deferred.t | Deferred.t | with a """callback""" type function call |
  | >>=                  |            |            |                                          |
  | return               | 'a         | Deferred.t |                                          |
  | Deferred.map         | Deferred.t | Deferred.t | bind + return                            |
  | >>¦                  |            |            |                                          |
  |----------------------+------------+------------+------------------------------------------|
*** ppx_let
  let%bind
  let%map
*** ivar, low-level manual filling of variable
- Ivar.create
- Ivar.fill
- Ivar.read
- Deferred.peek works with ivar's
*** upon
- Thunk: a function whose argument is of type *unit*
- upon: schedules a callback to be called when the passed Deferred is resolved
  - upon: 'a Deferred.t -> ('a -> unit) -> unit
  - no new Deferred is created
*** Example: Queue of scheduled thunks
#+begin_src ocaml
module Delayer : Delayer_intf = struct
  type t = { delay: Time.Span.t;
             jobs: (unit -> unit) Queue.t;
           }

  let create delay =
    { delay; jobs = Queue.create () }

  let schedule t thunk =
    let ivar = Ivar.create () in
    Queue.enqueue t.jobs (fun () ->
      upon (thunk ()) (fun x -> Ivar.fill ivar x));
    upon (after t.delay) (fun () ->
      let job = Queue.dequeue_exn t.jobs in
      job ());
    Ivar.read ivar
end;;
#+end_src
*** Example: Bind made with ivar and upon
#+begin_src ocaml
let my_bind d ~f =
  let i = Ivar.create () in
  upon d (fun x -> upon (f x) (fun y -> Ivar.fill i y));
  Ivar.read i;;
#+end_src
*** Example: Echo server
#+begin_src ocaml
open Core
open Async

let rec copy_blocks buffer r w =
  Reader.read r buffer
  >>= function
  | `Eof -> return ()
  | `Ok  -> bytes_read ->
    Writer.write w (Bytes.to_string buffer) ~len:bytes_read;
    Writer.flushed w
    >>= fun () ->
    copy_blocks buffer r w
#+end_src
- provides *pushback*, it holds until progress can be made, otherwise it could lead to a a memory leak
- bind + tail recursion
*** Example: Echo server - Async.Tcp
#+begin_src ocaml
let run () =
  let host_and_port =
    Tcp.Server.create
      ~on_handler_error:`Raise
      (tcp.Where_to_listen.of_port 8765)
      (fun _addr r w ->
        let buffer = Bytes.create (16 * 1024) in
        copy_blocks buffer r w)
  in
  ignore (host_and_port : (Socket.Address.Inet.t, in) Tcp.Server.t Deferred.t)
#+end_src
* Course: 2021 - OCaml Programming: Correct + Efficient + Beautiful
  https://cs3110.github.io/textbook/cover.html
  https://www.youtube.com/playlist?list=PLre5AT9JnKShBOPeuiD9b-I4XROIJhkIU
** Chapter 2
- The =let= definition is not an expression in itself,
  you cannot use it as a subexpression, like (let z = 1) + 2
- The =let in= is an expression
- On the utop/toplevel =let= definitions are understand as expression with an implicit *in*
  - <> tells us is a unprintable value
- OCaml does NOT have multi argument functions
  - only have 1 argument functions
  - Is just syntax-sugar for nested anonymous 1 argument functions
- Variables (known value) VS Type Variables (unknown type)
  Parametric Polymorphism
- (*) when writting this operator as a function utop thinks is a comment, use instead:
  ( * )
- Declaring an infix operator
  let ( <^> ) x y = max x y
  1 <^> 2
- Application Operators
  Application (@@) (like $ in Haskell, to avoid parens, it changes the precedence rules)
  Reverse Application (|>)
** Chapter 3
- types are best read, right to left
  int list list, a list of list of integers
- List is single linked list
- [] is pronounced list (here too)
- :: is pronounced cons
- utop
  #use "file.ml";;
- utop, is not a good practice to repeatedly "#use" the same file
  close utop and #use it again
- =with= for record copy, cannot add new fields
  { e with f1 = e1 }
- =fst= only works with tuples, if we want to work with triplets we need to define our own
- =#trace <function>=, shows you the calls of a function
- =ABC= always be compiling
  1) use dummy values
  2) or raise and exception
     failWith "TODO"
     assert false
- =match=, an exception *Match_failure* is raised if no patterns match
- =function= syntax-sugar for match, it will take the last argument of the function
  #+begin_src ocaml
let f x y = function
  | p1 -> e1
  | p2 -> e2
  #+end_src
*** =Variants=
- Constant if it carries NO data, Non-Constant if it carries data
- Definition:
  Cn being the *constructs* (aka tags), capitalized
  t1 being the data *carried* by the constructor
  #+begin_src ocaml
  type t =
    | C1 of t1
    | ...
    | Cn of tn
  #+end_src
*** =ADT= Algebraic Data Types
- Another name for variants
- They allow the combination of sum and products
- Defined by the type of conjuction of the data
  (OR variants, AND records or tuples)
  (sum types  , product types)
  (tag union  , cartesian product)
- Variants gets us *heterogeneus* lists, a list of possible 2 different types
- Idiomatic: Adding an uppercase letter to deal with different variant types with the same name.
- Idiomatic: <result>_of_<~type> function naming that convert one type to another
   instead of <~type>_to_<result>
*** =Recursive Parameterized Variants=
- Can be recursive and can be parametrized
- You can think of them as "functions at the type level", from type to type.
- Example: own type that works like, List.
  [] and :: are just constructors
  #+begin_src ocaml
  type 'a mylist =
    | []
    | (::) of 'a * 'a mylist
 let rec length = function
    | [] -> 0
    | _ :: t -> 1 + length t
  #+end_src
*** =Option=
- A way to think about them is a *box*
- Nested =match= are better with =begin/end=
*** =Exceptions=
- Are variants
- type exn
- All exceptions are subtype of it
- exn is a built-in *extensible* variant,
  meaning that his constructs can be define later by us
- Predefined exceptions
  | exception       | of     | helper      | return |   |
  |-----------------+--------+-------------+--------+---|
  | Failure         | string | failwith    | 'a     |   |
  | InvalidArgument | string | invalid_arg | 'a     |   |
*** Variant Example: Binary Trees
Binary Tree VS List, they have an extra child
#+begin_src ocaml
type 'a mylist =
  | Nil
  | Cons of 'a * 'a mylist
type 'a tree =
  | Leaf
  | Node of 'a * 'a tree * 'a tree
#+end_src
** Chapter 4
- Partial application: You can leave off the argument of a function,
  #+begin_src ocaml
let double x = 2 * x
let twice f x = f (f x)
let quad x = twice double x
let quad = twice double
  #+end_src
- fold       init op
  fold_right f    acc
  fold_left  acc  f
- fold_left is tail-recursive
** Chapter 5
- https://informationisbeautiful.net/visualizations/million-lines-of-code/
- Features for modularity
  |---------------+--------------------+------------------------|
  |               | OCaml              | Java                   |
  |---------------+--------------------+------------------------|
  | Namespaces    | struct             | Classes, packages      |
  | Interfaces    | sig                | Interfaces             |
  | Encapsulation | Abstract Types     | Public, private        |
  | Code reuse    | Functors, includes | Subtyping, inheritance |
  |---------------+--------------------+------------------------|
- Structures give us hierarchical namespaces
  - Can help to have the same function work with different types
    Just put the function and type in a *module/struct*
- Functional Datastructure: one that there are no updates
  Persistant, rather than ephemeral
- =module= definition syntax is similar to the one of *let*
  still module are not like any other value (cannot bind, pass to function, or return from function)
- Example: to get a queue with constant time for enqueue and peek at the same time
  1) define a queue as a record of 2 lists a `front` and a `back`
  2) front is a normal list
  3) back is a list reversed
- *Exceptions* makes it easier to pipeline (|>) operations
- *Options* makes it a little bit harder (except with bind)
- ( >>| ), Option.map
  applies the function to an Option element
  #+begin_src ocaml
  let ( >>| ) opt f =
    match opt with
    | None -> None
    | Some x -> Some (f x)
  #+end_src
- ( >>= ), Option.bind
  it takes an option, but it does NOT add an extra level of option around
  #+begin_src ocaml
  let ( >>= ) opt f =
    match opt with
    | None -> None
    | Some x -> f x
  #+end_src
- =sig= and =val= for defining interfaces/signatures
  we define a =module type= since is the type of a module NOT the value
  functions NOT defined in the *sig* but present on the *struct* will be unaccesible (private)
  #+begin_src ocaml
  module type Fact = sig
    (** documentation comment *)
    val fact : int -> int
  end
  (* We can define modules that have the type Fact *)
  module RecursiveFact : Fact = struct
    let rec fact n =
      if n = 0 then 1 else
        n * fact (n - 1)
  end
  #+end_src
- can also declare a new module
  - using a module type sig name (Queue)
  - and using the struct definition (ListQueueImpl)
  #+begin_src ocaml
  module ListQueue : Queue = ListQueueImpl
  #+end_src
- type checker ensures that
  1) Signature Matching: between the sig and the module definition
  2) Encapsulation: only things in sig can be accessed outside the module
- Abstract Data Types
  - Help use use the same signature for different struct implementations
  - Signatures help encapsulate types too
  - We can then, NOT specify the actual type on the *sig*
  - When we seal it, the outside world won't know the implementation type
    Will only know the type of *sig* not the *struct*
- =.mli=, no need to use =module type= or =sig=
  the .mli would have the public/sig (without explicitly declaring it)
  the .ml  would have the private/implementation
- Compilation unit = .ml + .mli
- =include=,
  we include all the contents of another *sig* or *struct* into the new one being defined
  make sure to include the unsealed versions of them
  >> kind of like inheriting the fields
- =include= is not the same as =open=
  open imports, doesn't exports
  include import, and exports
- =functors= takes a module as input and outputs a module
  always have to specify the type of input module for the functor
  #+begin_src ocaml
  module type X = sig
    val x : int
  end

  module A : X = struxt
    let x = 0
  end

  module IncX = functor (M : X) -> struct
    let x = M.x + 1
  end
  (* or *)
  module IncX (M : X) = struct
    let x = M.x + 1
  end
  (* USE it, can't just IncX(A) *)
  module B = IncX(A)
  #+end_src
- =Map=, binary balanced binary trees (not hashmaps)
  #+NAME: using the functor Map.Make
  #+begin_src ocaml
type day = Mon | Tue | Wed | Thu | Fri | Sat | Sun

let int_of_day = function
  | Mon -> 1
  | Tue -> 2
  | Wed -> 3
  | Thu -> 4
  | Fri -> 5
  | Sat -> 6
  | Sun -> 7

module DayKey = struct
  type t = day
  let compare day1 day2 =
    int_of_day day1 - int_of_day day2
end

module DayMap = Map.Make(DayKey)
  #+end_src
  - like TreeMap in java
  - To create map, call Make
    - which takes a struct, so you pass a module
      1) that has a type for the keys
      2) compare functions for the keys
** Chapter 6
- Client/Implementer, people who deal with the the *spec*
  - Agree on *Precondition and Postconditions* in a specification comment
  - Notes on performance (?
- (Docstring) specification format example
  #+begin_src ocaml
(** [f x] is ... aka one line summary, sometimes the postcondition
    Examples: ... boundary cases
    - [sort [1;3;2;3]] is [[1;2;3;3]].
    - [sort []] is [[]].
    Requires: ... aka precondition
    Raises: [Failure "hd"] if [lst] .. also a postcondition
      is empty. *)
val f : t -> u
  #+end_src
- You do NOT need to assert the precondition
- .ml  = Data Structure
  .mli = Data Abstraction
- When documenting the type .t of the =struct= implementation
  - AF =Abstraction Function=, how to *interpret* the abstracted data
    Implementation: Generally no, but a mathemathical idea.
    Except on .to_string functions, or any that converts data to a string.
  - RI =Representation Invariant=, which values are the *meaninful*
    Distinguish between valid and invalid concrete values.
    It might be not respected, while doing a concrete operation.
    - Implementation: yes like with a *rep_ok* function to check before and after a function,
      otherwise failwith
    - DEBUG: rep_ok can be used for debug, in prod use an identity function
      and in dev use the full version
    #+begin_src ocaml
    let rep_ok (x : t) : t =
      if (* check RI *) then t
      else failwith "RI"
    #+end_src
- Validation
  1) Validation: social, methodogical, technological, mathematical
  2) Testing
  3) Debugging
  4) Defensive Programming
- Testing vs Verification
  - Verification, can demostrate that it will work with ALL inputs
- Human Error -> Fault -> Failure (something goes wrong)
  a bug
- BlackBox Testing
  1) Typical Cases
  2) Boundary Cases
  3) Paths through spec:
     1) representative values that generate all possible outputs (bool or one of both)
     2) Different ways to satisfy the precondition(s)
     3) representative of raising exceptions and not
  4) Data Abstractions:
     consumer functions <-> producer functions
     test all posible interactions between
     size <-> add 1
     size <-> empty
- Glass Box Testing: supplements blackbox testing
  Coverage, more than one can be achieved
  * Statement: evaluate every statement/expression
  * Condition: evaluate every boolean/pattern match to each possible value
  * Path: every possible execution path (branch and sub-branch)
- Glass Box: look out for
  1) base cases of recursive function
  2) recursive calls in recursive functions
  3) every place a exception might be raised
- Glass Box: *bisect* is a tool to know code-coverage
  https://github.com/aantron/bisect_ppx
  #+NAME: leap_year_test.ml
  #+begin_src ocaml
open OUnit2
open Leap_year

let leap_year_test (n, y, b) =
  n >:: fun _ -> assert_equal b (leap_year y)

let tests = List.map leap_year_test [
  "non leap year", 2010, false;
  "non-centennial", 2020, true;
  "quadracentennial", 2000, true;
]

let suite = "leap year" >::: tests
let _ = run_test_tt_main suite
  #+end_src
  #+NAME: Makefile TODO
  #+begin_src makefile
test:
  BISECT_COVERAGE=YES $(OCAMLBUILD) -tag 'debug' -use-ocamlfind -plugin-tag

bisect: clen test
  bisect-ppx-report html

clean:
  ocamlbuild -clean
  rm -rf bisect*.coverage _coverage
    #+end_src
- Randomized testing (Fuzzing):
  Generate random input, and feed it to the program.
  #+NAME: leap_year_test.ml
  #+begin_src ocaml
  ...
  let mult4_or_non_leap_year y =
    y mod 4 == 0 || not (leap_year y)
  let random_non_4s =
    QCheck.Test.make ~count:1000
      ~name: "non-multiples of 4 cannot be leap years"
      QCheck.(1 -- 3000)
      mult4_or_non_leap_year

  let mult400_or_non_leap_year y =
    y mod 400 = 0 || not (leap_year y)
  let random_100s =
    QCheck.Test.make ~count:1000
    ~name:"100s cannot be leap years unless also"
    QCheck.(map(( * ) 100) (1 -- 30))
    mult400_or_non_leap_year

  let qcheck_tests = List.map QCheck_onuit.to_ounit2 [
    random_non4s;
    random_100s;
  ]
  let suite = "leap years" >::: List.flatten [
    tests;
    qcheck_tests;
  ]
  ...
  #+end_src
- Debugging: Follow the scientific method
  1) Formulate a falsifiable hypothesis
  2) create and experiment that can refute that hypothesis
  3) run the experiment
  4) keep a lab notebook
  5) if everything else fails, question the sanity of the whole thing
- let ( << ) = compose
- Induction, example on natural numbers
  - Base case:      n = 0
    Show: P(0)
  - Inductive case: n = k + 1
    IH:   P(k) (inductive hypothesis, we can have more than 1)
    Show: P(k+1)
- Total Correctness = partial correctness + termination
- https://en.wikipedia.org/wiki/Halting_problem
  https://www.youtube.com/watch?v=Iapz9pb5eRU
** Chapter 7
- =ref=, is a *pointer* to a typed location in memory
  - immutable, binding of a variable to a pointer
  - mutable, contents of a memory location
  - (!) being a derefence operator
  - =ref= is used for both the type and the function that creates
  - locations are created by ref
  - locations are values, NOT expressions
    - no addresses arithmetic
    - no direct creation of addresses
- =ignore=, used to ignore a value of an expression
  to avoid warnings on e1 if not returns a ()
  ignore: 'a -> unit
  e1;e2
  ignore e1; e2
- aliasing, when having a second variable point to the same location of another ref
- (==) physical equality
  (!=)
- (=) structural equality, contents (aka structure)
  (<>)
- Example: counter, lambda
  #+begin_src ocaml
  let next =
    let counter = ref 0 in
    fun () ->
      incr counter;
      !counter
  next () (* 1 *)
  next () (* 2 *)
  #+end_src
- Example: linked list
  #+NAME: two ways of represent a node, ref/mutable
  #+begin_src ocaml
  type 'a node = {
    value : 'a;
    mutable next : 'a node;
  }

  type 'a node = {
    value : 'a;
    next : 'a node ref;
  }
  #+end_src
  #+NAME: using an option
  #+begin_src ocaml
  (** An ['a node] is a node of a mutable singly-linked list.
      It contains a value of type ['a] and optionally has
      a pointer to the next node. *)
  type 'a node = {
    value : 'a;
    mutable next : 'a node option;
  }
  (** An ['a mlist] is a mutable singly-linked list with
      elements of type ['a]. *)
  type a mlist = {
    mutable first : 'a node option;
  }
  #+end_src
** Chapter 8
- (,) when writing 2 type variable on a type param constructor
  (*) when we define a list of a type, we can't use comma, so use (*)
  #+begin_src ocaml
let bindings : ('k, 'v) t -> ('k * 'v) list
  #+end_src
- TTD
  #+NAME: maps.ml
  #+begin_src ocaml
module AssocListMap : Map = struct
  type ('k, 'v) t = unit
  let insert k v m =
    failwith "uninplemented"
end
  #+end_src
  #+NAME: maps_test.ml, template
  #+begin_src ocaml
open OUnit2
open Maps
let assoc_tests = [
]
let suite "maps suite" >::: assoc_tests
let _ = run_test_tt_main suite
  #+end_src
- Tests: "There are only 3 numbers, zero, one and many"
- Example: DAT Direct Access Table, just an array
- When creating values of a Mutable DS, we need a function to create it, not a value
- Map Implementation
  |                    | insert   | find     | remove   |
  |--------------------+----------+----------+----------|
  | Alist              | O(1)     | O(n)     | O(n      |
  | DAT                | O(1)     | O(1)     | O(1)     |
  | Hash+Chaining      | O(n)**   | O(1)*    | O(n)**   |
  | Red-Black Map Tree | O(log n) | O(log n) | O(log n) |
  |--------------------+----------+----------+----------|
  * expected
  ** amortized O(1)
- DAT, keys must be integers, fast, high space
- Alist, any keys, but slow
- Hashtbl
  #+begin_src ocaml
  type ('k, 'v) t = {
    mutable buckets (* mutable to allow resize in case of high load factor *)
      : ('k * 'v) list array
  }
  #+end_src
  - Expected bucket length, aka the constant part of the O(?) aka "load factor"
    = (#bindings in hash) / (#buckets in array)
  - maps keys to integers, at O(1) time
  - mapping accepts collisions
  - *Bucket* integer output of a hash
  - *Probing* dealing with the collision by moving somewhere else
  - *Chaining* storing multiple collision values in a list in the bucket
- Steps of a hash function
  1) serialization: string -> bytes (injective)
  2) diffussion: bytes -> int (maybe injective)
     - modular        hashing
     - multiplicative hashing
     - universal      hashing
     - cryptographic  hashing
  3) compression: int -> int (from a wide range to small one)
- Hashtbl.hash
  - Does the *serialization*
  - Does the *diffusion* (in native C code "MurmurHash")
- Hashtbl.key_index
  - Does *compression*
- Hashtbl.Make
  - *compression* in client
  - a functor
  - Hashtbl.HashedType, input signature
    equal: t -> t -> bool
    hash : t -> int
- Amortized analysis of hash tables
  Saving a budget on cheap operations for the eventual big payment (resize)
  Amortized O(n)
  - Techniques: banker's method, physicis's method
- Amortized analysis of Two-list Queues
  - peek/enqueue still O(1)
  - Dequeue is O(n) or using this analysis "amortized O(1)"
- Search
  - Linear search: O(n)
    Binary search: O(log n)
- Binary Search Tree (BST)
  - are not necesarilly O(log n)
  - unbalanced trees have O(n), since they are just linked list
  - random insertions (as oppose to ascending one) are way faster (as they don't degenerate)
- "2-3 trees", ensure that all paths have the same length
- "AVL-trees", length of shortest and longest differ by 1
  OCAML uses this for his tree implementation with difference 2
- "Red-Black trees", length of shortest and longest differ by "at most a factor of 2" (can be at most twice as long)
  it does it by having some RI, using colors, paths and rebalances
  give you excelent performance on random and ascending workload
** Chapter 9
- AST (abstract syntaxt tree)
  -> IR (intermediate representation)
  -> Machine code
- Interpreted Language
  |                      |        | output           |
  |----------------------+--------+------------------|
  | lexical              | lexer  | tokens           |
  | syntactic            | parser | ast              |
  | semantic             |        | ast/symbol table |
  | compiler/interpreter |        | IR               |
  |----------------------+--------+------------------|
- .ml - test.ml
  #+begin_src ocaml
  open OUnit2
  open Aast
  open Main
  let make_i n i s =
    n >:: (fun _ -> assert_equal (string_if_int i) (interp s))
  let tests = [
    make_i "int" 22 "22";
  ]
  let _ = run_test_tt_main ("suite" >::: tests)
  #+end_src
- .ml  - main.ml
  #+begin_src ocaml
open Ast
let parse (s : string) : expr =
  let lexbuf = lexing.from_string s in
  let ast = Parser.prog Lexer.read lexbuf in
  ast

let string_of_val (e : expr) : string =
  match e with
  | Int i -> string_of_int i

let is_value : expr -> bool = function
  | Int _ -> true
let rc step : expr -> expr = function
  | Int i -> failwith "does not step"

let rec eval (e : expr) : expr =
  if is_value e then e
  else e |> step |> eval

let interp (s : string) : string =
  s |> parse |> eval |> string_of_val
    #+end_src
- .ml  - ast.ml
  #+begin_src ocaml
  type bop =
    | Add
    | Mult
  type expr =
    | Int of int
    | Binop of bop * expr * expr
  #+end_src
- .mll - lexer.mll
  #+begin_src
{
open Parser
}

let digit = ['0'-'9']
let int = '-'? digit+

rule read =
  parse
  | "+" { PLUS }
  | int { INT (int_of_string (Lexing.lexeme lexbuf)) }
  | eof { EOF }
  #+end_src
- .mly - parser.mly
  #+begin_src
%token <int> INT
%token PLUS
%token EOF

%start <Ast.expr> prog

%%

prog:
  | e = expr; EOF { () }
  ;

expr:
  | i = INT { Int i }
  | e1 = expr; PLUS; e2 = expr { Binop (Add, e1, e2) }
  ;
    #+end_src
* Course: 2020 - Princeton - COS 326 - Functional Programming
  2012 https://www.cs.princeton.edu/~dpw/courses/cos326-12/lectures.php
  2021 https://www.cs.princeton.edu/courses/archive/fall21/cos326/schedule.php
  2020 Video https://mediacentral.princeton.edu/channel/COS+326+Functional+Programming/174748251
** 03
- Function parameters are patterns too
  #+begin_src ocaml
  type point = float * float

  let distance ((x1,y1):point) ((x2,y2):point) : float =
    let square x = x *. x in
    sqrt (square (x -. x1) +. square (y2 -. y1))
  #+end_src
** 12 Modules
*** 1
- Signature = an inteface
  Structure = an implementation
  Function  = a parametrized module
- Murphy's Law: "When is not enforced is broken"
- Types of operations on a data type
  1) Constructor: return a value of the type
  2) Observer: reveals information about the status of the type
  3) Mutator: takes t and returns a new t
- "Sealing" a structure by a signature, limits visibility
*** 2
- Principles:
  1) Fail as early as possible (ex: return irregular data)
  2) Non-determinism is tough for clients (ex: return bad data)
  3) Recoverable errors are better (ex: crashing)
  4) More Non-determinism is worse (ex: it crashes or ret bad data)
- Options and Exceptions are preferred
  - *exception* can be declared on signatures, they can be handled
  - *option*, adds an code overhead
*** 3
** 18 Parallel
- Frameworks
  1) Dryad https://www.microsoft.com/en-us/research/publication/dryad-distributed-data-parallel-programs-from-sequential-building-blocks/
  2) Naiad https://www.youtube.com/watch?v=lHBCq2AbWqc&feature=emb_title
  3) Spark
  4) Hadoop
  5) Pig
- Types
  - Data, same computation on independent items
  - Task, different computations at the same time
  - Pipeline, assembly line
- Concurrency, mediates multiparty access to shared resources
  - Thread is single core, good for concurrent programming but not for parallel
    - That is < 2021
- Paralleism, performs many tasks simultaneously
  - You cannot get more parallelism than the number of virtual cores you have.
  - CPU's cache makes parallel operations even more complicated than just interleaving
- ~Atomicity~ is not guaranteed on a ref, on a := and !
  - Even if it is on the operation, it won't be across threads
    #+begin_src ocaml
    let inc(r:int ref) = r := !r + 1
    #+end_src
- ~Busy waiting~
  - Consuming CPU without doing something useful
  - CPU could either be runnign a useful thread/program or power down
- Thread.(create join)
  - ~Fork-Join Paralleism~, *join*, wait for the thread t to finish and resume when done
- Performance Bugs: for example when you run serial a code that is mean to be parallel
*** Futures (aka promises or delays)
- Easy to reason when there are NOT side effects, purely functional
- Good for things worst than O(n log n), it will get at best linear time
- Types helps remove errors at run-time, by checking types at compile-time
- Similar to *lazy programming*, not the same
**** Signature
  #+begin_src ocaml
  module type FUTURE =
  sig
    type 'a future
    val future : ('a -> 'b) -> 'a -> 'b future
    val force : 'a future -> 'a
  end
  #+end_src
**** An implementation
  #+begin_src ocaml
  module Future : FUTURE =
  struct
    type 'a future = { tid   : Thread.t ;
                      value : 'a option ref }

    let future(f:'a->'b) (x:'a) : 'b future =
      let r ref None in
      let t = Thread.create (fun () -> r:= Some(f x)) () in
      {tid=t ; value=r}

    let force (f:'a future) : 'a =
      Thread.join f.tid;
      match !(f.value) with
      | Some v -> v
      | None -> failwith "impossible"
  end
  #+end_src
**** Using it
  #+begin_src ocaml
  let x = future f () in
  let y = g () in
  let v = force x in
  #+end_src
* Libraries
- LWT/Telegram bot https://github.com/quernd/SushiBot
- Synth https://github.com/smimram/monadic-synth
- WebFramework https://aantron.github.io/dream/
- HTTP Server
  - https://github.com/inhabitedtype/ocaml-webmachine
  - https://github.com/mirage/ocaml-cohttp
  - https://github.com/dinosaure/multipart_form
- HTTP Clients
  - https://github.com/mirage/ocaml-cohttp
  - https://github.com/ygrek/ocurl
- https://github.com/aantron/bisect_ppx
- MirageOS smpt https://github.com/dinosaure/ptt-deployer
- https://janmidtgaard.dk/quickcheck/index.html
- https://github.com/ocaml-community/awesome-ocaml
- https://github.com/dinosaure/gilbraltar
- https://github.com/mirage/ocaml-freestanding
- Utils
  Source https://github.com/ocaml-batteries-team/batteries-included
  Docs https://ocaml-batteries-team.github.io/batteries-included/hdoc2/index.html
- Utils https://github.com/c-cube/ocaml-containers
- Utils https://github.com/janestreet/base
- Utils https://github.com/janestreet/core
- Utils https://github.com/janestreet/async
* Video
- 2014 Ocaml at Bloomberg http://cufp.org/2014/maxime-ransan-adopting-functional-programming-with-ocaml-at-bloomberg-lp.html
- Podcast: Automated Trading and OCaml with Yaron Minsky
  https://www.youtube.com/watch?v=KdAS2_Gienc
- Video: Effective ML (Yaron Minsky)
  https://vimeo.com/21564387
  https://vimeo.com/21564926
- Video: Raytracer
  https://www.youtube.com/playlist?list=PLlw1FcLpWd42vMLPlR3K7iq-CuCtkZr8o
  https://github.com/LesleyLai/ocamlpt
- TODO François René Rideau- Building Distributed Applications in OCaml- λC 2019
  https://www.youtube.com/watch?v=ZLZqe0goxF0
  - Better to programming at scale (multiple persons)
  - Better for hostile environments
  - Better for Distributed applications programming
- OCaml 2021 https://www.youtube.com/playlist?list=PLyrlk8Xaylp5CdqKE-ZqR5K5kRgPcKYN9
- OCaml 2014: The State of OCaml (invited), Xavier Leroy https://www.youtube.com/watch?v=DMzZy1bqj6Q&list=UUP9g4dLR7xt6KzCYntNqYcw
- Video: 2012 - Xavier Leroy - The continuation of functional programming by other means
  https://events.inf.ed.ac.uk/Milner2012/X_Leroy-html5-mp4.html
** Channels
- Westley Weimer https://www.youtube.com/channel/UCSZ5lYLg6ARj4Wow3ZQXQzA/videos
- Anwar Mamat https://www.youtube.com/playlist?list=PLF-pVzrCrXdj7rBvOOwulglwwDjVy96uI
- Jane Street https://www.youtube.com/channel/UCDsVC_ewpcEW_AQcO-H-RDQ
- Eduardo Rafael https://www.youtube.com/c/EduardoRFS/videos
- Ocaml Workshops https://www.youtube.com/c/OCamlWorkshops/videos
- Ocaml Software Foundation https://www.youtube.com/channel/UCnwkbeuXjuUTNsPoLKsBWdg
** Video: 2015 - A Crash Course in OCaml Modules - Tim McGilchrist
https://www.youtube.com/watch?v=lISWTUyNP4c
- =OCaml Modules= v =Haskell Type Classes=
- Ocaml Modules
  - like Functors (in category theory)
  - aka parametrized structures
  - functions from struct to struct
- Haskell
  - Implicit program construction
  - ad-hoc polymorphism
- Ocaml
  - Type Safe Extensions (using *include*) (aka monkeypatching)
  - Parametrized Library
    you can pick different "backends" or implementations for things
    like pick between lwt and async support
*** Typeclasses to Signatures
  #+begin_src ocaml haskell
  class Show a where
      show :: a -> String
  #+end_src
  #+begin_src ocaml
  module type Show = sig
    type t
    val show : t -> string
  end
  #+end_src
*** Instances   to Structures
  #+begin_src haskell
  instance Show Int where
      show = ... -- Provided by GHC
  #+end_src
  #+begin_src ocaml
  module ShowInt = struct
    type t = int
    let show = string_of_int
  end
  #+end_src
*** Using them
  #+begin_src haskell
  csv :: Show a => [a] String
  csv [] = ""
  csv [x] = show x
  csv h:t = show h ++ "," ++ csv t
  #+end_src
  - 1 extra step, instanciate with the functor, a new module
  #+begin_src ocaml
  module Csv(S:Show) = struct
    let rec to_csv : S.t -> string = function
      | []   -> ""
      | [x]  -> S.show x
      | h::t -> S.show h ^ "," ^ to_csv t
  end
  module X = Csv(ShowInt) (* extra step *)
  X.to_csv [1;2;3] (* => 1,2,3 *)
  #+end_src

** TODO Video: 2019 - GADTs and You; Writing Safer Code Using GADTs
   Nathan Holland https://www.youtube.com/watch?v=tEQ8bTNYj5g
   runnable slides https://github.com/nholland94/gadt-lambdaconf-talk
- Allows us:
  1) add *invariants* to our DT at the type level
     - Disallow to construction of values that don't follow the invariants
  2) restrict values we can pass to a functions
  3) Encode simple logic
  4) Runtime optimizations
- Limitations of ADTs
  - Since every constructor of and ADT (a variant) the same type
    - We are not able to reason about the types inside an ADT
- Use patterns
  - Type Witness, mapping between type parametres and the constructors
    #+begin_src ocaml
    type 'a witness =
      | Int : int witness
      | Bool : float witness
    #+end_src
  - Recursive Type Witness
    #+begin_src ocaml
    type 'a witness =
      | Int : int witness
      | Bool : float witness
      | List : 'a witness -> ('a list) witness
    #+end_src
  - Type Level Peano Numbers
    #+begin_src ocaml
    (* ADT *)
    type peano =
      | Zero
      | Succ of peano
    let zero = unit
    let one = Succ zero
    let four = Succ (Succ (Succ (Succ Zero)))
    (* Type Level *)
    type zero = unit
    type 'a succ = unit -> 'a
    type one = zero succ
    type two = one succ
    (* GADT *)
    type 'a peano =
      | Zero : zero peano
      | Succ : 'a peano -> ('a succ) peano
    let succ : 'a peano -> ('a succ) peano = fun n -> Succ n
    let zero : zero peano = Zero
    let one : one peano = Succ zero
    #+end_src
    13:00
* Books
- 2012 - Fun of Programming https://github.com/bobzhang/ocaml-book
- 2014 - Unix system programming in OCaml
  https://ocaml.github.io/ocamlunix/
  Text Code https://github.com/ocaml/ocamlunix
- 2021
  https://ocaml.xyz/book/
  https://github.com/owlbarn/owl
- OCaml From the Ground Up
  https://ocamlbook.org/
  https://github.com/dmbaturin/ocamlbook.org/tree/master/book
