- https://github.com/graninas/software-design-in-haskell
- https://kowainik.github.io/posts/haskell-mini-patterns
- https://github.com/kowainik/learn4haskell
- https://en.wikipedia.org/wiki/Dependent_type
- https://en.wikipedia.org/wiki/Generalized_algebraic_data_type
- https://github.com/omelkonian/AlgoRhythm (music)
- https://github.com/XiNNiW/tidalcyclesjournal/ (tidal tutorial)
- Making Algorithmic Music
  Compose NYC 2019
  Speaker: Donya Quick
  https://www.youtube.com/watch?v=9Fg54XAr044
- Haskell MOOC University of Helsinki
  https://haskell.mooc.fi/material/
  https://github.com/moocfi/haskell-mooc
- 2011
  Stanford CS240h, Functional Systems in Haskell
  https://github.com/bos/stanford-cs240h
  http://www.scs.stanford.edu/11au-cs240h/notes/
- https://github.com/hzlmn/haskell-must-watch
* Personalities
** Simon Peyton-Jones
- haskell comitee on design
** Philip Wadler
- haskell comitee on design
* Backend Web Programming in Haskell - Tsoding
https://www.twitch.tv/videos/743607386
https://github.com/tsoding/tsoken/blob/master/src/Main.hs
* Setup
  - https://github.com/haskell/haskell-ide-engine
  - https://github.com/soupi/minimal-haskell-emacs (setup)
  - https://github.com/ndmitchell/ghcid (continuous building)
  - https://github.com/ndmitchell/hlint (bashate like)
  - https://github.com/chrisdone/hindent (formatter)
* Libraries
- A fast, light-weight web server for WAI applications.
  https://hackage.haskell.org/package/warp
  https://hackage.haskell.org/package/wai
- REST - A family of combinators for defining webservices APIs and serving them
  https://hackage.haskell.org/package/servant
- https://hackage.haskell.org/package/turtle-1.5.21/docs/Turtle-Tutorial.html
- Conduit is a framework for dealing with streaming data, such as reading raw bytes from a file, parsing a CSV response body from an HTTP request, or performing an action on all files in a directory tree. 
  https://github.com/snoyberg/conduit
- It is defined as a monad transformer that can be stacked on arbitrary monads, and it is also parametric in the input stream type.
  https://hackage.haskell.org/package/parsec
- State of the Haskell ecosystem
  https://github.com/Gabriel439/post-rfc/blob/master/sotu.md
* Learn
  - https://github.com/hmemcpy/milewski-ctfp-pdf
  - CIS 194: Introduction to Haskell (Spring 2013)
    https://www.seas.upenn.edu/~cis194/spring13/lectures.html
  - https://threadreaderapp.com/thread/1277615394560360449.html
  - https://github.com/Kuratoro/haskell.zettel.page/blob/master/2012502.md
  - Applied Haskell is a commercial training program focusing on teaching intermediate Haskell.
    https://www.fpcomplete.com/haskell/syllabus/
  - http://learnyouahaskell.com/chapters
  - https://www.reddit.com/r/haskell/comments/d5og5n/which_book/
  - https://github.com/i-am-tom/haskell-exercises (extensions)
  - https://github.com/caiorss/Functional-Programming
  - http://dev.stephendiehl.com/hask/index.html
  - https://kowainik.github.io/posts/haskell-mini-patterns
  - https://github.com/soupi/haskell-study-plan
  - https://github.com/alpacaaa/zero-bullshit-haskell
  - https://github.com/tssm/up-to-date-real-world-haskell
  - https://github.com/graninas/software-design-in-haskell
  - https://github.com/bitemyapp/learnhaskell
* Videos
** Courses
   - Haskell Summer Course
     https://www.youtube.com/playlist?list=PLaAHmR4OoQXcrQl7kgkraWQAgQ-8FpEmS
   - GoogleTechTalk Haskell 10X
     https://www.youtube.com/watch?v=cTN1Qar4HSw
     https://www.youtube.com/watch?v=Ug9yJnOYR4U
     https://github.com/google/haskell-trainings
   - 2018 Haskell School in the Networked Imagination Laboratory
     https://www.youtube.com/playlist?list=PLyEzdf4cdMMHGqVnAzLV8eDXn6Ajj46JA
   - Haskell : Learn You a Haskell for Great Good
     https://www.youtube.com/playlist?list=PLS6urCrsYES24Fwzg5-Uga1QEbNm9kiU_
   - Haskell for Imperative Programmers
     https://www.youtube.com/playlist?list=PLe7Ei6viL6jGp1Rfu0dil1JH1SHk9bgDV
   - Haskell - Functional Programming Fundamentals (Dr. Erik Meijer)
     https://www.youtube.com/playlist?list=PLoJC20gNfC2gpI7Dl6fg8uj1a-wfnWTH8
   - Programming with Categories
     http://brendanfong.com/programmingcats.html
     https://www.youtube.com/playlist?list=PLhgq-BqyZ7i7MTGhUROZy3BOICnVixETS (category theory)
** Livecoding
   - https://www.youtube.com/user/kindohm (tidal)
   - Barry (haskell book) https://www.youtube.com/channel/UCndlCtPeYygdGZ9UUKdehbw
** other
  - Jappie Klooster
    https://www.youtube.com/channel/UCQxmXSQEYyCeBC6urMWRPVw/videos
  - HaskellRank (tsoding)
    https://www.youtube.com/playlist?list=PLguYJK7ydFE4aS8fq4D6DqjF6qsysxTnx
  - lenses
    https://www.youtube.com/watch?v=cefnmjtAolY
    https://docs.google.com/file/d/0ByK3AAy5ubqady1YczU2UEYzODQ/edit
  - Jeremy Gibbons: Algorithm Design with Haskell
    https://www.youtube.com/watch?v=JJv74IJUp4E
  - NYC Haskell User's Group
    https://www.youtube.com/channel/UCzNYHE7Kj6pBqq5h8LG9Zcg
* TODO Book: Haskell School of Music
** 1 Computer Music, Euterpea, and Haskell
*** 1.1 The Note versus Signal Dichotomy
- High/Low    level music concepts a.k.a.
  Note/Signal level music concepts
- Note: pitch and volume
- Bit depth: storage size of a single sample.
  Typically 16bits (2bytes) or 32bits (4bytes)
*** 1.2 Basic Principles of Programming
- Measures of success: correctness, efficiency, clarity
- Code often represents the author's thought process...A conventional
  musical score does not.
*** 1.3 Computation by Calculation
- In general, it is best to search first for an elegant (and correct!) solution to a problem, and later refine it for better performance.
  “Get it right first!”
- ~unfolding~ a function, is when we replace the arguments in the definition
  simple x y z = x * (y + z)
  simple 3 9 5
  > 3 * (9 + 5)
  > 42
- "simple 3 9 5 ~evaluates~ to 42"
*** 1.4 Expressions and Values
- note names are called pitch classes
- ~expressions~ entities that can be evaluated
- ~value~ are expressions that cannot be further evaluated.
  ex: 1,[1,2],(3,3),'C',"hello"
- ~diverging~ expressions are those that do not have an end
  ex: f x = f (x - 1)
  evaluate to "Bottom" value _|_
*** 1.5 Types
- Atomic or Structured
- Type Signature
  'D' :: Char
      :: reads as "has type"
   D  :: PitchClass
- Elements on a List are the same Type
- Elements on a Tuple could be different Types
*** 1.6 Function Types and Type Signatures
#+begin_src haskell
simple :: Int -> Int -> Int -> Int
simple x y z = x * (y + z)
#+end_src
- "it is a good habit to first write down the type of each function you
   are planning to define, as a first approximation to its full specification"
- f :: T1 -> T2 -- In mathematics T1 is the ~domain~ and T2 is the ~range~
- ~function application~ aka calling the funtion, has always higher precedence on application
- symbol based functions are usually called ~operators~ and are ~infix~
  - Are defined between parentheses
  - (+) :: Integer -> Integer -> Integer
- ' is a valid alphanumeric value, so f' and f'' are valid function names
*** 1.7 Abstraction, Abstraction, Abstraction
- “What are the three most important ideas in programming?" (see title)
**** 1.7.1 Naming
#+begin_src haskell
pi :: Double
pi = 3.1415
-- two definitions in one
concertA,a440 :: (PitchClass, Octave)
concertA = (A,4)
a440     = (A,4)
-- Vars
c = 42 -- is called a ~binding~
x    = let area = pi * r ** 2
       in f area + g area
#+end_src
- A4 is usually called "concert A" (because it is often used as a the note to which an orchestra
  tunes its intruments or "A440")
- {- MULTILINE COMMENT IN HASKELL -}
**** 1.7.2 Functional Abstraction
#+begin_src haskell
x = let areaF r = pi * r ** 2
    in f (areaF r1) + g (areaF r2)
note :: Dur -> Pitch -> Music Pitch
rest :: Dur -> Music Pitch
(:+:) Music Pitch -> Music Pitch -> Music Pitch -- Sequentially
(:=:) Music Pitch -> Music Pitch -> Music Pitch -- Simultanious
trans :: Int -> Pitch -> Pitch
-- Harmonizing each pN note with a third
qn = 1/4
mel = (note qn p1 :=: note qn (trans (-3) p1)) :+:
      (note qn p2 :=: note qn (trans (-3) p2)) :+:
      (note qn p3 :=: note qn (trans (-3) p3))
-- In a function
hNote :: Dur -> Pitch -> Music Pitch
hNote d p = note d p :=: note d (trans (-3) p)
-- applied
mel :: Music Pitch
mel = hNote qn p1 :+: hNote qn p2 :+: hNote qn p3
#+end_src
**** 1.7.3 Data Abstraction
- The order of ~associativity~ can be defined, either left, right or none.
- (:) operator has right associativity
#+begin_src haskell
hList          :: Dur -> [Pitch] -> Music Pitch
hList d []     = rest 0
hList d (p:ps) = hNote d p :+: hList d ps
--
mel = hList qn [p1,p2,p3]
#+end_src
*** 1.8 Haskell Equality versus Musical Equality
- 2 different melodies can be musically equivalent while being not equal by the language
- A melody can be interpreted either by his
  ~polyphonic~: grouping notes playing at the same time
  ~contrapuntal~: grouping by each voice
*** 1.9 Code Reuse and Modularity
- being able to re-use code is called ~modularity~
*** 1.10 [Advanced] Programming with Numbers 1
- Int data type is of size word (architecture dependent, 32 or 64 bits) (use Integer instead)
- In mathemathics, ~numerical analisys~ is concerned with numerical incongrueties
- If real-number acuraccy is important, be wary of floats
#+begin_src haskell
5 ∗ (−0.123456 + 0.123457)       :: Float ⇒ 4.991889e−6
5 ∗ (−0.123456) + 5 ∗ (0.123457) :: Float ⇒ 5.00679e−6
#+end_src
** 2 Simple Music
*** 2.1 Preliminaries
#+begin_src haskell
-- Type Synonyms
type Octave = Int
type Pitch  = (PitchClass, Octave)
type Dur    = Rational
-- Algebraic data type
data PitchClass = Cff | Cf | C | Dff | Cs | Df | Css | D | Eff | Ds
                | Ef | Fff | Dss | E | Ff | Es | F | Gff | Ess | Fs
                | Gf | Fss | G | Aff | Gs | Af | Gss | A | Bff | As
                | Bf | Ass | B | Bs | Bss
qn :: Dur
qn = 1/4
#+end_src
- data NAME = CONSTRUCTORS
  data Bool = False | True
*** 2.2 Notes, Music, and Polymorphism
#+begin_src haskell
-- (Value) Constructor
data Primitive = Note Dur Pitch |
                 Rest Dur
-- Type Constructor: more generic, polymorphic
data Primitive a = Note Dur a |
                   Rest Dur
-- Note :: Dur -> a -> Primitive a
-- Rest :: Dur ->      Primitive a
--
-- Another ~type constructor~, this time also recursive (aka inductive data type)
data Music a =
    Prim (Primitive a)
  | Music a :+: Music a
  | Music a :=: Music a
  | Modify Control (Music a)
-- Prim   :: Primitive a        -> Music a
-- (:+:)  :: Music a -> Music a -> Music a
-- (:=:)  :: Music a -> Music a -> Music a
-- Modify :: Control -> Music a -> Music a
#+end_src
- ~fixity declaration~
  infixr 5 :+:,:=:
- Data constructors
  - are still functions and have a type
  - are an example of polymorphic functions ~type abstraction~
#+begin_src haskell
data Control =
    Tempo      Rational          -- scale the tempo
  | Transpose  AbsPitch          -- transposition
  | Instrument InstrumentName    -- instrument label
  | Phrase     [PhraseAttribute] -- phrase attributes
  | KeySig     PitchClass Mode   -- key signature and mode
  | Custom     String            -- custom label
data Mode = Major | Minor | Ionian | Dorian | Phrygian | Lydian
             | Mixolydian | Aeolian | Locrian
             | CustomMode String
data InstrumentName = AcousticGrandPiano | BrightAcousticPiano ...
#+end_src
*** 2.3 Convenient Auxiliary Functions

*** 2.4 Absolute Pitches
- LIST !! N
  [C,D,E] !! 1 => D
* TODO Book: Real World Haskell
https://github.com/tssm/up-to-date-real-world-haskell/
** 7
- ~Type classes~ provide ad-hoc polymorphism
  - Can define default "implementations" for the class
- ~Types~ are made instances of a particular type class
- Typeclasses
  - Show: Used to display your custom types. ghci repl uses it.
    #+begin_src haskell
data Color = Red | Green | Blue

instance Show Color where
  show Red = "rojo"
  show Green = "verde"
  show Blue = "azul"
    #+end_src
* DONE Book: Seven Languages in 7 weeks
** Haskell
- "In Haskell, indentation is significant." (?
- on Haskell, IF is a function, not a control structure, it returns a value.
- "." for function composition
  second = head . tail
- On ghci console
  > :set +t
- A partial applied function is called ~section~
- ~where~ on function definition can define local functions too
- every function does have 1(one) parameter
  - the process of reducing a function of N parameters to N of 1 param is ~currying~
#+NAME: single-line vs multi-line pattern-matching vs guards
#+begin_src haskell
fact x = if x == 0 then 1 else fact (x - 1) * x

factorial :: Integer -> Integer
factorial 0 = 1
factorial x = x * factorial (x - 1)

factorio :: Integer -> Integer
factorio x
  | x > 1     = x * factorio (x - 1)
  | otherwise = 1
#+end_src
* TODO Interview: Michael Snoyman: From Haskell to Rust?
  #+DATE: Sep 13, 2020
  #+URL: https://www.youtube.com/watch?v=HKXmEFvsi6M
- Creator of Yesod/Stack
- VP at "FP Complete"
- Moved away from GHCjs
  - Purescript/Halogen
- Rust, has recently has async/await (it was "callback hell")
- Monads reinventions??: promises (js), scala (futures)
- "GO says, we don't trust the developers. Or I don't wanna bother the programmers with stuff"
  - Like overload of operators
- TALK ABOUT MONADS????
- RESUME 20:00
* TODO Course: Haskell by Bartosz Milewski https://www.youtube.com/playlist?list=PL0pwx9zqJ9IamHxRXTf34dC3JeQ2oYmfJ
** 1-1 => Why Haskell? https://www.youtube.com/watch?v=N6sOMGYsvFA
- Course based on "Parallel and concurrent programming" Oreilly book
- Based on math, lambda calculus
- lists are the core DS while in other langs would be an array
** 1-2 => Functions https://www.youtube.com/watch?v=ybba5tcOeEY
- keep the more reocurring thing simple
  - in morse code (? the letter "e" is just a dot
- ~function application~ is the strongest binding
  7 - f x y z - 1
- no variables in haskell, they are nonary functions
- load file
  #+begin_src haskell
sqDist :: Num a => a -> a -> a
sqDist x y = x^2 + y ^2

main = print (sqDist 3 4)
  #+end_src
  #+begin_src
  Prelude> :l main.hs
  [1 of 1] Compiling Main             ( main.hs, interpreted )
  Ok, one module loaded.
  *Main> main
  25
  *Main> :t sqDist
  sqDist :: Num a => a -> a -> a
  #+end_src
- there are things that are not expressable in haskell, that are left to the used (axioms)
- main :: IO ()
  print :: Show a => a -> IO ()
  putStrLn :: String -> IO ()
- ghci commands
  #+begin_src
  :l FILENAME
  :r reload
  :t expand type
  :q quit
  :i info
  #+end_src
- Num is a ~class of types~, Double is type
** 2-1 => More Functions
- on tuples: fst, snd
- lowest possible binding is $
- (.) ~function composition~, very high precedence
- spaces kind of does't matter at times, precedence does
- sq . sqDist -- reads "sq after sqDist"
- the definition of a function is with a -> b -> c because
  - ~partial application~ happens automatically
- using a tuple as an argument, is not convenient for partial application
- polymorphism:
  - parametric: "it can handle values uniformly without depending on their type.
                 Parametric polymorphism is a way to make a language more expressive
                 while still maintaining full static type-safety."
                 ex: map function
  - adhoc: different behaviour for different types of arguments
- code
  #+begin_src haskell
-- using ($)
main = print $ sqDist 3 4
-- using ($) when accepting a tuple
sqDist (x,y) = x^2 + y ^2
main = print $ sqDist $ (3,4)
-- replacing parens
sq x = x * x
main = print $ sq $ 2 + 3
main = print $ sq (2 + 3)
-- NOT the same
main = print $ sq 2+3
-- Partial Application in Function composition
-- pt means here PA^
--dist pt = sqrt $ sqDist pt
dist = sqrt . sqDist
  #+end_src
** 2-2 => Product data types https://www.youtube.com/watch?v=a6IkhX1zgXI
- (+) 3 2 -- changingn infix to prefix operator with parens
- inc x = 1 + x
  inc x = (+) 1 x
  inc   = (+ 1)    -- x cancells out
- partial application of an operator is called ~operator section~
- ELM isn't lazy evaluated
- ~Void~ is type with no elements
- ~Unit~ is the "Singleton" Type denoted by "()", tuple of 0 elements
- Define a ~new type~ with:
  > data Unit = CONSTRUCTOR
              = U
  > data ()   = ()
    TYPE      = DATA
    CONSTRUCTOR CONSTRUCTOR
- Different namespace for types and data constructors
- Every constructor is a function (capitalized for some reason).
  > data Product a b = P a b
  > :t P
  P :: a -> b -> Product a b
- ~Destructuring~ happens with the Data Constructor
  > f (P x y) = x + y
- When you have more tha 2 components, you are better using a ~record~ where fields are named
- 2 ways of constructing new data types??
** 3-1 => Laziness https://www.youtube.com/watch?v=jWrRs-l8C1U
- "In haskell we don't want to use many names, because the polute the namespace"
- ~*~ in type definitions means "any type"
- use ~:k~ to get the kind of the argument
- > :t (,) -- Data Constructor
  (,) :: a -> b -> (a, b)
  > :k (,) -- Type Constructor
  (,) :: * -> * -> *
- "if you define a data type in Haskell you can promote it to a kind"????
- Haskell by default is lazy evaluated
- :sprint prints a value without evaluating it
- Haskell has ~polymorphic values~, so we need to type "x" here
#+begin_src
> let x = 1 + 2 :: Int
> :sprint x
x = _
> x
3
> :sprint x
x = 3
#+end_src
- We can for eager evaluation by using ~seq~, it "sequences" the arguments, it evaluates the 1st before the 2nd
#+begin_src
> let x = 2 + 3 :: Int
> let y = x + 1
> print (seq y ())
()
> :sprint y
y = 6
#+end_src
- swap
#+begin_src
Prelude> import Data.Tuple
Prelude Data.Tuple> let z = swap (x,x+1)
Prelude Data.Tuple> :sprint z
z = _
#+end_src
** 3-2 => Sum types https://www.youtube.com/watch?v=MagayXbH4oY
- Unlike product types, on ~sum types~ we can have either from a or b
  - In terms of sets is like a "discriminated union", aka "tagged union"
- "|" as in OR
- Either is used to return either an error or a valid output. We don't use a pair.
#+begin_src haskell
data Either a b = Left a | Right b
safeSqrt :: Either String Double -> Either String Double
safeSqrt (Left str) = Left str
safeSqrt (Right x) = if x < 0
                      then Left "Error"
                      else Right (sqrt x)
-- Alternative using case
safeSqrt sx =
    case sx of
        Left str -> Left str
        Right x -> if x < 0
                   then Left "Error"
                   else Right (sqrt x)
#+end_src
- What in other languages would be an "enumeration type" here is just another sum
  - data Bool = True | False
- Algebraic data types???
#+begin_src haskell
data X a = X a | Y Void -- a + 0 = a
type Y a = (a, ())      -- a * 1 = a
type Z a = (a, Void)    -- a * 0 = 0
#+end_src
** 4-1 => Recursion https://www.youtube.com/watch?v=F-nAAIH4e2s
- data List a = Nil | Cons a (List a)
- ~:~ Cons operator
- ~..~ range operator for lists
  [0..]         => PRINTSUNTILSTOP
  [0..4]        => [0,1,2,3,4]
  take 4 [0..]  => [0,1,2,3]
** 4-2 => Functors
** 5-1 => Monads
** 5-2 => The Monad Class
** 6-1 => IO Monad
** 6-2 => Parallellism and Concurrency
** 7-1 => The Eval monad
** 7-2 => Parallel sudoku solver, strategies, overview of Haskell parallelism.
** 8-1 => Concurrent Haskell, MVars
** 8-2 => Software Transactional Memory
* TODO Videos: HaskellRank by tsoding
https://www.youtube.com/playlist?list=PLguYJK7ydFE4aS8fq4D6DqjF6qsysxTnx
** DONE HackerRank in Haskell
- Two number from stdin and print the sum
- We go from an expression that we can use on the repl to a function. $ -> .
- Functions: ($) (.) interact words read map sum show tail
#+NAME: idiomatic #1
#+begin_src haskell
main = interact $ show . sum . map read . words
#+end_src
#+NAME: idiomatic #2
#+begin_src haskell
main = interact $ show . sum . map read . tail . words
#+end_src
** DONE Grading Students
- (``) , guards, where, unlines
#+begin_src haskell
round5 :: Int -> Int
round5 x
    | x >= 38 && (m5 - x) < 3 = m5
    | otherwise               = x
    where m5 = x + (5 - x `mod` 5)

solve :: [Int] -> [Int]
solve xs = map round5 xs

main = interact $ unlines . map show . solve . map read . tail . words
#+end_src
** Apples and Oranges

** Code Warrior
** Between Two Sets
** Fold
** Playing Basketball with Kangaroo
** Purely Functional Solutions to ImperaSolving Russian Calendar Problems in Haskell
** The Usefulness of Maybe monad
** Tracking Hikes with Haskell
** Treating Lists as Monads
** Solving Magic Square using Functional Programming
** Brute-forcing all Magic Squares
** CodeWars Strikes Again
