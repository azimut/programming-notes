- NOT A 4k, ray tracing on microcontrollers with Ulisp http://www.ulisp.com/show?2NWA
- NOT A 4K, but a raymarched donut made in C https://www.a1k0n.net/2011/07/20/donut-math.html
- Article: Rust 151Bytes http://mainisusuallyafunction.blogspot.com/2015/01/151-byte-static-linux-binary-in-rust.html
- Synth https://github.com/askeksa/Oidos
- Intro 1k (ASM,sdl,opengl) https://github.com/baines/demostuff
- Intro 4k (D) https://github.com/kubo39/tiny-d-demo
- Intro 4k https://github.com/xyproto/tinytriangle 2012
- Intro 4k https://github.com/lnqs/intrusion
- Intro 4k https://github.com/Sixstring982/4k
- Intro 4k https://github.com/sandsmark/invitro
- Intro 4k https://github.com/xyproto/shrinky-intro
- Template https://github.com/shizmob/liner
- Template https://gitlab.com/PoroCYon/linux-4k-intro-template
- Tool https://github.com/stfsux/rld
- http://www.sizecoding.org/wiki/Linux
- 4k https://linux.weeaboo.software/Home
- (C/sstrip/xz/clang/32/ALSA/SDL/GL) https://github.com/grz0zrg/tinycelfgraphics
- Article http://glprogramming.com/red/chapter07.html
- Article http://twiren.kapsi.fi/linux4k.html
- Article https://github.com/faemiyah/dnload
- Article https://benjamin.computer/posts/2020-07-15-nova.html
- Article http://www.muppetlabs.com/~breadbox/software/tiny/teensy.html
- Article http://bruxy.regnet.cz/web/linux/EN/linux-demoscene/
- Article https://phresnel.org/gpl/4k/ntropy2k7/
- Article http://www.sizecoding.org/wiki/Main_Page
- Article https://int21.de/linux4k/
- Article https://raw.githubusercontent.com/gomson/TimothyLottes.github.io/d3d7e3f286a0066bec9b831c57ebcbe8f0ebdfd8/20140413.html
- Article https://www.alsa-project.org/alsa-doc/alsa-lib/pcm.html
- Article https://stackoverflow.com/questions/10551665/how-to-create-4kb-linux-binaries-that-render-a-3d-scene
- Article https://raw.githubusercontent.com/gomson/TimothyLottes.github.io/d3d7e3f286a0066bec9b831c57ebcbe8f0ebdfd8/20140413.html
  Manually dlopen() libGL.so
- Article http://git.mikejsavage.co.uk/medfall/file/linux_audio_output.cc.html
  Manually dlopen() libasound.so (ALSA)
- Tool https://github.com/Dav1dde/glad
  Loader-Generator for GL/GLES/EGL/GLX/WGL
  https://github.com/Dav1dde/glad/issues/152
- Tool https://github.com/DanielGibson/Linux-app-wrapper
  A wrapper to conditionally override some Linux system libs with newer ones
* DONE Video: (2006) Linux 4k coding - Markku Reunanen
  slides http://ftp.kameli.net/pub/fit/misc/presis_asm06.pdf
  talk https://www.youtube.com/watch?v=-UQSiRg8Ra0
- 6:30 Skip demos
- Languages: ASM, C, C++(too much overhead, difficult to interface with ASM)
- ASM: soft synth, system code and startup.
    C: Effect code
- GCC: -Os was worst than -O1
       -ffast-math
       -fshort-double (dangerous!)
       -nostdlib
       -fno-inline, -fmove-all-movables, -fpeephole2
                    -fforce-mem, -fexpensive-optimizations
- gcc version 3.2 (unlike 3.3)
- Libraries: Dynamically Loaded
  - "Using an external library *function* generates about 70byte overhead
     if done via standard dynamic linkage". Not per call, but per function.
  - reduced to 20bytes by opening the library manually with *dlsym* and *dlopen*
- Using SDL is better than dealing with GLX or GLUT
- Open the libraries ourselfes and call them through function pointers.
  dlopen(LIBRARY_NAME)
  dlsym(FUNCTION_NAME)
  Done in ASM.
- Compression
  - The final demo file is a shell script.
    - With some stub code and the compressed binary (tail|zcat|chmod+x|RUN)
- Code level tricks
  - Remove subroutines, messier
  - -fshort-double
  - Static tables: declaring local arrays as *static* removes their init code yielding some bytes.
  - Custom Random: 10 bytes
    #+begin_src asm
    rnd: mov eax, [rndi]
         add eax,RANDOM_SEED
         xor eax,RANDOM_SEED
         ror eax,1
         mov [rndi],eax
         ret
    rndi: dd RANDOM_SEED
    #+end_src
- Tools: NASM, ELF Kickers (sstrip), GC Masher (compiles with different params to know the smaller)
* Video: (2019) Revision - Intricacies of sizecoding on Linux
  https://www.youtube.com/watch?v=a03HXo8a_Io
  https://github.com/Shizmob/smol
  https://pcy.ulyssis.be/pres/Lin.pdf
  - Mentioned, renders through tcp https://github.com/graphitemaster/bbgl
  - Mentioned, Byte Optimized Linked https://www.alrj.org/pages/bold.html
** Environment (Ubuntu OS)
  - default: libopus, imagemagick, fftw, espeak, SDL, libgompl
  - glibc uses *ld.so* as dynamic linked
  - you can reduce the size by compiling to 32bits
    - but it doesn't come with x86 (nor x32)
  - libGL needs to be dynamic linked
  - To know the libraries that we "know" that are going to be around for a long time
    The more dependencies the more likely to stay.
    apt-rdepends -d --state-follow=Installed <pkg>
** ELF
   https://cseweb.ucsd.edu/~ricko/CSE131/teensyELF.htm
   http://www.muppetlabs.com/~breadbox/software/tiny/teensy.html
   https://www.pouet.net/prod.php?which=3696
   - ELF Headers
     Static: kernel loads it and does some checking
        - The kernel doesn't really look at "half of them"
     Dynamic: kernel invokes the ld.so
        - ld.so check some more
** Syscalls
   Static: done directly by the kernel
   Dynamic: deletegated to the ld.so
   #+begin_src
   - Check parsing code of either, *unparsed field* to code (of zeros)
   - Parsed but controllable fields (e_entry)
   #+end_src
** Entry to sizecoding
   - Default entry point of C code is *crt0/crt1.so*
   - Roll your own *-nostartfiles*
* Video: (2019) Executable Code Golf: Making Tiny Binaries for Constrained Systems
  for ~8k demos
  https://www.youtube.com/watch?v=J5WX-wN_RKY
  https://github.com/negge/xlink
  - Binary Dropping (circa 1995), uses lz
    #+begin_src
    cp $0 /tmp/M; (sed ld $0|lzcat)>$_;$_;exit
    T=/tmp/i;tail -n+2 $0|zcat>$T;chmod +x $T;$T;rm $T;exit
    sed ld $0|xzcat>/tmp/C;chmod +x /tmp/C;/tmp/C|aplay -f cd;exit
    #+end_src
  - Windows compressors: Crinkler, kkrunchy
  - xlink: linux compression
    - PAQ1 based compression (adaptable to the type of data)
    - Link-time reordering+transformations to improve compression
  - 11:47
* Video: (2019) Size coding på Linux – Knut Arild Erstad – RevolverConf 2019.2
  https://github.com/knutae/revolverconf-2019.2
  https://www.youtube.com/watch?v=UgNLULCwKgo
* DONE Video: (2021) Lovebyte 256 Second Seminar: Linux Sizecoding, by: PoroCYon / K2^TiTAN
  https://www.youtube.com/watch?v=cvsH_rXlMKg
  - For 256bytes demos
  - fbdev (/dev/fbo)
    vfb (for testing)
    vcsa (tile based)
  - sound
    - alsa (with syscalls is complicated)
    - OSS deprecated (disable by default /dev/dsp)
    - use |aplay
  - call syscall manually
    - can get away with 32-bit code in 64-bit OS
    - open() ioctl() mmap() manually
    - ABI and LSB doc http://refspecs.linuxfoundation.org
  - NASM
  - /usr/include/asm/unistd*.h
  - ELF Header
    - 52b/65b (ehdr) + 32b/54b (phdr)
  - Compression
    - Shell Dropper
    - dnload
  - Example: "Blin Elfom" by YOLP (2011)
    https://www.youtube.com/watch?v=c0Vh6u_Ze48
* LIBC static linking
  - https://akkadia.org/drepper/no_static_linking.html
  - https://sta.li/faq/
  - MUSL? dlopen() https://github.com/pfalcon/foreign-dlopen
  - https://www.arp242.net/static-go.html
    Go creates static binaries by default unless you use cgo to call C
    code, in which case it will create a dynamically linked
    library.
  - https://news.ycombinator.com/item?id=23816748
    Yep. The glibc tries very hard to avoid static linking (since the
    infamous times of Ulrich Drepper). It is almost as if they hated
    static linking for some personal reasons, and then they artificially
    add the NSS and locale excuses that make it impossible.

    Yet you can still compile a static executable that calls the dlopen
    function. And you can also select (by using some -B and -W magic
    options) exactly which libraries you want to link statically and
    dynamically on your executable. It is a bit painful but it works. The
    only thing that does not work is when you rely on GPU code, where your
    program needs to be linked directly to specific graphics drivers. I
    hope in a few years the kernel itself will allow a gpu abstraction for
    that to work.

    Great point about musl. To distribute (your) program as a linux static
    binary, write it in standard C and compile it using musl.

* Article: NIM 160Bytes
  https://github.com/def-/nim-binary-size/
  http://hookrace.net/blog/nim-binary-size/
  1. 160K initial
     - -d:release
     - --opt:size
     - strip -s
  2. LIBC Start by replacing glibc with musl gcc, statically
  3. GC Disable
     --gc:none
  4. Disable dynamic memory, error handling (needs to provide rawoutout() and panic())
     --os:standalone
  5. LIBC: Remove libc dependency, we remove the print
     --passL:-nostdlib
     - We need to supply a _start function, and exit the program with a syscall
  6. GCC Put function and data items into separate sections
     -ffunction-sections
     -fdata-sections
  7. LD and at the linking sections
     --passL:-Wl,--gc-sections
  8. Custom LD and ELF header, we create the object
     ld/objcopy/nm/nasm
     --app:staticlib
     https://github.com/def-/nim-binary-size/blob/master/elf.s
     https://github.com/def-/nim-binary-size/blob/master/script.ld
     #+begin_src bash
     nim --app:staticlib --os:standalone -d:release \
         --noMain \
         --passC:-ffunction-sections \
         --passC:-fdata-sections \
         --passL:-Wl,--gc-sections c hello
     ld --gc-sections -e _start -T script.ld \
        -o payload hello.o
     objcopy -j combined -O binary \
           payload payload.bin
     ENTRY=$(nm -f posix payload | grep '^_start' | awk '{print $3}')
     nasm -f bin -o hello -D entry=0x$ENTRY elf.s
     chmod +x hello
     #+end_src
